{"version":3,"file":"static/js/601.057f8d05.chunk.js","mappings":"2JAOaA,EAAb,WAGE,WAAYC,IAAe,oBAF3BC,QAE0B,EACxBC,KAAKD,IAAKE,EAAAA,EAAAA,IAAOH,EAAM,EAAG,CACxBI,QADwB,SAChBH,EAAII,EAAYC,EAAYC,GAElC,IAF+C,EAEzCC,EAAaP,EAAGQ,iBAFyB,UAG5BD,GAH4B,IAG/C,gCAAWR,EAAX,QACEC,EAAGS,kBAAkBV,IAJwB,8BAM/C,IAAMW,EAAcV,EAAGW,kBAAkB,UAAW,CAClDC,QAAS,SAEXF,EAAYG,YAAY,QAAS,QAAS,CAAEC,QAAQ,IACpDJ,EAAYG,YAAY,YAAa,YAAa,CAAEC,QAAQ,IAEtCd,EAAGW,kBAAkB,YAAa,CACtDC,QAAS,aAlBnB,6EAwBE,WAAkBG,EAAeC,EAAcC,GAA/C,6FACmBhB,KAAKD,GADxB,cACQA,EADR,OAEQkB,EAAKlB,EAAGM,YAAY,UAAW,aAC/Ba,EAAQD,EAAGE,YAAY,WAH/B,SAIYD,EAAME,IAAIL,GAJtB,0EASMC,EAAOK,OAAOC,aAAeN,EAAOM,cAChCC,EAAY,IAAIC,WAAWR,EAAOM,aAC9BG,IAAIT,GACdA,EAASO,GAZb,UAeQxB,EAAG2B,IAAI,UAAW,CACtBZ,MAAAA,EACAC,KAAAA,EACAC,OAAAA,EACAW,UAAWC,KAAKC,QAnBpB,iDAxBF,sHA+CE,WAAiBf,GAAjB,kFACQgB,EAAiBC,YAAYC,KAAKlB,GAD1C,SAEmBd,KAAKD,GAFxB,cAEQA,EAFR,gBAGuBA,EAAGkC,gBAAgB,UAAW,QAASH,GAH9D,cAGQI,EAHR,yBAISA,EAAOC,KAAI,SAACC,GAAD,OAAOA,EAAEpB,WAJ7B,gDA/CF,8GAsDE,WAAaF,GAAb,yHACmBd,KAAKD,GADxB,cACQA,EADR,gBAGyBA,EAAGqB,IAAI,YAAaN,GAH7C,OAGQuB,EAHR,OAMQP,EAAiBC,YAAYC,KAAKlB,GAClCwB,EAAU,GACZC,EAAyB,EAR/B,8BAS6BxC,EAAGM,YAAY,WAAWa,MAAMsB,MAAM,SAASC,QAAQX,IATpF,oFASmBY,EATnB,QAUIJ,EAAQK,KAAKD,EAAOE,MAAM5B,QAC1BuB,EAAiBM,KAAKC,IAAIJ,EAAOE,MAAMjB,UAAWY,GAXtD,oTAiBE,IAFMQ,EAAiB,IAAIC,IACrBC,EAAgB,IAAID,IAC1B,MAAqBV,EAArB,eAAWtB,EAAmB,KACtBkC,EAAIC,IAAAA,aAAuBnC,GACjCiC,EAAcxB,IAAIyB,EAAEnC,KAAOC,GAC3B+B,EAAetB,IAAIT,EAAQkC,GApB/B,OAsBQE,EAAgBC,EAAgBf,GAAS,SAAAgB,GAE7C,OADUP,EAAe3B,IAAIkC,GACpBC,KAAKpB,KAAI,SAAAqB,GAAC,OAAIP,EAAc7B,IAAIoC,SAxB7C,kBA2BS,CACLC,cAAa,OAAEpB,QAAF,IAAEA,OAAF,EAAEA,EAAUoB,cACzBnB,QAASc,EACTb,eAAAA,IA9BJ,6EAtDF,oHAwFE,WAAmBzB,GAAnB,yGAC2Dd,KAAK0D,OAAO5C,GADvE,mBACU2C,EADV,EACUA,cAAenB,EADzB,EACyBA,QAASC,EADlC,EACkCA,iBAE5BD,EAAQqB,OA7FY,KA0F1B,wDAKMC,EAAMH,EAAgBN,IAAAA,KAAeM,GAAiBN,IAAAA,OAC1DS,EAAMT,IAAAA,aAAuBS,EAAKtB,GAAS,GAErCuB,EAAoBV,IAAAA,KAAeS,GAR3C,UASmB5D,KAAKD,GATxB,eASQA,EATR,iBAUQA,EAAG+D,IAAI,YAAa,CACxBhD,MAAAA,EACA2C,cAAeI,EACflC,UAAWC,KAAKC,QAbpB,eAgBQkC,EAAqBhC,YAAYiC,WAAWzB,GAC5CC,EAAQzC,EACXM,YAAY,UAAW,aACvBa,MAAMsB,MAAM,aAnBjB,UAqBqBA,EAAMyB,WAAWF,GArBtC,QAqBMrB,EArBN,mBAsBSA,EAtBT,wBAuBIA,EAAOwB,SAvBX,UAwBmBxB,EAAOyB,WAxB1B,QAwBIzB,EAxBJ,wEAxFF,8DAqHA,SAASW,EAAmBe,EAASC,GAKnC,IAJA,IAAMC,EAAc,GAChBC,GAAQ,EACNC,EAAW,IAAIC,IAAIL,GACnBM,EAAY,IAAID,IACfD,EAASG,MAAM,CAGpB,GADAC,EADUJ,EAAStC,SAAS2C,OAAOjC,QAE9B2B,EACH,MAAM,IAAIO,MAAM,aAGpB,OAAOR,EAEP,SAASM,EAAMG,GACb,GAAKP,EAASQ,IAAID,GAClB,GAAIL,EAAUM,IAAID,GAChBR,GAAQ,MADV,CAIAG,EAAUhD,IAAIqD,GANK,gBAOHV,EAAcU,IAPX,IAOnB,2BAAkC,CAChCH,EADgC,UAPf,8BAUnBF,EAAUR,OAAOa,GACjBP,EAASN,OAAOa,GAChBT,EAAO3B,KAAKoC,KC/IhB,IAAMhF,EAAK,IAAIF,EAAG,YAElBoF,KAAKC,iBAAiB,WAAW,SAACC,GACnBA,EAAEC,MAAM,GAChBC,UAAY,SAACF,GAChB,IAAOrE,EAASqE,EAAEG,KAAXxE,MACPf,EAAGwF,aAAazE,SCZhB0E,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,IAOV,OAHAE,EAAoBL,GAAUM,KAAKF,EAAOD,QAASC,EAAQA,EAAOD,QAASJ,GAGpEK,EAAOD,QAIfJ,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAI,WAGvB,IAAIC,EAAsBV,EAAoBW,OAAER,EAAW,CAAC,MAAM,WAAa,OAAOH,EAAoB,SAE1G,OADAU,EAAsBV,EAAoBW,EAAED,I,WChC7C,IAAIE,EAAW,GACfZ,EAAoBW,EAAI,SAAS9B,EAAQgC,EAAUC,EAAIC,GACtD,IAAGF,EAAH,CAMA,IAAIG,EAAeC,EAAAA,EACnB,IAASC,EAAI,EAAGA,EAAIN,EAAS1C,OAAQgD,IAAK,CACrCL,EAAWD,EAASM,GAAG,GACvBJ,EAAKF,EAASM,GAAG,GACjBH,EAAWH,EAASM,GAAG,GAE3B,IAJA,IAGIC,GAAY,EACPC,EAAI,EAAGA,EAAIP,EAAS3C,OAAQkD,MACpB,EAAXL,GAAsBC,GAAgBD,IAAaM,OAAOC,KAAKtB,EAAoBW,GAAGY,OAAM,SAASC,GAAO,OAAOxB,EAAoBW,EAAEa,GAAKX,EAASO,OAC3JP,EAASY,OAAOL,IAAK,IAErBD,GAAY,EACTJ,EAAWC,IAAcA,EAAeD,IAG7C,GAAGI,EAAW,CACbP,EAASa,OAAOP,IAAK,GACrB,IAAIQ,EAAIZ,SACEX,IAANuB,IAAiB7C,EAAS6C,IAGhC,OAAO7C,EAzBNkC,EAAWA,GAAY,EACvB,IAAI,IAAIG,EAAIN,EAAS1C,OAAQgD,EAAI,GAAKN,EAASM,EAAI,GAAG,GAAKH,EAAUG,IAAKN,EAASM,GAAKN,EAASM,EAAI,GACrGN,EAASM,GAAK,CAACL,EAAUC,EAAIC,I,GCJ/Bf,EAAoBV,EAAI,SAASe,GAChC,IAAIsB,EAAStB,GAAUA,EAAOuB,WAC7B,WAAa,OAAOvB,EAAgB,SACpC,WAAa,OAAOA,GAErB,OADAL,EAAoBvC,EAAEkE,EAAQ,CAAEE,EAAGF,IAC5BA,GCLR3B,EAAoBvC,EAAI,SAAS2C,EAAS0B,GACzC,IAAI,IAAIN,KAAOM,EACX9B,EAAoB+B,EAAED,EAAYN,KAASxB,EAAoB+B,EAAE3B,EAASoB,IAC5EH,OAAOW,eAAe5B,EAASoB,EAAK,CAAES,YAAY,EAAMtG,IAAKmG,EAAWN,MCJ3ExB,EAAoBkC,EAAI,GAGxBlC,EAAoBN,EAAI,SAASyC,GAChC,OAAOC,QAAQC,IAAIhB,OAAOC,KAAKtB,EAAoBkC,GAAGI,QAAO,SAASC,EAAUf,GAE/E,OADAxB,EAAoBkC,EAAEV,GAAKW,EAASI,GAC7BA,IACL,MCNJvC,EAAoBwC,EAAI,SAASL,GAEhC,MAAO,aAAeA,EAAf,sBCFRnC,EAAoByC,SAAW,SAASN,KCDxCnC,EAAoB+B,EAAI,SAASW,EAAKC,GAAQ,OAAOtB,OAAOuB,UAAUC,eAAetC,KAAKmC,EAAKC,ICA/F3C,EAAoB8C,EAAI,I,WCIxB,IAAIC,EAAkB,CACrB,IAAK,GAkBN/C,EAAoBkC,EAAEhB,EAAI,SAASiB,EAASI,GAEvCQ,EAAgBZ,IAElBa,cAAchD,EAAoB8C,EAAI9C,EAAoBwC,EAAEL,KAK/D,IAAIc,EAAqBzD,KAA2B,qBAAIA,KAA2B,sBAAK,GACpF0D,EAA6BD,EAAmB/F,KAAKiG,KAAKF,GAC9DA,EAAmB/F,KAzBA,SAAS2C,GAC3B,IAAIgB,EAAWhB,EAAK,GAChBuD,EAAcvD,EAAK,GACnBwD,EAAUxD,EAAK,GACnB,IAAI,IAAII,KAAYmD,EAChBpD,EAAoB+B,EAAEqB,EAAanD,KACrCD,EAAoBQ,EAAEP,GAAYmD,EAAYnD,IAIhD,IADGoD,GAASA,EAAQrD,GACda,EAAS3C,QACd6E,EAAgBlC,EAASyC,OAAS,EACnCJ,EAA2BrD,I,cCrB5B,IAAIT,EAAOY,EAAoBS,EAC/BT,EAAoBS,EAAI,WACvB,OAAOT,EAAoBN,EAAE,KAAK6D,KAAKnE,I,GCDdY,EAAoBS,I","sources":["db.ts","worker/index.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { openDB } from 'idb/with-async-ittr'\nimport type { IDBPDatabase } from 'idb/with-async-ittr'\nimport Automerge from 'automerge'\n\n// The limit of changes to keep before db.saveSnapshot will do serialization\nconst MAX_CHANGES_TO_KEEP = 100\n\nexport class DB {\n  db: Promise<IDBPDatabase<any>>\n\n  constructor(name: string) {\n    this.db = openDB(name, 1, {\n      upgrade(db, oldVersion, newVersion, transaction) {\n        // Reset db\n        const storeNames = db.objectStoreNames\n        for (const name of storeNames)\n          db.deleteObjectStore(name)\n\n        const changeStore = db.createObjectStore('changes', {\n          keyPath: 'hash',\n        })\n        changeStore.createIndex('docId', 'docId', { unique: false })\n        changeStore.createIndex('timestamp', 'timestamp', { unique: false })\n\n        const snapshotStore = db.createObjectStore('snapshots', {\n          keyPath: 'docId',\n        })\n      },\n    })\n  }\n\n  async storeChange(docId: string, hash: string, change: Uint8Array) {\n    const db = await this.db\n    const tx = db.transaction('changes', 'readwrite')\n    const store = tx.objectStore('changes')\n    if (await store.get(hash)) {\n      // We already have this change; do nothing.\n      return\n    }\n\n    if (change.buffer.byteLength !== change.byteLength) {\n      const newChange = new Uint8Array(change.byteLength)\n      newChange.set(change)\n      change = newChange\n    }\n\n    await db.add('changes', {\n      docId,\n      hash,\n      change,\n      timestamp: Date.now(),\n    })\n  }\n\n  async getChanges(docId: string) {\n    const singleKeyRange = IDBKeyRange.only(docId)\n    const db = await this.db\n    const values = await db.getAllFromIndex('changes', 'docId', singleKeyRange)\n    return values.map((v) => v.change)\n  }\n\n  async getDoc(docId: string) {\n    const db = await this.db\n    // Get latest snapshot if it exists\n    const snapshot = await db.get('snapshots', docId)\n\n    // Get outstanding changes\n    const singleKeyRange = IDBKeyRange.only(docId)\n    const changes = []\n    let lastChangeTime: number = 0\n    for await (const cursor of db.transaction('changes').store.index('docId').iterate(singleKeyRange)) {\n      changes.push(cursor.value.change)\n      lastChangeTime = Math.max(cursor.value.timestamp, lastChangeTime)\n    }\n\n    // topo sort changes to work around https://github.com/automerge/automerge/commit/62b9f780fe5fc066b03cd1df628c0b68b82d0a80\n    const decodedChanges = new Map<any, Automerge.Change>()\n    const changesByHash = new Map<string, any>()\n    for (const change of changes) {\n      const d = Automerge.decodeChange(change)\n      changesByHash.set(d.hash!, change)\n      decodedChanges.set(change, d)\n    }\n    const sortedChanges = topologicalSort(changes, c => {\n      const d = decodedChanges.get(c)!\n      return d.deps.map(h => changesByHash.get(h))\n    })\n\n    return {\n      serializedDoc: snapshot?.serializedDoc,\n      changes: sortedChanges,\n      lastChangeTime,\n    }\n  }\n\n  async saveSnapshot(docId: string) {\n    const { serializedDoc, changes, lastChangeTime } = await this.getDoc(docId)\n    // Bail out of saving snapshot if changes are under threshold\n    if (changes.length < MAX_CHANGES_TO_KEEP) return\n    // Create AM doc\n    let doc = serializedDoc ? Automerge.load(serializedDoc) : Automerge.init()\n    doc = Automerge.applyChanges(doc, changes)[0]\n    // Serialize and save with timestamp\n    const nextSerializedDoc = Automerge.save(doc)\n    const db = await this.db\n    await db.put('snapshots', {\n      docId,\n      serializedDoc: nextSerializedDoc,\n      timestamp: Date.now(),\n    })\n    // Delete changes before lastChangeTime\n    const oldChangesKeyRange = IDBKeyRange.upperBound(lastChangeTime)\n    const index = db\n      .transaction('changes', 'readwrite')\n      .store.index('timestamp')\n\n    let cursor = await index.openCursor(oldChangesKeyRange)\n    while (cursor) {\n      cursor.delete()\n      cursor = await cursor.continue()\n    }\n  }\n}\n\nfunction topologicalSort<T>(xs: T[], outgoingEdges: (n: T) => T[]) {\n  const result: T[] = [];\n  let isDag = true;\n  const unmarked = new Set(xs);\n  const tempMarks = new Set();\n  while (unmarked.size) {\n    const n = unmarked.values().next().value as T;\n    visit(n);\n    if (!isDag) {\n      throw new Error(\"Not a DAG\");\n    }\n  }\n  return result;\n\n  function visit(n: T) {\n    if (!unmarked.has(n)) return;\n    if (tempMarks.has(n)) {\n      isDag = false;\n      return;\n    }\n    tempMarks.add(n);\n    for (const m of outgoingEdges(n)) {\n      visit(m);\n    }\n    tempMarks.delete(n);\n    unmarked.delete(n);\n    result.push(n);\n  }\n}\n","/**\n * This shared worker is a background compaction task. Every N changes, it\n * saves a snapshot of the document. This improves load times.\n */\nimport { DB } from '../db'\ndeclare const self: SharedWorkerGlobalScope;\n\nconst db = new DB('autowiki')\n\nself.addEventListener('connect', (e) => {\n  const port = e.ports[0]\n  port.onmessage = (e) => {\n    const {docId} = e.data\n    db.saveSnapshot(docId)\n  }\n})\n\nexport {}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [143], function() { return __webpack_require__(5601); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"9c404735\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t601: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkautowiki\"] = self[\"webpackChunkautowiki\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(143).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DB","name","db","this","openDB","upgrade","oldVersion","newVersion","transaction","storeNames","objectStoreNames","deleteObjectStore","changeStore","createObjectStore","keyPath","createIndex","unique","docId","hash","change","tx","store","objectStore","get","buffer","byteLength","newChange","Uint8Array","set","add","timestamp","Date","now","singleKeyRange","IDBKeyRange","only","getAllFromIndex","values","map","v","snapshot","changes","lastChangeTime","index","iterate","cursor","push","value","Math","max","decodedChanges","Map","changesByHash","d","Automerge","sortedChanges","topologicalSort","c","deps","h","serializedDoc","getDoc","length","doc","nextSerializedDoc","put","oldChangesKeyRange","upperBound","openCursor","delete","continue","xs","outgoingEdges","result","isDag","unmarked","Set","tempMarks","size","visit","next","Error","n","has","self","addEventListener","e","ports","onmessage","data","saveSnapshot","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","Object","keys","every","key","splice","r","getter","__esModule","a","definition","o","defineProperty","enumerable","f","chunkId","Promise","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}