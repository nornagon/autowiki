{"version":3,"file":"static/js/601.e7121f4e.chunk.js","mappings":"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","sources":["db.ts","worker/index.ts","../../automerge/backend/backend.js","../../automerge/backend/columnar.js","../../automerge/backend/encoding.js","../../automerge/backend/index.js","../../automerge/backend/new.js","../../automerge/backend/sync.js","../../automerge/backend/util.js","../../automerge/frontend/apply_patch.js","../../automerge/frontend/constants.js","../../automerge/frontend/context.js","../../automerge/frontend/counter.js","../../automerge/frontend/index.js","../../automerge/frontend/numbers.js","../../automerge/frontend/observable.js","../../automerge/frontend/proxies.js","../../automerge/frontend/table.js","../../automerge/frontend/text.js","../../automerge/src/automerge.js","../../automerge/src/common.js","../../automerge/src/uuid.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { openDB } from 'idb/with-async-ittr'\nimport type { IDBPDatabase } from 'idb/with-async-ittr'\nimport Automerge from 'automerge'\n\n// The limit of changes to keep before db.saveSnapshot will do serialization\nconst MAX_CHANGES_TO_KEEP = 100\n\nexport class DB {\n  db: Promise<IDBPDatabase<any>>\n\n  constructor(name: string) {\n    this.db = openDB(name, 1, {\n      upgrade(db, oldVersion, newVersion, transaction) {\n        // Reset db\n        const storeNames = db.objectStoreNames\n        for (const name of storeNames)\n          db.deleteObjectStore(name)\n\n        const changeStore = db.createObjectStore('changes', {\n          keyPath: 'hash',\n        })\n        changeStore.createIndex('docId', 'docId', { unique: false })\n        changeStore.createIndex('timestamp', 'timestamp', { unique: false })\n\n        const snapshotStore = db.createObjectStore('snapshots', {\n          keyPath: 'docId',\n        })\n      },\n    })\n  }\n\n  async storeChange(docId: string, hash: string, change: Uint8Array) {\n    const db = await this.db\n    const tx = db.transaction('changes', 'readwrite')\n    const store = tx.objectStore('changes')\n    if (await store.get(hash)) {\n      // We already have this change; do nothing.\n      return\n    }\n\n    if (change.buffer.byteLength !== change.byteLength) {\n      const newChange = new Uint8Array(change.byteLength)\n      newChange.set(change)\n      change = newChange\n    }\n\n    await db.add('changes', {\n      docId,\n      hash,\n      change,\n      timestamp: Date.now(),\n    })\n  }\n\n  async getChanges(docId: string) {\n    const singleKeyRange = IDBKeyRange.only(docId)\n    const db = await this.db\n    const values = await db.getAllFromIndex('changes', 'docId', singleKeyRange)\n    return values.map((v) => v.change)\n  }\n\n  async getDoc(docId: string) {\n    const db = await this.db\n    // Get latest snapshot if it exists\n    const snapshot = await db.get('snapshots', docId)\n\n    // Get outstanding changes\n    const singleKeyRange = IDBKeyRange.only(docId)\n    const changes = []\n    let lastChangeTime: number = 0\n    for await (const cursor of db.transaction('changes').store.index('docId').iterate(singleKeyRange)) {\n      changes.push(cursor.value.change)\n      lastChangeTime = Math.max(cursor.value.timestamp, lastChangeTime)\n    }\n\n    // topo sort changes to work around https://github.com/automerge/automerge/commit/62b9f780fe5fc066b03cd1df628c0b68b82d0a80\n    const decodedChanges = new Map<any, Automerge.Change>()\n    const changesByHash = new Map<string, any>()\n    for (const change of changes) {\n      const d = Automerge.decodeChange(change)\n      changesByHash.set(d.hash!, change)\n      decodedChanges.set(change, d)\n    }\n    const sortedChanges = topologicalSort(changes, c => {\n      const d = decodedChanges.get(c)!\n      return d.deps.map(h => changesByHash.get(h))\n    })\n\n    return {\n      serializedDoc: snapshot?.serializedDoc,\n      changes: sortedChanges,\n      lastChangeTime,\n    }\n  }\n\n  async saveSnapshot(docId: string) {\n    const { serializedDoc, changes, lastChangeTime } = await this.getDoc(docId)\n    // Bail out of saving snapshot if changes are under threshold\n    if (changes.length < MAX_CHANGES_TO_KEEP) return\n    // Create AM doc\n    let doc = serializedDoc ? Automerge.load(serializedDoc) : Automerge.init()\n    doc = Automerge.applyChanges(doc, changes)[0]\n    // Serialize and save with timestamp\n    const nextSerializedDoc = Automerge.save(doc)\n    const db = await this.db\n    await db.put('snapshots', {\n      docId,\n      serializedDoc: nextSerializedDoc,\n      timestamp: Date.now(),\n    })\n    // Delete changes before lastChangeTime\n    const oldChangesKeyRange = IDBKeyRange.upperBound(lastChangeTime)\n    const index = db\n      .transaction('changes', 'readwrite')\n      .store.index('timestamp')\n\n    let cursor = await index.openCursor(oldChangesKeyRange)\n    while (cursor) {\n      cursor.delete()\n      cursor = await cursor.continue()\n    }\n  }\n}\n\nfunction topologicalSort<T>(xs: T[], outgoingEdges: (n: T) => T[]) {\n  const result: T[] = [];\n  let isDag = true;\n  const unmarked = new Set(xs);\n  const tempMarks = new Set();\n  while (unmarked.size) {\n    const n = unmarked.values().next().value as T;\n    visit(n);\n    if (!isDag) {\n      throw new Error(\"Not a DAG\");\n    }\n  }\n  return result;\n\n  function visit(n: T) {\n    if (!unmarked.has(n)) return;\n    if (tempMarks.has(n)) {\n      isDag = false;\n      return;\n    }\n    tempMarks.add(n);\n    for (const m of outgoingEdges(n)) {\n      visit(m);\n    }\n    tempMarks.delete(n);\n    unmarked.delete(n);\n    result.push(n);\n  }\n}\n","/**\n * This shared worker is a background compaction task. Every N changes, it\n * saves a snapshot of the document. This improves load times.\n */\nimport { DB } from '../db'\ndeclare const self: SharedWorkerGlobalScope;\n\nconst db = new DB('autowiki')\n\nself.addEventListener('connect', (e) => {\n  const port = e.ports[0]\n  port.onmessage = (e) => {\n    const {docId} = e.data\n    db.saveSnapshot(docId)\n  }\n})\n\nexport {}\n","const { encodeChange } = require('./columnar')\nconst { BackendDoc } = require('./new')\nconst { backendState } = require('./util')\n\n/**\n * Returns an empty node state.\n */\nfunction init() {\n  return {state: new BackendDoc(), heads: []}\n}\n\nfunction clone(backend) {\n  return {state: backendState(backend).clone(), heads: backend.heads}\n}\n\nfunction free(backend) {\n  backend.state = null\n  backend.frozen = true\n}\n\n/**\n * Applies a list of `changes` from remote nodes to the node state `backend`.\n * Returns a two-element array `[state, patch]` where `state` is the updated\n * node state, and `patch` describes the modifications that need to be made\n * to the document objects to reflect these changes.\n */\nfunction applyChanges(backend, changes) {\n  const state = backendState(backend)\n  const patch = state.applyChanges(changes)\n  backend.frozen = true\n  return [{state, heads: state.heads}, patch]\n}\n\nfunction hashByActor(state, actorId, index) {\n  if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {\n    return state.hashesByActor[actorId][index]\n  }\n  if (!state.haveHashGraph) {\n    state.computeHashGraph()\n    if (state.hashesByActor[actorId] && state.hashesByActor[actorId][index]) {\n      return state.hashesByActor[actorId][index]\n    }\n  }\n  throw new RangeError(`Unknown change: actorId = ${actorId}, seq = ${index + 1}`)\n}\n\n/**\n * Takes a single change request `request` made by the local user, and applies\n * it to the node state `backend`. Returns a three-element array `[backend, patch, binaryChange]`\n * where `backend` is the updated node state,`patch` confirms the\n * modifications to the document objects, and `binaryChange` is a binary-encoded form of\n * the change submitted.\n */\nfunction applyLocalChange(backend, change) {\n  const state = backendState(backend)\n  if (change.seq <= state.clock[change.actor] || 0) {\n    throw new RangeError('Change request has already been applied')\n  }\n\n  // Add the local actor's last change hash to deps. We do this because when frontend\n  // and backend are on separate threads, the frontend may fire off several local\n  // changes in sequence before getting a response from the backend; since the binary\n  // encoding and hashing is done by the backend, the frontend does not know the hash\n  // of its own last change in this case. Rather than handle this situation as a\n  // special case, we say that the frontend includes only specifies other actors'\n  // deps in changes it generates, and the dependency from the local actor's last\n  // change is always added here in the backend.\n  //\n  // Strictly speaking, we should check whether the local actor's last change is\n  // indirectly reachable through a different actor's change; in that case, it is not\n  // necessary to add this dependency. However, it doesn't do any harm either (only\n  // using a few extra bytes of storage).\n  if (change.seq > 1) {\n    const lastHash = hashByActor(state, change.actor, change.seq - 2)\n    if (!lastHash) {\n      throw new RangeError(`Cannot find hash of localChange before seq=${change.seq}`)\n    }\n    let deps = {[lastHash]: true}\n    for (let hash of change.deps) deps[hash] = true\n    change.deps = Object.keys(deps).sort()\n  }\n\n  const binaryChange = encodeChange(change)\n  const patch = state.applyChanges([binaryChange], true)\n  backend.frozen = true\n\n  // On the patch we send out, omit the last local change hash\n  const lastHash = hashByActor(state, change.actor, change.seq - 1)\n  patch.deps = patch.deps.filter(head => head !== lastHash)\n  return [{state, heads: state.heads}, patch, binaryChange]\n}\n\n/**\n * Returns the state of the document serialised to an Uint8Array.\n */\nfunction save(backend) {\n  return backendState(backend).save()\n}\n\n/**\n * Loads the document and/or changes contained in an Uint8Array, and returns a\n * backend initialised with this state.\n */\nfunction load(data) {\n  const state = new BackendDoc(data)\n  return {state, heads: state.heads}\n}\n\n/**\n * Applies a list of `changes` to the node state `backend`, and returns the updated\n * state with those changes incorporated. Unlike `applyChanges()`, this function\n * does not produce a patch describing the incremental modifications, making it\n * a little faster when loading a document from disk. When all the changes have\n * been loaded, you can use `getPatch()` to construct the latest document state.\n */\nfunction loadChanges(backend, changes) {\n  const state = backendState(backend)\n  state.applyChanges(changes)\n  backend.frozen = true\n  return {state, heads: state.heads}\n}\n\n/**\n * Returns a patch that, when applied to an empty document, constructs the\n * document tree in the state described by the node state `backend`.\n */\nfunction getPatch(backend) {\n  return backendState(backend).getPatch()\n}\n\n/**\n * Returns an array of hashes of the current \"head\" changes (i.e. those changes\n * that no other change depends on).\n */\nfunction getHeads(backend) {\n  return backend.heads\n}\n\n/**\n * Returns the full history of changes that have been applied to a document.\n */\nfunction getAllChanges(backend) {\n  return getChanges(backend, [])\n}\n\n/**\n * Returns all changes that are newer than or concurrent to the changes\n * identified by the hashes in `haveDeps`. If `haveDeps` is an empty array, all\n * changes are returned. Throws an exception if any of the given hashes is unknown.\n */\nfunction getChanges(backend, haveDeps) {\n  if (!Array.isArray(haveDeps)) {\n    throw new TypeError('Pass an array of hashes to Backend.getChanges()')\n  }\n  return backendState(backend).getChanges(haveDeps)\n}\n\n/**\n * Returns all changes that are present in `backend2` but not in `backend1`.\n * Intended for use in situations where the two backends are for different actors.\n * To get the changes added between an older and a newer document state of the same\n * actor, use `getChanges()` instead. `getChangesAdded()` throws an exception if\n * one of the backend states is frozen (i.e. if it is not the latest state of that\n * backend instance; this distinction matters when the backend is mutable).\n */\nfunction getChangesAdded(backend1, backend2) {\n  return backendState(backend2).getChangesAdded(backendState(backend1))\n}\n\n/**\n * If the backend has applied a change with the given `hash` (given as a\n * hexadecimal string), returns that change (as a byte array). Returns undefined\n * if no change with that hash has been applied. A change with missing\n * dependencies does not count as having been applied.\n */\nfunction getChangeByHash(backend, hash) {\n  return backendState(backend).getChangeByHash(hash)\n}\n\n/**\n * Returns the hashes of any missing dependencies, i.e. where we have applied a\n * change that has a dependency on a change we have not seen.\n *\n * If the argument `heads` is given (an array of hexadecimal strings representing\n * hashes as returned by `getHeads()`), this function also ensures that all of\n * those hashes resolve to either a change that has been applied to the document,\n * or that has been enqueued for later application once missing dependencies have\n * arrived. Any missing heads hashes are included in the returned array.\n */\nfunction getMissingDeps(backend, heads = []) {\n  return backendState(backend).getMissingDeps(heads)\n}\n\nmodule.exports = {\n  init, clone, free, applyChanges, applyLocalChange, save, load, loadChanges, getPatch,\n  getHeads, getAllChanges, getChanges, getChangesAdded, getChangeByHash, getMissingDeps\n}\n","const pako = require('pako')\nconst { copyObject, parseOpId, equalBytes } = require('../src/common')\nconst {\n  utf8ToString, hexStringToBytes, bytesToHexString,\n  Encoder, Decoder, RLEEncoder, RLEDecoder, DeltaEncoder, DeltaDecoder, BooleanEncoder, BooleanDecoder\n} = require('./encoding')\n\n// Maybe we should be using the platform's built-in hash implementation?\n// Node has the crypto module: https://nodejs.org/api/crypto.html and browsers have\n// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n// However, the WebCrypto API is asynchronous (returns promises), which would\n// force all our APIs to become asynchronous as well, which would be annoying.\n//\n// I think on balance, it's safe enough to use a random library off npm:\n// - We only need one hash function (not a full suite of crypto algorithms);\n// - SHA256 is quite simple and has fairly few opportunities for subtle bugs\n//   (compared to asymmetric cryptography anyway);\n// - It does not need a secure source of random bits and does not need to be\n//   constant-time;\n// - I have reviewed the source code and it seems pretty reasonable.\nconst { Hash } = require('fast-sha256')\n\n// These bytes don't mean anything, they were generated randomly\nconst MAGIC_BYTES = new Uint8Array([0x85, 0x6f, 0x4a, 0x83])\n\nconst CHUNK_TYPE_DOCUMENT = 0\nconst CHUNK_TYPE_CHANGE = 1\nconst CHUNK_TYPE_DEFLATE = 2 // like CHUNK_TYPE_CHANGE but with DEFLATE compression\n\n// Minimum number of bytes in a value before we enable DEFLATE compression (there is no point\n// compressing very short values since compression may actually make them bigger)\nconst DEFLATE_MIN_SIZE = 256\n\n// The least-significant 3 bits of a columnId indicate its datatype\nconst COLUMN_TYPE = {\n  GROUP_CARD: 0, ACTOR_ID: 1, INT_RLE: 2, INT_DELTA: 3, BOOLEAN: 4,\n  STRING_RLE: 5, VALUE_LEN: 6, VALUE_RAW: 7\n}\n\n// The 4th-least-significant bit of a columnId is set if the column is DEFLATE-compressed\nconst COLUMN_TYPE_DEFLATE = 8\n\n// In the values in a column of type VALUE_LEN, the bottom four bits indicate the type of the value,\n// one of the following types in VALUE_TYPE. The higher bits indicate the length of the value in the\n// associated VALUE_RAW column (in bytes).\nconst VALUE_TYPE = {\n  NULL: 0, FALSE: 1, TRUE: 2, LEB128_UINT: 3, LEB128_INT: 4, IEEE754: 5,\n  UTF8: 6, BYTES: 7, COUNTER: 8, TIMESTAMP: 9, MIN_UNKNOWN: 10, MAX_UNKNOWN: 15\n}\n\n// make* actions must be at even-numbered indexes in this list\nconst ACTIONS = ['makeMap', 'set', 'makeList', 'del', 'makeText', 'inc', 'makeTable', 'link']\n\nconst OBJECT_TYPE = {makeMap: 'map', makeList: 'list', makeText: 'text', makeTable: 'table'}\n\nconst COMMON_COLUMNS = [\n  {columnName: 'objActor',  columnId: 0 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'objCtr',    columnId: 0 << 4 | COLUMN_TYPE.INT_RLE},\n  {columnName: 'keyActor',  columnId: 1 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'keyCtr',    columnId: 1 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'keyStr',    columnId: 1 << 4 | COLUMN_TYPE.STRING_RLE},\n  {columnName: 'idActor',   columnId: 2 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'idCtr',     columnId: 2 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'insert',    columnId: 3 << 4 | COLUMN_TYPE.BOOLEAN},\n  {columnName: 'action',    columnId: 4 << 4 | COLUMN_TYPE.INT_RLE},\n  {columnName: 'valLen',    columnId: 5 << 4 | COLUMN_TYPE.VALUE_LEN},\n  {columnName: 'valRaw',    columnId: 5 << 4 | COLUMN_TYPE.VALUE_RAW},\n  {columnName: 'chldActor', columnId: 6 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'chldCtr',   columnId: 6 << 4 | COLUMN_TYPE.INT_DELTA}\n]\n\nconst CHANGE_COLUMNS = COMMON_COLUMNS.concat([\n  {columnName: 'predNum',   columnId: 7 << 4 | COLUMN_TYPE.GROUP_CARD},\n  {columnName: 'predActor', columnId: 7 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'predCtr',   columnId: 7 << 4 | COLUMN_TYPE.INT_DELTA}\n])\n\nconst DOC_OPS_COLUMNS = COMMON_COLUMNS.concat([\n  {columnName: 'succNum',   columnId: 8 << 4 | COLUMN_TYPE.GROUP_CARD},\n  {columnName: 'succActor', columnId: 8 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'succCtr',   columnId: 8 << 4 | COLUMN_TYPE.INT_DELTA}\n])\n\nconst DOCUMENT_COLUMNS = [\n  {columnName: 'actor',     columnId: 0 << 4 | COLUMN_TYPE.ACTOR_ID},\n  {columnName: 'seq',       columnId: 0 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'maxOp',     columnId: 1 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'time',      columnId: 2 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'message',   columnId: 3 << 4 | COLUMN_TYPE.STRING_RLE},\n  {columnName: 'depsNum',   columnId: 4 << 4 | COLUMN_TYPE.GROUP_CARD},\n  {columnName: 'depsIndex', columnId: 4 << 4 | COLUMN_TYPE.INT_DELTA},\n  {columnName: 'extraLen',  columnId: 5 << 4 | COLUMN_TYPE.VALUE_LEN},\n  {columnName: 'extraRaw',  columnId: 5 << 4 | COLUMN_TYPE.VALUE_RAW}\n]\n\n/**\n * Maps an opId of the form {counter: 12345, actorId: 'someActorId'} to the form\n * {counter: 12345, actorNum: 123, actorId: 'someActorId'}, where the actorNum\n * is the index into the `actorIds` array.\n */\nfunction actorIdToActorNum(opId, actorIds) {\n  if (!opId || !opId.actorId) return opId\n  const counter = opId.counter\n  const actorNum = actorIds.indexOf(opId.actorId)\n  if (actorNum < 0) throw new RangeError('missing actorId') // should not happen\n  return {counter, actorNum, actorId: opId.actorId}\n}\n\n/**\n * Comparison function to pass to Array.sort(), which compares two opIds in the\n * form produced by `actorIdToActorNum` so that they are sorted in increasing\n * Lamport timestamp order (sorted first by counter, then by actorId).\n */\nfunction compareParsedOpIds(id1, id2) {\n  if (id1.counter < id2.counter) return -1\n  if (id1.counter > id2.counter) return +1\n  if (id1.actorId < id2.actorId) return -1\n  if (id1.actorId > id2.actorId) return +1\n  return 0\n}\n\n/**\n * Takes `changes`, an array of changes (represented as JS objects). Returns an\n * object `{changes, actorIds}`, where `changes` is a copy of the argument in\n * which all string opIds have been replaced with `{counter, actorNum}` objects,\n * and where `actorIds` is a lexicographically sorted array of actor IDs occurring\n * in any of the operations. `actorNum` is an index into that array of actorIds.\n * If `single` is true, the actorId of the author of the change is moved to the\n * beginning of the array of actorIds, so that `actorNum` is zero when referencing\n * the author of the change itself. This special-casing is omitted if `single` is\n * false.\n */\nfunction parseAllOpIds(changes, single) {\n  const actors = {}, newChanges = []\n  for (let change of changes) {\n    change = copyObject(change)\n    actors[change.actor] = true\n    change.ops = expandMultiOps(change.ops, change.startOp, change.actor)\n    change.ops = change.ops.map(op => {\n      op = copyObject(op)\n      if (op.obj !== '_root') op.obj = parseOpId(op.obj)\n      if (op.elemId && op.elemId !== '_head') op.elemId = parseOpId(op.elemId)\n      if (op.child) op.child = parseOpId(op.child)\n      if (op.pred) op.pred = op.pred.map(parseOpId)\n      if (op.obj.actorId) actors[op.obj.actorId] = true\n      if (op.elemId && op.elemId.actorId) actors[op.elemId.actorId] = true\n      if (op.child && op.child.actorId) actors[op.child.actorId] = true\n      for (let pred of op.pred) actors[pred.actorId] = true\n      return op\n    })\n    newChanges.push(change)\n  }\n\n  let actorIds = Object.keys(actors).sort()\n  if (single) {\n    actorIds = [changes[0].actor].concat(actorIds.filter(actor => actor !== changes[0].actor))\n  }\n  for (let change of newChanges) {\n    change.actorNum = actorIds.indexOf(change.actor)\n    for (let i = 0; i < change.ops.length; i++) {\n      let op = change.ops[i]\n      op.id = {counter: change.startOp + i, actorNum: change.actorNum, actorId: change.actor}\n      op.obj = actorIdToActorNum(op.obj, actorIds)\n      op.elemId = actorIdToActorNum(op.elemId, actorIds)\n      op.child = actorIdToActorNum(op.child, actorIds)\n      op.pred = op.pred.map(pred => actorIdToActorNum(pred, actorIds))\n    }\n  }\n  return {changes: newChanges, actorIds}\n}\n\n/**\n * Encodes the `obj` property of operation `op` into the two columns\n * `objActor` and `objCtr`.\n */\nfunction encodeObjectId(op, columns) {\n  if (op.obj === '_root') {\n    columns.objActor.appendValue(null)\n    columns.objCtr.appendValue(null)\n  } else if (op.obj.actorNum >= 0 && op.obj.counter > 0) {\n    columns.objActor.appendValue(op.obj.actorNum)\n    columns.objCtr.appendValue(op.obj.counter)\n  } else {\n    throw new RangeError(`Unexpected objectId reference: ${JSON.stringify(op.obj)}`)\n  }\n}\n\n/**\n * Encodes the `key` and `elemId` properties of operation `op` into the three\n * columns `keyActor`, `keyCtr`, and `keyStr`.\n */\nfunction encodeOperationKey(op, columns) {\n  if (op.key) {\n    columns.keyActor.appendValue(null)\n    columns.keyCtr.appendValue(null)\n    columns.keyStr.appendValue(op.key)\n  } else if (op.elemId === '_head' && op.insert) {\n    columns.keyActor.appendValue(null)\n    columns.keyCtr.appendValue(0)\n    columns.keyStr.appendValue(null)\n  } else if (op.elemId && op.elemId.actorNum >= 0 && op.elemId.counter > 0) {\n    columns.keyActor.appendValue(op.elemId.actorNum)\n    columns.keyCtr.appendValue(op.elemId.counter)\n    columns.keyStr.appendValue(null)\n  } else {\n    throw new RangeError(`Unexpected operation key: ${JSON.stringify(op)}`)\n  }\n}\n\n/**\n * Encodes the `action` property of operation `op` into the `action` column.\n */\nfunction encodeOperationAction(op, columns) {\n  const actionCode = ACTIONS.indexOf(op.action)\n  if (actionCode >= 0) {\n    columns.action.appendValue(actionCode)\n  } else if (typeof op.action === 'number') {\n    columns.action.appendValue(op.action)\n  } else {\n    throw new RangeError(`Unexpected operation action: ${op.action}`)\n  }\n}\n\n/**\n * Given the datatype for a number, determine the typeTag and the value to encode\n * otherwise guess\n */\nfunction getNumberTypeAndValue(op) {\n  switch (op.datatype) {\n    case \"counter\":\n      return [ VALUE_TYPE.COUNTER, op.value ]\n    case \"timestamp\":\n      return [ VALUE_TYPE.TIMESTAMP, op.value ]\n    case \"uint\":\n      return [ VALUE_TYPE.LEB128_UINT, op.value ]\n    case \"int\":\n      return [ VALUE_TYPE.LEB128_INT, op.value ]\n    case \"float64\": {\n      const buf64 = new ArrayBuffer(8), view64 = new DataView(buf64)\n      view64.setFloat64(0, op.value, true)\n      return [ VALUE_TYPE.IEEE754,  new Uint8Array(buf64) ]\n    }\n    default:\n      // increment operators get resolved here ...\n      if (Number.isInteger(op.value) && op.value <= Number.MAX_SAFE_INTEGER && op.value >= Number.MIN_SAFE_INTEGER) {\n        return [ VALUE_TYPE.LEB128_INT, op.value ]\n      } else {\n        const buf64 = new ArrayBuffer(8), view64 = new DataView(buf64)\n        view64.setFloat64(0, op.value, true)\n        return [ VALUE_TYPE.IEEE754,  new Uint8Array(buf64) ]\n      }\n  }\n}\n\n/**\n * Encodes the `value` property of operation `op` into the two columns\n * `valLen` and `valRaw`.\n */\nfunction encodeValue(op, columns) {\n  if ((op.action !== 'set' && op.action !== 'inc') || op.value === null) {\n    columns.valLen.appendValue(VALUE_TYPE.NULL)\n  } else if (op.value === false) {\n    columns.valLen.appendValue(VALUE_TYPE.FALSE)\n  } else if (op.value === true) {\n    columns.valLen.appendValue(VALUE_TYPE.TRUE)\n  } else if (typeof op.value === 'string') {\n    const numBytes = columns.valRaw.appendRawString(op.value)\n    columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.UTF8)\n  } else if (ArrayBuffer.isView(op.value)) {\n    const numBytes = columns.valRaw.appendRawBytes(new Uint8Array(op.value.buffer))\n    columns.valLen.appendValue(numBytes << 4 | VALUE_TYPE.BYTES)\n  } else if (typeof op.value === 'number') {\n    let [typeTag, value] = getNumberTypeAndValue(op)\n    let numBytes\n    if (typeTag === VALUE_TYPE.LEB128_UINT) {\n      numBytes = columns.valRaw.appendUint53(value)\n    } else if (typeTag === VALUE_TYPE.IEEE754) {\n      numBytes = columns.valRaw.appendRawBytes(value)\n    } else {\n      numBytes = columns.valRaw.appendInt53(value)\n    }\n    columns.valLen.appendValue(numBytes << 4 | typeTag)\n  } else if (typeof op.datatype === 'number' && op.datatype >= VALUE_TYPE.MIN_UNKNOWN &&\n             op.datatype <= VALUE_TYPE.MAX_UNKNOWN && op.value instanceof Uint8Array) {\n    const numBytes = columns.valRaw.appendRawBytes(op.value)\n    columns.valLen.appendValue(numBytes << 4 | op.datatype)\n  } else if (op.datatype) {\n      throw new RangeError(`Unknown datatype ${op.datatype} for value ${op.value}`)\n  } else {\n    throw new RangeError(`Unsupported value in operation: ${op.value}`)\n  }\n}\n\n/**\n * Given `sizeTag` (an unsigned integer read from a VALUE_LEN column) and `bytes` (a Uint8Array\n * read from a VALUE_RAW column, with length `sizeTag >> 4`), this function returns an object of the\n * form `{value: value, datatype: datatypeTag}` where `value` is a JavaScript primitive datatype\n * corresponding to the value, and `datatypeTag` is a datatype annotation such as 'counter'.\n */\nfunction decodeValue(sizeTag, bytes) {\n  if (sizeTag === VALUE_TYPE.NULL) {\n    return {value: null}\n  } else if (sizeTag === VALUE_TYPE.FALSE) {\n    return {value: false}\n  } else if (sizeTag === VALUE_TYPE.TRUE) {\n    return {value: true}\n  } else if (sizeTag % 16 === VALUE_TYPE.UTF8) {\n    return {value: utf8ToString(bytes)}\n  } else {\n    if (sizeTag % 16 === VALUE_TYPE.LEB128_UINT) {\n      return {value: new Decoder(bytes).readUint53(), datatype: \"uint\"}\n    } else if (sizeTag % 16 === VALUE_TYPE.LEB128_INT) {\n      return {value: new Decoder(bytes).readInt53(), datatype: \"int\"}\n    } else if (sizeTag % 16 === VALUE_TYPE.IEEE754) {\n      const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n      if (bytes.byteLength === 8) {\n        return {value: view.getFloat64(0, true), datatype: \"float64\"}\n      } else {\n        throw new RangeError(`Invalid length for floating point number: ${bytes.byteLength}`)\n      }\n    } else if (sizeTag % 16 === VALUE_TYPE.COUNTER) {\n      return {value: new Decoder(bytes).readInt53(), datatype: 'counter'}\n    } else if (sizeTag % 16 === VALUE_TYPE.TIMESTAMP) {\n      return {value: new Decoder(bytes).readInt53(), datatype: 'timestamp'}\n    } else {\n      return {value: bytes, datatype: sizeTag % 16}\n    }\n  }\n}\n\n/**\n * Reads one value from the column `columns[colIndex]` and interprets it based\n * on the column type. `actorIds` is a list of actors that appear in the change;\n * `actorIds[0]` is the actorId of the change's author. Mutates the `result`\n * object with the value, and returns the number of columns processed (this is 2\n * in the case of a pair of VALUE_LEN and VALUE_RAW columns, which are processed\n * in one go).\n */\nfunction decodeValueColumns(columns, colIndex, actorIds, result) {\n  const { columnId, columnName, decoder } = columns[colIndex]\n  if (columnId % 8 === COLUMN_TYPE.VALUE_LEN && colIndex + 1 < columns.length &&\n      columns[colIndex + 1].columnId === columnId + 1) {\n    const sizeTag = decoder.readValue()\n    const rawValue = columns[colIndex + 1].decoder.readRawBytes(sizeTag >> 4)\n    const { value, datatype } = decodeValue(sizeTag, rawValue)\n    result[columnName] = value\n    if (datatype) result[columnName + '_datatype'] = datatype\n    return 2\n  } else if (columnId % 8 === COLUMN_TYPE.ACTOR_ID) {\n    const actorNum = decoder.readValue()\n    if (actorNum === null) {\n      result[columnName] = null\n    } else {\n      if (!actorIds[actorNum]) throw new RangeError(`No actor index ${actorNum}`)\n      result[columnName] = actorIds[actorNum]\n    }\n  } else {\n    result[columnName] = decoder.readValue()\n  }\n  return 1\n}\n\n/**\n * Encodes an array of operations in a set of columns. The operations need to\n * be parsed with `parseAllOpIds()` beforehand. If `forDocument` is true, we use\n * the column structure of a whole document, otherwise we use the column\n * structure for an individual change. Returns an array of\n * `{columnId, columnName, encoder}` objects.\n */\nfunction encodeOps(ops, forDocument) {\n  const columns = {\n    objActor  : new RLEEncoder('uint'),\n    objCtr    : new RLEEncoder('uint'),\n    keyActor  : new RLEEncoder('uint'),\n    keyCtr    : new DeltaEncoder(),\n    keyStr    : new RLEEncoder('utf8'),\n    insert    : new BooleanEncoder(),\n    action    : new RLEEncoder('uint'),\n    valLen    : new RLEEncoder('uint'),\n    valRaw    : new Encoder(),\n    chldActor : new RLEEncoder('uint'),\n    chldCtr   : new DeltaEncoder()\n  }\n\n  if (forDocument) {\n    columns.idActor   = new RLEEncoder('uint')\n    columns.idCtr     = new DeltaEncoder()\n    columns.succNum   = new RLEEncoder('uint')\n    columns.succActor = new RLEEncoder('uint')\n    columns.succCtr   = new DeltaEncoder()\n  } else {\n    columns.predNum   = new RLEEncoder('uint')\n    columns.predCtr   = new DeltaEncoder()\n    columns.predActor = new RLEEncoder('uint')\n  }\n\n  for (let op of ops) {\n    encodeObjectId(op, columns)\n    encodeOperationKey(op, columns)\n    columns.insert.appendValue(!!op.insert)\n    encodeOperationAction(op, columns)\n    encodeValue(op, columns)\n\n    if (op.child && op.child.counter) {\n      columns.chldActor.appendValue(op.child.actorNum)\n      columns.chldCtr.appendValue(op.child.counter)\n    } else {\n      columns.chldActor.appendValue(null)\n      columns.chldCtr.appendValue(null)\n    }\n\n    if (forDocument) {\n      columns.idActor.appendValue(op.id.actorNum)\n      columns.idCtr.appendValue(op.id.counter)\n      columns.succNum.appendValue(op.succ.length)\n      op.succ.sort(compareParsedOpIds)\n      for (let i = 0; i < op.succ.length; i++) {\n        columns.succActor.appendValue(op.succ[i].actorNum)\n        columns.succCtr.appendValue(op.succ[i].counter)\n      }\n    } else {\n      columns.predNum.appendValue(op.pred.length)\n      op.pred.sort(compareParsedOpIds)\n      for (let i = 0; i < op.pred.length; i++) {\n        columns.predActor.appendValue(op.pred[i].actorNum)\n        columns.predCtr.appendValue(op.pred[i].counter)\n      }\n    }\n  }\n\n  let columnList = []\n  for (let {columnName, columnId} of forDocument ? DOC_OPS_COLUMNS : CHANGE_COLUMNS) {\n    if (columns[columnName]) columnList.push({columnId, columnName, encoder: columns[columnName]})\n  }\n  return columnList.sort((a, b) => a.columnId - b.columnId)\n}\n\nfunction validDatatype(value, datatype) {\n  if (datatype === undefined) {\n    return (typeof value === 'string' || typeof value === 'boolean' || value === null)\n  } else {\n    return typeof value === 'number'\n  }\n}\n\nfunction expandMultiOps(ops, startOp, actor) {\n  let opNum = startOp\n  let expandedOps = []\n  for (const op of ops) {\n    if (op.action === 'set' && op.values && op.insert) {\n      if (op.pred.length !== 0) throw new RangeError('multi-insert pred must be empty')\n      let lastElemId = op.elemId\n      const datatype = op.datatype\n      for (const value of op.values) {\n        if (!validDatatype(value, datatype)) throw new RangeError(`Decode failed: bad value/datatype association (${value},${datatype})`)\n        expandedOps.push({action: 'set', obj: op.obj, elemId: lastElemId, datatype, value, pred: [], insert: true})\n        lastElemId = `${opNum}@${actor}`\n        opNum += 1\n      }\n    } else if (op.action === 'del' && op.multiOp > 1) {\n      if (op.pred.length !== 1) throw new RangeError('multiOp deletion must have exactly one pred')\n      const startElemId = parseOpId(op.elemId), startPred = parseOpId(op.pred[0])\n      for (let i = 0; i < op.multiOp; i++) {\n        const elemId = `${startElemId.counter + i}@${startElemId.actorId}`\n        const pred = [`${startPred.counter + i}@${startPred.actorId}`]\n        expandedOps.push({action: 'del', obj: op.obj, elemId, pred})\n        opNum += 1\n      }\n    } else {\n      expandedOps.push(op)\n      opNum += 1\n    }\n  }\n  return expandedOps\n}\n\n/**\n * Takes a change as decoded by `decodeColumns`, and changes it into the form\n * expected by the rest of the backend. If `forDocument` is true, we use the op\n * structure of a whole document, otherwise we use the op structure for an\n * individual change.\n */\nfunction decodeOps(ops, forDocument) {\n  const newOps = []\n  for (let op of ops) {\n    const obj = (op.objCtr === null) ? '_root' : `${op.objCtr}@${op.objActor}`\n    const elemId = op.keyStr ? undefined : (op.keyCtr === 0 ? '_head' : `${op.keyCtr}@${op.keyActor}`)\n    const action = ACTIONS[op.action] || op.action\n    const newOp = elemId ? {obj, elemId, action} : {obj, key: op.keyStr, action}\n    newOp.insert = !!op.insert\n    if (ACTIONS[op.action] === 'set' || ACTIONS[op.action] === 'inc') {\n      newOp.value = op.valLen\n      if (op.valLen_datatype) newOp.datatype = op.valLen_datatype\n    }\n    if (!!op.chldCtr !== !!op.chldActor) {\n      throw new RangeError(`Mismatched child columns: ${op.chldCtr} and ${op.chldActor}`)\n    }\n    if (op.chldCtr !== null) newOp.child = `${op.chldCtr}@${op.chldActor}`\n    if (forDocument) {\n      newOp.id = `${op.idCtr}@${op.idActor}`\n      newOp.succ = op.succNum.map(succ => `${succ.succCtr}@${succ.succActor}`)\n      checkSortedOpIds(op.succNum.map(succ => ({counter: succ.succCtr, actorId: succ.succActor})))\n    } else {\n      newOp.pred = op.predNum.map(pred => `${pred.predCtr}@${pred.predActor}`)\n      checkSortedOpIds(op.predNum.map(pred => ({counter: pred.predCtr, actorId: pred.predActor})))\n    }\n    newOps.push(newOp)\n  }\n  return newOps\n}\n\n/**\n * Throws an exception if the opIds in the given array are not in sorted order.\n */\nfunction checkSortedOpIds(opIds) {\n  let last = null\n  for (let opId of opIds) {\n    if (last && compareParsedOpIds(last, opId) !== -1) {\n      throw new RangeError('operation IDs are not in ascending order')\n    }\n    last = opId\n  }\n}\n\nfunction encoderByColumnId(columnId) {\n  if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {\n    return new DeltaEncoder()\n  } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {\n    return new BooleanEncoder()\n  } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {\n    return new RLEEncoder('utf8')\n  } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {\n    return new Encoder()\n  } else {\n    return new RLEEncoder('uint')\n  }\n}\n\nfunction decoderByColumnId(columnId, buffer) {\n  if ((columnId & 7) === COLUMN_TYPE.INT_DELTA) {\n    return new DeltaDecoder(buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.BOOLEAN) {\n    return new BooleanDecoder(buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.STRING_RLE) {\n    return new RLEDecoder('utf8', buffer)\n  } else if ((columnId & 7) === COLUMN_TYPE.VALUE_RAW) {\n    return new Decoder(buffer)\n  } else {\n    return new RLEDecoder('uint', buffer)\n  }\n}\n\nfunction makeDecoders(columns, columnSpec) {\n  const emptyBuf = new Uint8Array(0)\n  let decoders = [], columnIndex = 0, specIndex = 0\n\n  while (columnIndex < columns.length || specIndex < columnSpec.length) {\n    if (columnIndex === columns.length ||\n        (specIndex < columnSpec.length && columnSpec[specIndex].columnId < columns[columnIndex].columnId)) {\n      const {columnId, columnName} = columnSpec[specIndex]\n      decoders.push({columnId, columnName, decoder: decoderByColumnId(columnId, emptyBuf)})\n      specIndex++\n    } else if (specIndex === columnSpec.length || columns[columnIndex].columnId < columnSpec[specIndex].columnId) {\n      const {columnId, buffer} = columns[columnIndex]\n      decoders.push({columnId, decoder: decoderByColumnId(columnId, buffer)})\n      columnIndex++\n    } else { // columns[columnIndex].columnId === columnSpec[specIndex].columnId\n      const {columnId, buffer} = columns[columnIndex], {columnName} = columnSpec[specIndex]\n      decoders.push({columnId, columnName, decoder: decoderByColumnId(columnId, buffer)})\n      columnIndex++\n      specIndex++\n    }\n  }\n  return decoders\n}\n\nfunction decodeColumns(columns, actorIds, columnSpec) {\n  columns = makeDecoders(columns, columnSpec)\n  let parsedRows = []\n  while (columns.some(col => !col.decoder.done)) {\n    let row = {}, col = 0\n    while (col < columns.length) {\n      const columnId = columns[col].columnId\n      let groupId = columnId >> 4, groupCols = 1\n      while (col + groupCols < columns.length && columns[col + groupCols].columnId >> 4 === groupId) {\n        groupCols++\n      }\n\n      if (columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n        const values = [], count = columns[col].decoder.readValue()\n        for (let i = 0; i < count; i++) {\n          let value = {}\n          for (let colOffset = 1; colOffset < groupCols; colOffset++) {\n            decodeValueColumns(columns, col + colOffset, actorIds, value)\n          }\n          values.push(value)\n        }\n        row[columns[col].columnName] = values\n        col += groupCols\n      } else {\n        col += decodeValueColumns(columns, col, actorIds, row)\n      }\n    }\n    parsedRows.push(row)\n  }\n  return parsedRows\n}\n\nfunction decodeColumnInfo(decoder) {\n  // A number that is all 1 bits except for the bit that indicates whether a column is\n  // deflate-compressed. We ignore this bit when checking whether columns are sorted by ID.\n  const COLUMN_ID_MASK = (-1 ^ COLUMN_TYPE_DEFLATE) >>> 0\n\n  let lastColumnId = -1, columns = [], numColumns = decoder.readUint53()\n  for (let i = 0; i < numColumns; i++) {\n    const columnId = decoder.readUint53(), bufferLen = decoder.readUint53()\n    if ((columnId & COLUMN_ID_MASK) <= (lastColumnId & COLUMN_ID_MASK)) {\n      throw new RangeError('Columns must be in ascending order')\n    }\n    lastColumnId = columnId\n    columns.push({columnId, bufferLen})\n  }\n  return columns\n}\n\nfunction encodeColumnInfo(encoder, columns) {\n  const nonEmptyColumns = columns.filter(column => column.encoder.buffer.byteLength > 0)\n  encoder.appendUint53(nonEmptyColumns.length)\n  for (let column of nonEmptyColumns) {\n    encoder.appendUint53(column.columnId)\n    encoder.appendUint53(column.encoder.buffer.byteLength)\n  }\n}\n\nfunction decodeChangeHeader(decoder) {\n  const numDeps = decoder.readUint53(), deps = []\n  for (let i = 0; i < numDeps; i++) {\n    deps.push(bytesToHexString(decoder.readRawBytes(32)))\n  }\n  let change = {\n    actor:   decoder.readHexString(),\n    seq:     decoder.readUint53(),\n    startOp: decoder.readUint53(),\n    time:    decoder.readInt53(),\n    message: decoder.readPrefixedString(),\n    deps\n  }\n  const actorIds = [change.actor], numActorIds = decoder.readUint53()\n  for (let i = 0; i < numActorIds; i++) actorIds.push(decoder.readHexString())\n  change.actorIds = actorIds\n  return change\n}\n\n/**\n * Assembles a chunk of encoded data containing a checksum, headers, and a\n * series of encoded columns. Calls `encodeHeaderCallback` with an encoder that\n * should be used to add the headers. The columns should be given as `columns`.\n */\nfunction encodeContainer(chunkType, encodeContentsCallback) {\n  const CHECKSUM_SIZE = 4 // checksum is first 4 bytes of SHA-256 hash of the rest of the data\n  const HEADER_SPACE = MAGIC_BYTES.byteLength + CHECKSUM_SIZE + 1 + 5 // 1 byte type + 5 bytes length\n  const body = new Encoder()\n  // Make space for the header at the beginning of the body buffer. We will\n  // copy the header in here later. This is cheaper than copying the body since\n  // the body is likely to be much larger than the header.\n  body.appendRawBytes(new Uint8Array(HEADER_SPACE))\n  encodeContentsCallback(body)\n\n  const bodyBuf = body.buffer\n  const header = new Encoder()\n  header.appendByte(chunkType)\n  header.appendUint53(bodyBuf.byteLength - HEADER_SPACE)\n\n  // Compute the hash over chunkType, length, and body\n  const headerBuf = header.buffer\n  const sha256 = new Hash()\n  sha256.update(headerBuf)\n  sha256.update(bodyBuf.subarray(HEADER_SPACE))\n  const hash = sha256.digest(), checksum = hash.subarray(0, CHECKSUM_SIZE)\n\n  // Copy header into the body buffer so that they are contiguous\n  bodyBuf.set(MAGIC_BYTES, HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength)\n  bodyBuf.set(checksum,    HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE)\n  bodyBuf.set(headerBuf,   HEADER_SPACE - headerBuf.byteLength)\n  return {hash, bytes: bodyBuf.subarray(HEADER_SPACE - headerBuf.byteLength - CHECKSUM_SIZE - MAGIC_BYTES.byteLength)}\n}\n\nfunction decodeContainerHeader(decoder, computeHash) {\n  if (!equalBytes(decoder.readRawBytes(MAGIC_BYTES.byteLength), MAGIC_BYTES)) {\n    throw new RangeError('Data does not begin with magic bytes 85 6f 4a 83')\n  }\n  const expectedHash = decoder.readRawBytes(4)\n  const hashStartOffset = decoder.offset\n  const chunkType = decoder.readByte()\n  const chunkLength = decoder.readUint53()\n  const header = {chunkType, chunkLength, chunkData: decoder.readRawBytes(chunkLength)}\n\n  if (computeHash) {\n    const sha256 = new Hash()\n    sha256.update(decoder.buf.subarray(hashStartOffset, decoder.offset))\n    const binaryHash = sha256.digest()\n    if (!equalBytes(binaryHash.subarray(0, 4), expectedHash)) {\n      throw new RangeError('checksum does not match data')\n    }\n    header.hash = bytesToHexString(binaryHash)\n  }\n  return header\n}\n\nfunction encodeChange(changeObj) {\n  if (encoded.has(changeObj)) return encoded.get(changeObj)\n  const { changes, actorIds } = parseAllOpIds([changeObj], true)\n  const change = changes[0]\n\n  const { hash, bytes } = encodeContainer(CHUNK_TYPE_CHANGE, encoder => {\n    if (!Array.isArray(change.deps)) throw new TypeError('deps is not an array')\n    encoder.appendUint53(change.deps.length)\n    for (let hash of change.deps.slice().sort()) {\n      encoder.appendRawBytes(hexStringToBytes(hash))\n    }\n    encoder.appendHexString(change.actor)\n    encoder.appendUint53(change.seq)\n    encoder.appendUint53(change.startOp)\n    encoder.appendInt53(change.time)\n    encoder.appendPrefixedString(change.message || '')\n    encoder.appendUint53(actorIds.length - 1)\n    for (let actor of actorIds.slice(1)) encoder.appendHexString(actor)\n\n    const columns = encodeOps(change.ops, false)\n    encodeColumnInfo(encoder, columns)\n    for (let column of columns) encoder.appendRawBytes(column.encoder.buffer)\n    if (change.extraBytes) encoder.appendRawBytes(change.extraBytes)\n  })\n\n  const hexHash = bytesToHexString(hash)\n  if (changeObj.hash && changeObj.hash !== hexHash) {\n    throw new RangeError(`Change hash does not match encoding: ${changeObj.hash} != ${hexHash}`)\n  }\n  return (bytes.byteLength >= DEFLATE_MIN_SIZE) ? deflateChange(bytes) : bytes\n}\n\nfunction decodeChangeColumns(buffer) {\n  if (buffer[8] === CHUNK_TYPE_DEFLATE) buffer = inflateChange(buffer)\n  const decoder = new Decoder(buffer)\n  const header = decodeContainerHeader(decoder, true)\n  const chunkDecoder = new Decoder(header.chunkData)\n  if (!decoder.done) throw new RangeError('Encoded change has trailing data')\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n\n  const change = decodeChangeHeader(chunkDecoder)\n  const columns = decodeColumnInfo(chunkDecoder)\n  for (let i = 0; i < columns.length; i++) {\n    if ((columns[i].columnId & COLUMN_TYPE_DEFLATE) !== 0) {\n      throw new RangeError('change must not contain deflated columns')\n    }\n    columns[i].buffer = chunkDecoder.readRawBytes(columns[i].bufferLen)\n  }\n  if (!chunkDecoder.done) {\n    const restLen = chunkDecoder.buf.byteLength - chunkDecoder.offset\n    change.extraBytes = chunkDecoder.readRawBytes(restLen)\n  }\n\n  change.columns = columns\n  change.hash = header.hash\n  return change\n}\n\nconst encoded = new WeakMap() // change => buffer\n/**\n * Decodes one change in binary format into its JS object representation.\n */\nfunction decodeChange(buffer) {\n  const change = decodeChangeColumns(buffer)\n  change.ops = decodeOps(decodeColumns(change.columns, change.actorIds, CHANGE_COLUMNS), false)\n  delete change.actorIds\n  delete change.columns\n  encoded.set(change, buffer)\n  return change\n}\n\n/**\n * Decodes the header fields of a change in binary format, but does not decode\n * the operations. Saves work when we only need to inspect the headers. Only\n * computes the hash of the change if `computeHash` is true.\n */\nfunction decodeChangeMeta(buffer, computeHash) {\n  if (buffer[8] === CHUNK_TYPE_DEFLATE) buffer = inflateChange(buffer)\n  const header = decodeContainerHeader(new Decoder(buffer), computeHash)\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) {\n    throw new RangeError('Buffer chunk type is not a change')\n  }\n  const meta = decodeChangeHeader(new Decoder(header.chunkData))\n  meta.change = buffer\n  if (computeHash) meta.hash = header.hash\n  return meta\n}\n\n/**\n * Compresses a binary change using DEFLATE.\n */\nfunction deflateChange(buffer) {\n  const header = decodeContainerHeader(new Decoder(buffer), false)\n  if (header.chunkType !== CHUNK_TYPE_CHANGE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n  const compressed = pako.deflateRaw(header.chunkData)\n  const encoder = new Encoder()\n  encoder.appendRawBytes(buffer.subarray(0, 8)) // copy MAGIC_BYTES and checksum\n  encoder.appendByte(CHUNK_TYPE_DEFLATE)\n  encoder.appendUint53(compressed.byteLength)\n  encoder.appendRawBytes(compressed)\n  return encoder.buffer\n}\n\n/**\n * Decompresses a binary change that has been compressed with DEFLATE.\n */\nfunction inflateChange(buffer) {\n  const header = decodeContainerHeader(new Decoder(buffer), false)\n  if (header.chunkType !== CHUNK_TYPE_DEFLATE) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n  const decompressed = pako.inflateRaw(header.chunkData)\n  const encoder = new Encoder()\n  encoder.appendRawBytes(buffer.subarray(0, 8)) // copy MAGIC_BYTES and checksum\n  encoder.appendByte(CHUNK_TYPE_CHANGE)\n  encoder.appendUint53(decompressed.byteLength)\n  encoder.appendRawBytes(decompressed)\n  return encoder.buffer\n}\n\n/**\n * Takes an Uint8Array that may contain multiple concatenated changes, and\n * returns an array of subarrays, each subarray containing one change.\n */\nfunction splitContainers(buffer) {\n  let decoder = new Decoder(buffer), chunks = [], startOffset = 0\n  while (!decoder.done) {\n    decodeContainerHeader(decoder, false)\n    chunks.push(buffer.subarray(startOffset, decoder.offset))\n    startOffset = decoder.offset\n  }\n  return chunks\n}\n\n/**\n * Decodes a list of changes from the binary format into JS objects.\n * `binaryChanges` is an array of `Uint8Array` objects.\n */\nfunction decodeChanges(binaryChanges) {\n  let decoded = []\n  for (let binaryChange of binaryChanges) {\n    for (let chunk of splitContainers(binaryChange)) {\n      if (chunk[8] === CHUNK_TYPE_DOCUMENT) {\n        decoded = decoded.concat(decodeDocument(chunk))\n      } else if (chunk[8] === CHUNK_TYPE_CHANGE || chunk[8] === CHUNK_TYPE_DEFLATE) {\n        decoded.push(decodeChange(chunk))\n      } else {\n        // ignoring chunk of unknown type\n      }\n    }\n  }\n  return decoded\n}\n\nfunction sortOpIds(a, b) {\n  if (a === b) return 0\n  if (a === '_root') return -1\n  if (b === '_root') return +1\n  const a_ = parseOpId(a), b_ = parseOpId(b)\n  if (a_.counter < b_.counter) return -1\n  if (a_.counter > b_.counter) return +1\n  if (a_.actorId < b_.actorId) return -1\n  if (a_.actorId > b_.actorId) return +1\n  return 0\n}\n\n/**\n * Takes a set of operations `ops` loaded from an encoded document, and\n * reconstructs the changes that they originally came from.\n * Does not return anything, only mutates `changes`.\n */\nfunction groupChangeOps(changes, ops) {\n  let changesByActor = {} // map from actorId to array of changes by that actor\n  for (let change of changes) {\n    change.ops = []\n    if (!changesByActor[change.actor]) changesByActor[change.actor] = []\n    if (change.seq !== changesByActor[change.actor].length + 1) {\n      throw new RangeError(`Expected seq = ${changesByActor[change.actor].length + 1}, got ${change.seq}`)\n    }\n    if (change.seq > 1 && changesByActor[change.actor][change.seq - 2].maxOp > change.maxOp) {\n      throw new RangeError('maxOp must increase monotonically per actor')\n    }\n    changesByActor[change.actor].push(change)\n  }\n\n  let opsById = {}\n  for (let op of ops) {\n    if (op.action === 'del') throw new RangeError('document should not contain del operations')\n    op.pred = opsById[op.id] ? opsById[op.id].pred : []\n    opsById[op.id] = op\n    for (let succ of op.succ) {\n      if (!opsById[succ]) {\n        if (op.elemId) {\n          const elemId = op.insert ? op.id : op.elemId\n          opsById[succ] = {id: succ, action: 'del', obj: op.obj, elemId, pred: []}\n        } else {\n          opsById[succ] = {id: succ, action: 'del', obj: op.obj, key: op.key, pred: []}\n        }\n      }\n      opsById[succ].pred.push(op.id)\n    }\n    delete op.succ\n  }\n  for (let op of Object.values(opsById)) {\n    if (op.action === 'del') ops.push(op)\n  }\n\n  for (let op of ops) {\n    const { counter, actorId } = parseOpId(op.id)\n    const actorChanges = changesByActor[actorId]\n    // Binary search to find the change that should contain this operation\n    let left = 0, right = actorChanges.length\n    while (left < right) {\n      const index = Math.floor((left + right) / 2)\n      if (actorChanges[index].maxOp < counter) {\n        left = index + 1\n      } else {\n        right = index\n      }\n    }\n    if (left >= actorChanges.length) {\n      throw new RangeError(`Operation ID ${op.id} outside of allowed range`)\n    }\n    actorChanges[left].ops.push(op)\n  }\n\n  for (let change of changes) {\n    change.ops.sort((op1, op2) => sortOpIds(op1.id, op2.id))\n    change.startOp = change.maxOp - change.ops.length + 1\n    delete change.maxOp\n    for (let i = 0; i < change.ops.length; i++) {\n      const op = change.ops[i], expectedId = `${change.startOp + i}@${change.actor}`\n      if (op.id !== expectedId) {\n        throw new RangeError(`Expected opId ${expectedId}, got ${op.id}`)\n      }\n      delete op.id\n    }\n  }\n}\n\nfunction decodeDocumentChanges(changes, expectedHeads) {\n  let heads = {} // change hashes that are not a dependency of any other change\n  for (let i = 0; i < changes.length; i++) {\n    let change = changes[i]\n    change.deps = []\n    for (let index of change.depsNum.map(d => d.depsIndex)) {\n      if (!changes[index] || !changes[index].hash) {\n        throw new RangeError(`No hash for index ${index} while processing index ${i}`)\n      }\n      const hash = changes[index].hash\n      change.deps.push(hash)\n      if (heads[hash]) delete heads[hash]\n    }\n    change.deps.sort()\n    delete change.depsNum\n\n    if (change.extraLen_datatype !== VALUE_TYPE.BYTES) {\n      throw new RangeError(`Bad datatype for extra bytes: ${VALUE_TYPE.BYTES}`)\n    }\n    change.extraBytes = change.extraLen\n    delete change.extraLen_datatype\n\n    // Encoding and decoding again to compute the hash of the change\n    changes[i] = decodeChange(encodeChange(change))\n    heads[changes[i].hash] = true\n  }\n\n  const actualHeads = Object.keys(heads).sort()\n  let headsEqual = (actualHeads.length === expectedHeads.length), i = 0\n  while (headsEqual && i < actualHeads.length) {\n    headsEqual = (actualHeads[i] === expectedHeads[i])\n    i++\n  }\n  if (!headsEqual) {\n    throw new RangeError(`Mismatched heads hashes: expected ${expectedHeads.join(', ')}, got ${actualHeads.join(', ')}`)\n  }\n}\n\nfunction encodeDocumentHeader(doc) {\n  const { changesColumns, opsColumns, actorIds, heads, headsIndexes, extraBytes } = doc\n  for (let column of changesColumns) deflateColumn(column)\n  for (let column of opsColumns) deflateColumn(column)\n\n  return encodeContainer(CHUNK_TYPE_DOCUMENT, encoder => {\n    encoder.appendUint53(actorIds.length)\n    for (let actor of actorIds) {\n      encoder.appendHexString(actor)\n    }\n    encoder.appendUint53(heads.length)\n    for (let head of heads.sort()) {\n      encoder.appendRawBytes(hexStringToBytes(head))\n    }\n    encodeColumnInfo(encoder, changesColumns)\n    encodeColumnInfo(encoder, opsColumns)\n    for (let column of changesColumns) encoder.appendRawBytes(column.encoder.buffer)\n    for (let column of opsColumns) encoder.appendRawBytes(column.encoder.buffer)\n    for (let index of headsIndexes) encoder.appendUint53(index)\n    if (extraBytes) encoder.appendRawBytes(extraBytes)\n  }).bytes\n}\n\nfunction decodeDocumentHeader(buffer) {\n  const documentDecoder = new Decoder(buffer)\n  const header = decodeContainerHeader(documentDecoder, true)\n  const decoder = new Decoder(header.chunkData)\n  if (!documentDecoder.done) throw new RangeError('Encoded document has trailing data')\n  if (header.chunkType !== CHUNK_TYPE_DOCUMENT) throw new RangeError(`Unexpected chunk type: ${header.chunkType}`)\n\n  const actorIds = [], numActors = decoder.readUint53()\n  for (let i = 0; i < numActors; i++) {\n    actorIds.push(decoder.readHexString())\n  }\n  const heads = [], headsIndexes = [], numHeads = decoder.readUint53()\n  for (let i = 0; i < numHeads; i++) {\n    heads.push(bytesToHexString(decoder.readRawBytes(32)))\n  }\n\n  const changesColumns = decodeColumnInfo(decoder)\n  const opsColumns = decodeColumnInfo(decoder)\n  for (let i = 0; i < changesColumns.length; i++) {\n    changesColumns[i].buffer = decoder.readRawBytes(changesColumns[i].bufferLen)\n    inflateColumn(changesColumns[i])\n  }\n  for (let i = 0; i < opsColumns.length; i++) {\n    opsColumns[i].buffer = decoder.readRawBytes(opsColumns[i].bufferLen)\n    inflateColumn(opsColumns[i])\n  }\n  if (!decoder.done) {\n    for (let i = 0; i < numHeads; i++) headsIndexes.push(decoder.readUint53())\n  }\n\n  const extraBytes = decoder.readRawBytes(decoder.buf.byteLength - decoder.offset)\n  return { changesColumns, opsColumns, actorIds, heads, headsIndexes, extraBytes }\n}\n\nfunction decodeDocument(buffer) {\n  const { changesColumns, opsColumns, actorIds, heads } = decodeDocumentHeader(buffer)\n  const changes = decodeColumns(changesColumns, actorIds, DOCUMENT_COLUMNS)\n  const ops = decodeOps(decodeColumns(opsColumns, actorIds, DOC_OPS_COLUMNS), true)\n  groupChangeOps(changes, ops)\n  decodeDocumentChanges(changes, heads)\n  return changes\n}\n\n/**\n * DEFLATE-compresses the given column if it is large enough to make the compression worthwhile.\n */\nfunction deflateColumn(column) {\n  if (column.encoder.buffer.byteLength >= DEFLATE_MIN_SIZE) {\n    column.encoder = {buffer: pako.deflateRaw(column.encoder.buffer)}\n    column.columnId |= COLUMN_TYPE_DEFLATE\n  }\n}\n\n/**\n * Decompresses the given column if it is DEFLATE-compressed.\n */\nfunction inflateColumn(column) {\n  if ((column.columnId & COLUMN_TYPE_DEFLATE) !== 0) {\n    column.buffer = pako.inflateRaw(column.buffer)\n    column.columnId ^= COLUMN_TYPE_DEFLATE\n  }\n}\n\nmodule.exports = {\n  COLUMN_TYPE, VALUE_TYPE, ACTIONS, OBJECT_TYPE, DOC_OPS_COLUMNS, CHANGE_COLUMNS, DOCUMENT_COLUMNS,\n  encoderByColumnId, decoderByColumnId, makeDecoders, decodeValue,\n  splitContainers, encodeChange, decodeChangeColumns, decodeChange, decodeChangeMeta, decodeChanges,\n  encodeDocumentHeader, decodeDocumentHeader, decodeDocument\n}\n","/**\n * UTF-8 decoding and encoding using API that is supported in Node >= 12 and modern browsers:\n * https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode\n * https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/decode\n * If you're running in an environment where it's not available, please use a polyfill, such as:\n * https://github.com/anonyco/FastestSmallestTextEncoderDecoder\n */\nconst utf8encoder = new TextEncoder()\nconst utf8decoder = new TextDecoder('utf-8')\n\nfunction stringToUtf8(string) {\n  return utf8encoder.encode(string)\n}\n\nfunction utf8ToString(buffer) {\n  return utf8decoder.decode(buffer)\n}\n\n/**\n * Converts a string consisting of hexadecimal digits into an Uint8Array.\n */\nfunction hexStringToBytes(value) {\n  if (typeof value !== 'string') {\n    throw new TypeError('value is not a string')\n  }\n  if (!/^([0-9a-f][0-9a-f])*$/.test(value)) {\n    throw new RangeError('value is not hexadecimal')\n  }\n  if (value === '') {\n    return new Uint8Array(0)\n  } else {\n    return new Uint8Array(value.match(/../g).map(b => parseInt(b, 16)))\n  }\n}\n\nconst NIBBLE_TO_HEX = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']\nconst BYTE_TO_HEX = new Array(256)\nfor (let i = 0; i < 256; i++) {\n  BYTE_TO_HEX[i] = `${NIBBLE_TO_HEX[(i >>> 4) & 0xf]}${NIBBLE_TO_HEX[i & 0xf]}`;\n}\n\n/**\n * Converts a Uint8Array into the equivalent hexadecimal string.\n */\nfunction bytesToHexString(bytes) {\n  let hex = '', len = bytes.byteLength\n  for (let i = 0; i < len; i++) {\n    hex += BYTE_TO_HEX[bytes[i]]\n  }\n  return hex\n}\n\n/**\n * Wrapper around an Uint8Array that allows values to be appended to the buffer,\n * and that automatically grows the buffer when space runs out.\n */\nclass Encoder {\n  constructor() {\n    this.buf = new Uint8Array(16)\n    this.offset = 0\n  }\n\n  /**\n   * Returns the byte array containing the encoded data.\n   */\n  get buffer() {\n    this.finish()\n    return this.buf.subarray(0, this.offset)\n  }\n\n  /**\n   * Reallocates the encoder's buffer to be bigger.\n   */\n  grow(minSize = 0) {\n    let newSize = this.buf.byteLength * 4\n    while (newSize < minSize) newSize *= 2\n    const newBuf = new Uint8Array(newSize)\n    newBuf.set(this.buf, 0)\n    this.buf = newBuf\n    return this\n  }\n\n  /**\n   * Appends one byte (0 to 255) to the buffer.\n   */\n  appendByte(value) {\n    if (this.offset >= this.buf.byteLength) this.grow()\n    this.buf[this.offset] = value\n    this.offset += 1\n  }\n\n  /**\n   * Encodes a 32-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and\n   * appends it to the buffer. Returns the number of bytes written.\n   */\n  appendUint32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < 0 || value > 0xffffffff) throw new RangeError('number out of range')\n\n    const numBytes = Math.max(1, Math.ceil((32 - Math.clz32(value)) / 7))\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = (value & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      value >>>= 7 // zero-filling right shift\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a 32-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme (https://en.wikipedia.org/wiki/LEB128) and appends\n   * it to the buffer. Returns the number of bytes written.\n   */\n  appendInt32(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < -0x80000000 || value > 0x7fffffff) throw new RangeError('number out of range')\n\n    const numBytes = Math.ceil((33 - Math.clz32(value >= 0 ? value : -value - 1)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n\n    for (let i = 0; i < numBytes; i++) {\n      this.buf[this.offset + i] = (value & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      value >>= 7 // sign-propagating right shift\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a nonnegative integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n  appendUint53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < 0 || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range')\n    }\n    const high32 = Math.floor(value / 0x100000000)\n    const low32 = (value & 0xffffffff) >>> 0 // right shift to interpret as unsigned\n    return this.appendUint64(high32, low32)\n  }\n\n  /**\n   * Encodes a signed integer in a variable number of bytes using the LEB128\n   * encoding scheme, up to the maximum size of integers supported by JavaScript\n   * (53 bits).\n   */\n  appendInt53(value) {\n    if (!Number.isInteger(value)) throw new RangeError('value is not an integer')\n    if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n      throw new RangeError('number out of range')\n    }\n    const high32 = Math.floor(value / 0x100000000)\n    const low32 = (value & 0xffffffff) >>> 0 // right shift to interpret as unsigned\n    return this.appendInt64(high32, low32)\n  }\n\n  /**\n   * Encodes a 64-bit nonnegative integer in a variable number of bytes using\n   * the LEB128 encoding scheme, and appends it to the buffer. The number is\n   * given as two 32-bit halves since JavaScript cannot accurately represent\n   * integers with more than 53 bits in a single variable.\n   */\n  appendUint64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer')\n    }\n    if (high32 < 0 || high32 > 0xffffffff || low32 < 0 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range')\n    }\n    if (high32 === 0) return this.appendUint32(low32)\n\n    const numBytes = Math.ceil((64 - Math.clz32(high32)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = (low32 & 0x7f) | 0x80\n      low32 >>>= 7 // zero-filling right shift\n    }\n    this.buf[this.offset + 4] = (low32 & 0x0f) | ((high32 & 0x07) << 4) | (numBytes === 5 ? 0x00 : 0x80)\n    high32 >>>= 3\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = (high32 & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      high32 >>>= 7\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Encodes a 64-bit signed integer in a variable number of bytes using the\n   * LEB128 encoding scheme, and appends it to the buffer. The number is given\n   * as two 32-bit halves since JavaScript cannot accurately represent integers\n   * with more than 53 bits in a single variable. The sign of the 64-bit\n   * number is determined by the sign of the `high32` half; the sign of the\n   * `low32` half is ignored.\n   */\n  appendInt64(high32, low32) {\n    if (!Number.isInteger(high32) || !Number.isInteger(low32)) {\n      throw new RangeError('value is not an integer')\n    }\n    if (high32 < -0x80000000 || high32 > 0x7fffffff || low32 < -0x80000000 || low32 > 0xffffffff) {\n      throw new RangeError('number out of range')\n    }\n    low32 >>>= 0 // interpret as unsigned\n    if (high32 === 0 && low32 <= 0x7fffffff) return this.appendInt32(low32)\n    if (high32 === -1 && low32 >= 0x80000000) return this.appendInt32(low32 - 0x100000000)\n\n    const numBytes = Math.ceil((65 - Math.clz32(high32 >= 0 ? high32 : -high32 - 1)) / 7)\n    if (this.offset + numBytes > this.buf.byteLength) this.grow()\n    for (let i = 0; i < 4; i++) {\n      this.buf[this.offset + i] = (low32 & 0x7f) | 0x80\n      low32 >>>= 7 // zero-filling right shift\n    }\n    this.buf[this.offset + 4] = (low32 & 0x0f) | ((high32 & 0x07) << 4) | (numBytes === 5 ? 0x00 : 0x80)\n    high32 >>= 3 // sign-propagating right shift\n    for (let i = 5; i < numBytes; i++) {\n      this.buf[this.offset + i] = (high32 & 0x7f) | (i === numBytes - 1 ? 0x00 : 0x80)\n      high32 >>= 7\n    }\n    this.offset += numBytes\n    return numBytes\n  }\n\n  /**\n   * Appends the contents of byte buffer `data` to the buffer. Returns the\n   * number of bytes appended.\n   */\n  appendRawBytes(data) {\n    if (this.offset + data.byteLength > this.buf.byteLength) {\n      this.grow(this.offset + data.byteLength)\n    }\n    this.buf.set(data, this.offset)\n    this.offset += data.byteLength\n    return data.byteLength\n  }\n\n  /**\n   * Appends a UTF-8 string to the buffer, without any metadata. Returns the\n   * number of bytes appended.\n   */\n  appendRawString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string')\n    return this.appendRawBytes(stringToUtf8(value))\n  }\n\n  /**\n   * Appends the contents of byte buffer `data` to the buffer, prefixed with the\n   * number of bytes in the buffer (as a LEB128-encoded unsigned integer).\n   */\n  appendPrefixedBytes(data) {\n    this.appendUint53(data.byteLength)\n    this.appendRawBytes(data)\n    return this\n  }\n\n  /**\n   * Appends a UTF-8 string to the buffer, prefixed with its length in bytes\n   * (where the length is encoded as an unsigned LEB128 integer).\n   */\n  appendPrefixedString(value) {\n    if (typeof value !== 'string') throw new TypeError('value is not a string')\n    this.appendPrefixedBytes(stringToUtf8(value))\n    return this\n  }\n\n  /**\n   * Takes a value, which must be a string consisting only of hexadecimal\n   * digits, maps it to a byte array, and appends it to the buffer, prefixed\n   * with its length in bytes.\n   */\n  appendHexString(value) {\n    this.appendPrefixedBytes(hexStringToBytes(value))\n    return this\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n  }\n}\n\n/**\n * Counterpart to Encoder. Wraps a Uint8Array buffer with a cursor indicating\n * the current decoding position, and allows values to be incrementally read by\n * decoding the bytes at the current position.\n */\nclass Decoder {\n  constructor(buffer) {\n    if (!(buffer instanceof Uint8Array)) {\n      throw new TypeError(`Not a byte array: ${buffer}`)\n    }\n    this.buf = buffer\n    this.offset = 0\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return this.offset === this.buf.byteLength\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n  }\n\n  /**\n   * Moves the current decoding position forward by the specified number of\n   * bytes, without decoding anything.\n   */\n  skip(bytes) {\n    if (this.offset + bytes > this.buf.byteLength) {\n      throw new RangeError('cannot skip beyond end of buffer')\n    }\n    this.offset += bytes\n  }\n\n  /**\n   * Reads one byte (0 to 255) from the buffer.\n   */\n  readByte() {\n    this.offset += 1\n    return this.buf[this.offset - 1]\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit unsigned int.\n   */\n  readUint32() {\n    let result = 0, shift = 0\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if (shift === 28 && (nextByte & 0xf0) !== 0) { // more than 5 bytes, or value > 0xffffffff\n        throw new RangeError('number out of range')\n      }\n      result = (result | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return result\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the buffer.\n   * Throws an exception if the value doesn't fit in a 32-bit signed int.\n   */\n  readInt32() {\n    let result = 0, shift = 0\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if ((shift === 28 && (nextByte & 0x80) !== 0) || // more than 5 bytes\n          (shift === 28 && (nextByte & 0x40) === 0 && (nextByte & 0x38) !== 0) || // positive int > 0x7fffffff\n          (shift === 28 && (nextByte & 0x40) !== 0 && (nextByte & 0x38) !== 0x38)) { // negative int < -0x80000000\n        throw new RangeError('number out of range')\n      }\n      result |= (nextByte & 0x7f) << shift\n      shift += 7\n      this.offset++\n\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) === 0 || shift > 28) {\n          return result // positive, or negative value that doesn't need sign-extending\n        } else {\n          return result | (-1 << shift) // sign-extend negative integer\n        }\n      }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (up to 2^53 - 1), and throws an exception outside of that range.\n   */\n  readUint53() {\n    const { low32, high32 } = this.readUint64()\n    if (high32 < 0 || high32 > 0x1fffff) {\n      throw new RangeError('number out of range')\n    }\n    return high32 * 0x100000000 + low32\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Allows any integer that can be safely represented by JavaScript\n   * (between -(2^53 - 1) and 2^53 - 1), throws an exception outside of that range.\n   */\n  readInt53() {\n    const { low32, high32 } = this.readInt64()\n    if (high32 < -0x200000 || (high32 === -0x200000 && low32 === 0) || high32 > 0x1fffff) {\n      throw new RangeError('number out of range')\n    }\n    return high32 * 0x100000000 + low32\n  }\n\n  /**\n   * Reads a LEB128-encoded unsigned integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit unsigned\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`.\n   */\n  readUint64() {\n    let low32 = 0, high32 = 0, shift = 0\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset]\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4\n      }\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return { high32, low32 }\n    }\n\n    shift = 3\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      if (shift === 31 && (nextByte & 0xfe) !== 0) { // more than 10 bytes, or value > 2^64 - 1\n        throw new RangeError('number out of range')\n      }\n      high32 = (high32 | (nextByte & 0x7f) << shift) >>> 0\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) return { high32, low32 }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Reads a LEB128-encoded signed integer from the current position in the\n   * buffer. Throws an exception if the value doesn't fit in a 64-bit signed\n   * int. Returns the number in two 32-bit halves, as an object of the form\n   * `{high32, low32}`. The `low32` half is always non-negative, and the\n   * sign of the `high32` half indicates the sign of the 64-bit number.\n   */\n  readInt64() {\n    let low32 = 0, high32 = 0, shift = 0\n    while (this.offset < this.buf.byteLength && shift <= 28) {\n      const nextByte = this.buf[this.offset]\n      low32 = (low32 | (nextByte & 0x7f) << shift) >>> 0 // right shift to interpret value as unsigned\n      if (shift === 28) {\n        high32 = (nextByte & 0x70) >>> 4\n      }\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0) { // sign-extend negative integer\n          if (shift < 32) low32 = (low32 | (-1 << shift)) >>> 0\n          high32 |= -1 << Math.max(shift - 32, 0)\n        }\n        return { high32, low32 }\n      }\n    }\n\n    shift = 3\n    while (this.offset < this.buf.byteLength) {\n      const nextByte = this.buf[this.offset]\n      // On the 10th byte there are only two valid values: all 7 value bits zero\n      // (if the value is positive) or all 7 bits one (if the value is negative)\n      if (shift === 31 && nextByte !== 0 && nextByte !== 0x7f) {\n        throw new RangeError('number out of range')\n      }\n      high32 |= (nextByte & 0x7f) << shift\n      shift += 7\n      this.offset++\n      if ((nextByte & 0x80) === 0) {\n        if ((nextByte & 0x40) !== 0 && shift < 32) { // sign-extend negative integer\n          high32 |= -1 << shift\n        }\n        return { high32, low32 }\n      }\n    }\n    throw new RangeError('buffer ended with incomplete number')\n  }\n\n  /**\n   * Extracts a subarray `length` bytes in size, starting from the current\n   * position in the buffer, and moves the position forward.\n   */\n  readRawBytes(length) {\n    const start = this.offset\n    if (start + length > this.buf.byteLength) {\n      throw new RangeError('subarray exceeds buffer size')\n    }\n    this.offset += length\n    return this.buf.subarray(start, this.offset)\n  }\n\n  /**\n   * Extracts `length` bytes from the buffer, starting from the current position,\n   * and returns the UTF-8 string decoding of those bytes.\n   */\n  readRawString(length) {\n    return utf8ToString(this.readRawBytes(length))\n  }\n\n  /**\n   * Extracts a subarray from the current position in the buffer, prefixed with\n   * its length in bytes (encoded as an unsigned LEB128 integer).\n   */\n  readPrefixedBytes() {\n    return this.readRawBytes(this.readUint53())\n  }\n\n  /**\n   * Reads a UTF-8 string from the current position in the buffer, prefixed with its\n   * length in bytes (where the length is encoded as an unsigned LEB128 integer).\n   */\n  readPrefixedString() {\n    return utf8ToString(this.readPrefixedBytes())\n  }\n\n  /**\n   * Reads a byte array from the current position in the buffer, prefixed with its\n   * length in bytes. Returns that byte array converted to a hexadecimal string.\n   */\n  readHexString() {\n    return bytesToHexString(this.readPrefixedBytes())\n  }\n}\n\n/**\n * An encoder that uses run-length encoding to compress sequences of repeated\n * values. The constructor argument specifies the type of values, which may be\n * either 'int', 'uint', or 'utf8'. Besides valid values of the selected\n * datatype, values may also be null.\n *\n * The encoded buffer starts with a LEB128-encoded signed integer, the\n * repetition count. The interpretation of the following values depends on this\n * repetition count:\n *   - If this number is a positive value n, the next value in the buffer\n *     (encoded as the specified datatype) is repeated n times in the sequence.\n *   - If the repetition count is a negative value -n, then the next n values\n *     (encoded as the specified datatype) in the buffer are treated as a\n *     literal, i.e. they appear in the sequence without any further\n *     interpretation or repetition.\n *   - If the repetition count is zero, then the next value in the buffer is a\n *     LEB128-encoded unsigned integer indicating the number of null values\n *     that appear at the current position in the sequence.\n *\n * After one of these three has completed, the process repeats, starting again\n * with a repetition count, until we reach the end of the buffer.\n */\nclass RLEEncoder extends Encoder {\n  constructor(type) {\n    super()\n    this.type = type\n    this.state = 'empty'\n    this.lastValue = undefined\n    this.count = 0\n    this.literal = []\n  }\n\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    this._appendValue(value, repetitions)\n  }\n\n  /**\n   * Like `appendValue()`, but this method is not overridden by `DeltaEncoder`.\n   */\n  _appendValue(value, repetitions = 1) {\n    if (repetitions <= 0) return\n    if (this.state === 'empty') {\n      this.state = (value === null ? 'nulls' : (repetitions === 1 ? 'loneValue' : 'repetition'))\n      this.lastValue = value\n      this.count = repetitions\n    } else if (this.state === 'loneValue') {\n      if (value === null) {\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.state = 'repetition'\n        this.count = 1 + repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.state = 'literal'\n        this.literal = [this.lastValue]\n        this.lastValue = value\n      }\n    } else if (this.state === 'repetition') {\n      if (value === null) {\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.count += repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.flush()\n        this.state = 'loneValue'\n        this.lastValue = value\n      }\n    } else if (this.state === 'literal') {\n      if (value === null) {\n        this.literal.push(this.lastValue)\n        this.flush()\n        this.state = 'nulls'\n        this.count = repetitions\n      } else if (value === this.lastValue) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = 1 + repetitions\n      } else if (repetitions > 1) {\n        this.literal.push(this.lastValue)\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.literal.push(this.lastValue)\n        this.lastValue = value\n      }\n    } else if (this.state === 'nulls') {\n      if (value === null) {\n        this.count += repetitions\n      } else if (repetitions > 1) {\n        this.flush()\n        this.state = 'repetition'\n        this.count = repetitions\n        this.lastValue = value\n      } else {\n        this.flush()\n        this.state = 'loneValue'\n        this.lastValue = value\n      }\n    }\n  }\n\n  /**\n   * Copies values from the RLEDecoder `decoder` into this encoder. The `options` object may\n   * contain the following keys:\n   *  - `count`: The number of values to copy. If not specified, copies all remaining values.\n   *  - `sumValues`: If true, the function computes the sum of all numeric values as they are\n   *    copied (null values are counted as zero), and returns that number.\n   *  - `sumShift`: If set, values are shifted right by `sumShift` bits before adding to the sum.\n   *\n   * Returns an object of the form `{nonNullValues, sum}` where `nonNullValues` is the number of\n   * non-null values copied, and `sum` is the sum (only if the `sumValues` option is set).\n   */\n  copyFrom(decoder, options = {}) {\n    const { count, sumValues, sumShift } = options\n    if (!(decoder instanceof RLEDecoder) || (decoder.type !== this.type)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n    let remaining = (typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER)\n    let nonNullValues = 0, sum = 0\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return sumValues ? {nonNullValues, sum} : {nonNullValues}\n\n    // Copy a value so that we have a well-defined starting state. NB: when super.copyFrom() is\n    // called by the DeltaEncoder subclass, the following calls to readValue() and appendValue()\n    // refer to the overridden methods, while later readRecord(), readRawValue() and _appendValue()\n    // calls refer to the non-overridden RLEDecoder/RLEEncoder methods.\n    let firstValue = decoder.readValue()\n    if (firstValue === null) {\n      const numNulls = Math.min(decoder.count + 1, remaining)\n      remaining -= numNulls\n      decoder.count -= numNulls - 1\n      this.appendValue(null, numNulls)\n      if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n      if (remaining === 0 || decoder.done) return sumValues ? {nonNullValues, sum} : {nonNullValues}\n      firstValue = decoder.readValue()\n      if (firstValue === null) throw new RangeError('null run must be followed by non-null value')\n    }\n    this.appendValue(firstValue)\n    remaining--\n    nonNullValues++\n    if (sumValues) sum += (sumShift ? (firstValue >>> sumShift) : firstValue)\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return sumValues ? {nonNullValues, sum} : {nonNullValues}\n\n    // Copy data at the record level without expanding repetitions\n    let firstRun = (decoder.count > 0)\n    while (remaining > 0 && !decoder.done) {\n      if (!firstRun) decoder.readRecord()\n      const numValues = Math.min(decoder.count, remaining)\n      decoder.count -= numValues\n\n      if (decoder.state === 'literal') {\n        nonNullValues += numValues\n        for (let i = 0; i < numValues; i++) {\n          if (decoder.done) throw new RangeError('incomplete literal')\n          const value = decoder.readRawValue()\n          if (value === decoder.lastValue) throw new RangeError('Repetition of values is not allowed in literal')\n          decoder.lastValue = value\n          this._appendValue(value)\n          if (sumValues) sum += (sumShift ? (value >>> sumShift) : value)\n        }\n      } else if (decoder.state === 'repetition') {\n        nonNullValues += numValues\n        if (sumValues) sum += numValues * (sumShift ? (decoder.lastValue >>> sumShift) : decoder.lastValue)\n        const value = decoder.lastValue\n        this._appendValue(value)\n        if (numValues > 1) {\n          this._appendValue(value)\n          if (this.state !== 'repetition') throw new RangeError(`Unexpected state ${this.state}`)\n          this.count += numValues - 2\n        }\n      } else if (decoder.state === 'nulls') {\n        this._appendValue(null)\n        if (this.state !== 'nulls') throw new RangeError(`Unexpected state ${this.state}`)\n        this.count += numValues - 1\n      }\n\n      firstRun = false\n      remaining -= numValues\n    }\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    return sumValues ? {nonNullValues, sum} : {nonNullValues}\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   */\n  flush() {\n    if (this.state === 'loneValue') {\n      this.appendInt32(-1)\n      this.appendRawValue(this.lastValue)\n    } else if (this.state === 'repetition') {\n      this.appendInt53(this.count)\n      this.appendRawValue(this.lastValue)\n    } else if (this.state === 'literal') {\n      this.appendInt53(-this.literal.length)\n      for (let v of this.literal) this.appendRawValue(v)\n    } else if (this.state === 'nulls') {\n      this.appendInt32(0)\n      this.appendUint53(this.count)\n    }\n    this.state = 'empty'\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   */\n  appendRawValue(value) {\n    if (this.type === 'int') {\n      this.appendInt53(value)\n    } else if (this.type === 'uint') {\n      this.appendUint53(value)\n    } else if (this.type === 'utf8') {\n      this.appendPrefixedString(value)\n    } else {\n      throw new RangeError(`Unknown RLEEncoder datatype: ${this.type}`)\n    }\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n    if (this.state === 'literal') this.literal.push(this.lastValue)\n    // Don't write anything if the only values we have seen are nulls\n    if (this.state !== 'nulls' || this.offset > 0) this.flush()\n  }\n}\n\n/**\n * Counterpart to RLEEncoder: reads values from an RLE-compressed sequence,\n * returning nulls and repeated values as required.\n */\nclass RLEDecoder extends Decoder {\n  constructor(type, buffer) {\n    super(buffer)\n    this.type = type\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return (this.count === 0) && (this.offset === this.buf.byteLength)\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n  }\n\n  /**\n   * Returns the next value (or null) in the sequence.\n   */\n  readValue() {\n    if (this.done) return null\n    if (this.count === 0) this.readRecord()\n    this.count -= 1\n    if (this.state === 'literal') {\n      const value = this.readRawValue()\n      if (value === this.lastValue) throw new RangeError('Repetition of values is not allowed in literal')\n      this.lastValue = value\n      return value\n    } else {\n      return this.lastValue\n    }\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readInt53()\n        if (this.count > 0) {\n          this.lastValue = (this.count <= numSkip) ? this.skipRawValues(1) : this.readRawValue()\n          this.state = 'repetition'\n        } else if (this.count < 0) {\n          this.count = -this.count\n          this.state = 'literal'\n        } else { // this.count == 0\n          this.count = this.readUint53()\n          this.lastValue = null\n          this.state = 'nulls'\n        }\n      }\n\n      const consume = Math.min(numSkip, this.count)\n      if (this.state === 'literal') this.skipRawValues(consume)\n      numSkip -= consume\n      this.count -= consume\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Reads a repetition count from the buffer and sets up the state appropriately.\n   */\n  readRecord() {\n    this.count = this.readInt53()\n    if (this.count > 1) {\n      const value = this.readRawValue()\n      if ((this.state === 'repetition' || this.state === 'literal') && this.lastValue === value) {\n        throw new RangeError('Successive repetitions with the same value are not allowed')\n      }\n      this.state = 'repetition'\n      this.lastValue = value\n    } else if (this.count === 1) {\n      throw new RangeError('Repetition count of 1 is not allowed, use a literal instead')\n    } else if (this.count < 0) {\n      this.count = -this.count\n      if (this.state === 'literal') throw new RangeError('Successive literals are not allowed')\n      this.state = 'literal'\n    } else { // this.count == 0\n      if (this.state === 'nulls') throw new RangeError('Successive null runs are not allowed')\n      this.count = this.readUint53()\n      if (this.count === 0) throw new RangeError('Zero-length null runs are not allowed')\n      this.lastValue = null\n      this.state = 'nulls'\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Reads one value of the datatype configured on construction.\n   */\n  readRawValue() {\n    if (this.type === 'int') {\n      return this.readInt53()\n    } else if (this.type === 'uint') {\n      return this.readUint53()\n    } else if (this.type === 'utf8') {\n      return this.readPrefixedString()\n    } else {\n      throw new RangeError(`Unknown RLEDecoder datatype: ${this.type}`)\n    }\n  }\n\n  /**\n   * Private method, do not call from outside the class.\n   * Skips over `num` values of the datatype configured on construction.\n   */\n  skipRawValues(num) {\n    if (this.type === 'utf8') {\n      for (let i = 0; i < num; i++) this.skip(this.readUint53())\n    } else {\n      while (num > 0 && this.offset < this.buf.byteLength) {\n        if ((this.buf[this.offset] & 0x80) === 0) num--\n        this.offset++\n      }\n      if (num > 0) throw new RangeError('cannot skip beyond end of buffer')\n    }\n  }\n}\n\n/**\n * A variant of RLEEncoder: rather than storing the actual values passed to\n * appendValue(), this version stores only the first value, and for all\n * subsequent values it stores the difference to the previous value. This\n * encoding is good when values tend to come in sequentially incrementing runs,\n * because the delta between successive values is 1, and repeated values of 1\n * are easily compressed with run-length encoding.\n *\n * Null values are also allowed, as with RLEEncoder.\n */\nclass DeltaEncoder extends RLEEncoder {\n  constructor() {\n    super('int')\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Appends a new integer value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    if (repetitions <= 0) return\n    if (typeof value === 'number') {\n      super.appendValue(value - this.absoluteValue, 1)\n      this.absoluteValue = value\n      if (repetitions > 1) super.appendValue(0, repetitions - 1)\n    } else {\n      super.appendValue(value, repetitions)\n    }\n  }\n\n  /**\n   * Copies values from the DeltaDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n  copyFrom(decoder, options = {}) {\n    if (options.sumValues) {\n      throw new RangeError('unsupported options for DeltaEncoder.copyFrom()')\n    }\n    if (!(decoder instanceof DeltaDecoder)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n\n    let remaining = options.count\n    if (remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${remaining} values`)\n    if (remaining === 0 || decoder.done) return\n\n    // Copy any null values, and the first non-null value, so that appendValue() computes the\n    // difference between the encoder's last value and the decoder's first (absolute) value.\n    let value = decoder.readValue(), nulls = 0\n    this.appendValue(value)\n    if (value === null) {\n      nulls = decoder.count + 1\n      if (remaining !== undefined && remaining < nulls) nulls = remaining\n      decoder.count -= nulls - 1\n      this.count += nulls - 1\n      if (remaining > nulls && decoder.done) throw new RangeError(`cannot copy ${remaining} values`)\n      if (remaining === nulls || decoder.done) return\n\n      // The next value read is certain to be non-null because we're not at the end of the decoder,\n      // and a run of nulls must be followed by a run of non-nulls.\n      if (decoder.count === 0) this.appendValue(decoder.readValue())\n    }\n\n    // Once we have the first value, the subsequent relative values can be copied verbatim without\n    // any further processing. Note that the first value copied by super.copyFrom() is an absolute\n    // value, while subsequent values are relative. Thus, the sum of all of the (non-null) copied\n    // values must equal the absolute value of the final element copied.\n    if (remaining !== undefined) remaining -= nulls + 1\n    const { nonNullValues, sum } = super.copyFrom(decoder, {count: remaining, sumValues: true})\n    if (nonNullValues > 0) {\n      this.absoluteValue = sum\n      decoder.absoluteValue = sum\n    }\n  }\n}\n\n/**\n * Counterpart to DeltaEncoder: reads values from a delta-compressed sequence of\n * numbers (may include null values).\n */\nclass DeltaDecoder extends RLEDecoder {\n  constructor(buffer) {\n    super('int', buffer)\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = undefined\n    this.count = 0\n    this.state = undefined\n    this.absoluteValue = 0\n  }\n\n  /**\n   * Returns the next integer (or null) value in the sequence.\n   */\n  readValue() {\n    const value = super.readValue()\n    if (value === null) return null\n    this.absoluteValue += value\n    return this.absoluteValue\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) this.readRecord()\n      const consume = Math.min(numSkip, this.count)\n      if (this.state === 'literal') {\n        for (let i = 0; i < consume; i++) {\n          this.lastValue = this.readRawValue()\n          this.absoluteValue += this.lastValue\n        }\n      } else if (this.state === 'repetition') {\n        this.absoluteValue += consume * this.lastValue\n      }\n      numSkip -= consume\n      this.count -= consume\n    }\n  }\n}\n\n/**\n * Encodes a sequence of boolean values by mapping it to a sequence of integers:\n * the number of false values, followed by the number of true values, followed\n * by the number of false values, and so on. Each number is encoded as a LEB128\n * unsigned integer. This encoding is a bit like RLEEncoder, except that we\n * only encode the repetition count but not the actual value, since the values\n * just alternate between false and true (starting with false).\n */\nclass BooleanEncoder extends Encoder {\n  constructor() {\n    super()\n    this.lastValue = false\n    this.count = 0\n  }\n\n  /**\n   * Appends a new value to the sequence. If `repetitions` is given, the value is repeated\n   * `repetitions` times.\n   */\n  appendValue(value, repetitions = 1) {\n    if (value !== false && value !== true) {\n      throw new RangeError(`Unsupported value for BooleanEncoder: ${value}`)\n    }\n    if (repetitions <= 0) return\n    if (this.lastValue === value) {\n      this.count += repetitions\n    } else {\n      this.appendUint53(this.count)\n      this.lastValue = value\n      this.count = repetitions\n    }\n  }\n\n  /**\n   * Copies values from the BooleanDecoder `decoder` into this encoder. The `options` object may\n   * contain the key `count`, indicating the number of values to copy. If not specified, copies\n   * all remaining values in the decoder.\n   */\n  copyFrom(decoder, options = {}) {\n    if (!(decoder instanceof BooleanDecoder)) {\n      throw new TypeError('incompatible type of decoder')\n    }\n\n    const { count } = options\n    let remaining = (typeof count === 'number' ? count : Number.MAX_SAFE_INTEGER)\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n    if (remaining === 0 || decoder.done) return\n\n    // Copy one value to bring decoder and encoder state into sync, then finish that value's repetitions\n    this.appendValue(decoder.readValue())\n    remaining--\n    const firstCopy = Math.min(decoder.count, remaining)\n    this.count += firstCopy\n    decoder.count -= firstCopy\n    remaining -= firstCopy\n\n    while (remaining > 0 && !decoder.done) {\n      decoder.count = decoder.readUint53()\n      if (decoder.count === 0) throw new RangeError('Zero-length runs are not allowed')\n      decoder.lastValue = !decoder.lastValue\n      this.appendUint53(this.count)\n\n      const numCopied = Math.min(decoder.count, remaining)\n      this.count = numCopied\n      this.lastValue = decoder.lastValue\n      decoder.count -= numCopied\n      remaining -= numCopied\n    }\n\n    if (count && remaining > 0 && decoder.done) throw new RangeError(`cannot copy ${count} values`)\n  }\n\n  /**\n   * Flushes any unwritten data to the buffer. Call this before reading from\n   * the buffer constructed by this Encoder.\n   */\n  finish() {\n    if (this.count > 0) {\n      this.appendUint53(this.count)\n      this.count = 0\n    }\n  }\n}\n\n/**\n * Counterpart to BooleanEncoder: reads boolean values from a runlength-encoded\n * sequence.\n */\nclass BooleanDecoder extends Decoder {\n  constructor(buffer) {\n    super(buffer)\n    this.lastValue = true // is negated the first time we read a count\n    this.firstRun = true\n    this.count = 0\n  }\n\n  /**\n   * Returns false if there is still data to be read at the current decoding\n   * position, and true if we are at the end of the buffer.\n   */\n  get done() {\n    return (this.count === 0) && (this.offset === this.buf.byteLength)\n  }\n\n  /**\n   * Resets the cursor position, so that the next read goes back to the\n   * beginning of the buffer.\n   */\n  reset() {\n    this.offset = 0\n    this.lastValue = true\n    this.firstRun = true\n    this.count = 0\n  }\n\n  /**\n   * Returns the next value in the sequence.\n   */\n  readValue() {\n    if (this.done) return false\n    while (this.count === 0) {\n      this.count = this.readUint53()\n      this.lastValue = !this.lastValue\n      if (this.count === 0 && !this.firstRun) {\n        throw new RangeError('Zero-length runs are not allowed')\n      }\n      this.firstRun = false\n    }\n    this.count -= 1\n    return this.lastValue\n  }\n\n  /**\n   * Discards the next `numSkip` values in the sequence.\n   */\n  skipValues(numSkip) {\n    while (numSkip > 0 && !this.done) {\n      if (this.count === 0) {\n        this.count = this.readUint53()\n        this.lastValue = !this.lastValue\n        if (this.count === 0 && !this.firstRun) {\n          throw new RangeError('Zero-length runs are not allowed')\n        }\n        this.firstRun = false\n      }\n      if (this.count < numSkip) {\n        numSkip -= this.count\n        this.count = 0\n      } else {\n        this.count -= numSkip\n        numSkip = 0\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  stringToUtf8, utf8ToString, hexStringToBytes, bytesToHexString,\n  Encoder, Decoder, RLEEncoder, RLEDecoder, DeltaEncoder, DeltaDecoder, BooleanEncoder, BooleanDecoder\n}\n","const { init, clone, free, applyChanges, applyLocalChange, save, load, loadChanges, getPatch, getHeads, getAllChanges, getChanges, getChangesAdded, getChangeByHash, getMissingDeps } = require(\"./backend\")\nconst { receiveSyncMessage, generateSyncMessage, encodeSyncMessage, decodeSyncMessage, encodeSyncState, decodeSyncState, initSyncState } = require('./sync')\n\nmodule.exports = {\n  init, clone, free, applyChanges, applyLocalChange, save, load, loadChanges, getPatch,\n  getHeads, getAllChanges, getChanges, getChangesAdded, getChangeByHash, getMissingDeps,\n  receiveSyncMessage, generateSyncMessage, encodeSyncMessage, decodeSyncMessage, encodeSyncState, decodeSyncState, initSyncState\n}\n","const { parseOpId, copyObject } = require('../src/common')\nconst { COLUMN_TYPE, VALUE_TYPE, ACTIONS, OBJECT_TYPE, DOC_OPS_COLUMNS, CHANGE_COLUMNS, DOCUMENT_COLUMNS,\n  encoderByColumnId, decoderByColumnId, makeDecoders, decodeValue,\n  encodeChange, decodeChangeColumns, decodeChangeMeta, decodeChanges, decodeDocumentHeader, encodeDocumentHeader } = require('./columnar')\n\nconst MAX_BLOCK_SIZE = 600 // operations\nconst BLOOM_BITS_PER_ENTRY = 10, BLOOM_NUM_PROBES = 7 // 1% false positive rate\nconst BLOOM_FILTER_SIZE = Math.floor(BLOOM_BITS_PER_ENTRY * MAX_BLOCK_SIZE / 8) // bytes\n\nconst objActorIdx = 0, objCtrIdx = 1, keyActorIdx = 2, keyCtrIdx = 3, keyStrIdx = 4,\n  idActorIdx = 5, idCtrIdx = 6, insertIdx = 7, actionIdx = 8, valLenIdx = 9, valRawIdx = 10,\n  predNumIdx = 13, predActorIdx = 14, predCtrIdx = 15, succNumIdx = 13, succActorIdx = 14, succCtrIdx = 15\n\nconst PRED_COLUMN_IDS = CHANGE_COLUMNS\n  .filter(column => ['predNum', 'predActor', 'predCtr'].includes(column.columnName))\n  .map(column => column.columnId)\n\n/**\n * Updates `objectTree`, which is a tree of nested objects, so that afterwards\n * `objectTree[path[0]][path[1]][...] === value`. Only the root object is mutated, whereas any\n * nested objects are copied before updating. This means that once the root object has been\n * shallow-copied, this function can be used to update it without mutating the previous version.\n */\nfunction deepCopyUpdate(objectTree, path, value) {\n  if (path.length === 1) {\n    objectTree[path[0]] = value\n  } else {\n    let child = Object.assign({}, objectTree[path[0]])\n    deepCopyUpdate(child, path.slice(1), value)\n    objectTree[path[0]] = child\n  }\n}\n\n/**\n * Scans a block of document operations, encoded as columns `docCols`, to find the position at which\n * an operation (or sequence of operations) `ops` should be applied. `actorIds` is the array that\n * maps actor numbers to hexadecimal actor IDs. `resumeInsertion` is true if we're performing a list\n * insertion and we already found the reference element in a previous block, but we reached the end\n * of that previous block while scanning for the actual insertion position, and so we're continuing\n * the scan in a subsequent block.\n *\n * Returns an object with keys:\n * - `found`: false if we were scanning for a reference element in a list but couldn't find it;\n *    true otherwise.\n * - `skipCount`: the number of operations, counted from the start of the block, after which the\n *   new operations should be inserted or applied.\n * - `visibleCount`: if modifying a list object, the number of visible (i.e. non-deleted) list\n *   elements that precede the position where the new operations should be applied.\n */\nfunction seekWithinBlock(ops, docCols, actorIds, resumeInsertion) {\n  for (let col of docCols) col.decoder.reset()\n  const { objActor, objCtr, keyActor, keyCtr, keyStr, idActor, idCtr, insert } = ops\n  const [objActorD, objCtrD, /* keyActorD */, /* keyCtrD */, keyStrD, idActorD, idCtrD, insertD, actionD,\n    /* valLenD */, /* valRawD */, /* chldActorD */, /* chldCtrD */, succNumD] = docCols.map(col => col.decoder)\n  let skipCount = 0, visibleCount = 0, elemVisible = false, nextObjActor = null, nextObjCtr = null\n  let nextIdActor = null, nextIdCtr = null, nextKeyStr = null, nextInsert = null, nextSuccNum = 0\n\n  // Seek to the beginning of the object being updated\n  if (objCtr !== null && !resumeInsertion) {\n    while (!objCtrD.done || !objActorD.done || !actionD.done) {\n      nextObjCtr = objCtrD.readValue()\n      nextObjActor = actorIds[objActorD.readValue()]\n      actionD.skipValues(1)\n      if (nextObjCtr === null || !nextObjActor || nextObjCtr < objCtr ||\n          (nextObjCtr === objCtr && nextObjActor < objActor)) {\n        skipCount += 1\n      } else {\n        break\n      }\n    }\n  }\n  if ((nextObjCtr !== objCtr || nextObjActor !== objActor) && !resumeInsertion) {\n    return {found: true, skipCount, visibleCount}\n  }\n\n  // Seek to the appropriate key (if string key is used)\n  if (keyStr !== null) {\n    keyStrD.skipValues(skipCount)\n    while (!keyStrD.done) {\n      const objActorIndex = objActorD.readValue()\n      nextObjActor = objActorIndex === null ? null : actorIds[objActorIndex]\n      nextObjCtr = objCtrD.readValue()\n      nextKeyStr = keyStrD.readValue()\n      if (nextKeyStr !== null && nextKeyStr < keyStr &&\n          nextObjCtr === objCtr && nextObjActor === objActor) {\n        skipCount += 1\n      } else {\n        break\n      }\n    }\n    return {found: true, skipCount, visibleCount}\n  }\n\n  idCtrD.skipValues(skipCount)\n  idActorD.skipValues(skipCount)\n  insertD.skipValues(skipCount)\n  succNumD.skipValues(skipCount)\n  nextIdCtr = idCtrD.readValue()\n  nextIdActor = actorIds[idActorD.readValue()]\n  nextInsert = insertD.readValue()\n  nextSuccNum = succNumD.readValue()\n\n  // If we are inserting into a list, an opId key is used, and we need to seek to a position *after*\n  // the referenced operation. Moreover, we need to skip over any existing operations with a greater\n  // opId than the new insertion, for CRDT convergence on concurrent insertions in the same place.\n  if (insert) {\n    // If insertion is not at the head, search for the reference element\n    if (!resumeInsertion && keyCtr !== null && keyCtr > 0 && keyActor !== null) {\n      skipCount += 1\n      while (!idCtrD.done && !idActorD.done && (nextIdCtr !== keyCtr || nextIdActor !== keyActor)) {\n        if (nextInsert) elemVisible = false\n        if (nextSuccNum === 0 && !elemVisible) {\n          visibleCount += 1\n          elemVisible = true\n        }\n        nextIdCtr = idCtrD.readValue()\n        nextIdActor = actorIds[idActorD.readValue()]\n        nextObjCtr = objCtrD.readValue()\n        nextObjActor = actorIds[objActorD.readValue()]\n        nextInsert = insertD.readValue()\n        nextSuccNum = succNumD.readValue()\n        if (nextObjCtr === objCtr && nextObjActor === objActor) skipCount += 1; else break\n      }\n      if (nextObjCtr !== objCtr || nextObjActor !== objActor || nextIdCtr !== keyCtr ||\n          nextIdActor !== keyActor || !nextInsert) {\n        return {found: false, skipCount, visibleCount}\n      }\n      if (nextInsert) elemVisible = false\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1\n        elemVisible = true\n      }\n\n      // Set up the next* variables to the operation following the reference element\n      if (idCtrD.done || idActorD.done) return {found: true, skipCount, visibleCount}\n      nextIdCtr = idCtrD.readValue()\n      nextIdActor = actorIds[idActorD.readValue()]\n      nextObjCtr = objCtrD.readValue()\n      nextObjActor = actorIds[objActorD.readValue()]\n      nextInsert = insertD.readValue()\n      nextSuccNum = succNumD.readValue()\n    }\n\n    // Skip over any list elements with greater ID than the new one, and any non-insertions\n    while ((!nextInsert || nextIdCtr > idCtr || (nextIdCtr === idCtr && nextIdActor > idActor)) &&\n           nextObjCtr === objCtr && nextObjActor === objActor) {\n      skipCount += 1\n      if (nextInsert) elemVisible = false\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1\n        elemVisible = true\n      }\n      if (!idCtrD.done && !idActorD.done) {\n        nextIdCtr = idCtrD.readValue()\n        nextIdActor = actorIds[idActorD.readValue()]\n        nextObjCtr = objCtrD.readValue()\n        nextObjActor = actorIds[objActorD.readValue()]\n        nextInsert = insertD.readValue()\n        nextSuccNum = succNumD.readValue()\n      } else {\n        break\n      }\n    }\n\n  } else if (keyCtr !== null && keyCtr > 0 && keyActor !== null) {\n    // If we are updating an existing list element, seek to just before the referenced ID\n    while ((!nextInsert || nextIdCtr !== keyCtr || nextIdActor !== keyActor) &&\n           nextObjCtr === objCtr && nextObjActor === objActor) {\n      skipCount += 1\n      if (nextInsert) elemVisible = false\n      if (nextSuccNum === 0 && !elemVisible) {\n        visibleCount += 1\n        elemVisible = true\n      }\n      if (!idCtrD.done && !idActorD.done) {\n        nextIdCtr = idCtrD.readValue()\n        nextIdActor = actorIds[idActorD.readValue()]\n        nextObjCtr = objCtrD.readValue()\n        nextObjActor = actorIds[objActorD.readValue()]\n        nextInsert = insertD.readValue()\n        nextSuccNum = succNumD.readValue()\n      } else {\n        break\n      }\n    }\n    if (nextObjCtr !== objCtr || nextObjActor !== objActor || nextIdCtr !== keyCtr ||\n        nextIdActor !== keyActor || !nextInsert) {\n      return {found: false, skipCount, visibleCount}\n    }\n  }\n  return {found: true, skipCount, visibleCount}\n}\n\n/**\n * Returns the number of list elements that should be added to a list index when skipping over the\n * block with index `blockIndex` in the list object with object ID consisting of actor number\n * `objActorNum` and counter `objCtr`.\n */\nfunction visibleListElements(docState, blockIndex, objActorNum, objCtr) {\n  const thisBlock = docState.blocks[blockIndex]\n  const nextBlock = docState.blocks[blockIndex + 1]\n\n  if (thisBlock.lastObjectActor !== objActorNum || thisBlock.lastObjectCtr !== objCtr ||\n      thisBlock.numVisible === undefined) {\n    return 0\n\n    // If a list element is split across the block boundary, don't double-count it\n  } else if (thisBlock.lastVisibleActor === nextBlock.firstVisibleActor &&\n             thisBlock.lastVisibleActor !== undefined &&\n             thisBlock.lastVisibleCtr === nextBlock.firstVisibleCtr &&\n             thisBlock.lastVisibleCtr !== undefined) {\n    return thisBlock.numVisible - 1\n  } else {\n    return thisBlock.numVisible\n  }\n}\n\n/**\n * Scans the blocks of document operations to find the position where a new operation should be\n * inserted. Returns an object with keys:\n * - `blockIndex`: the index of the block into which we should insert the new operation\n * - `skipCount`: the number of operations, counted from the start of the block, after which the\n *   new operations should be inserted or merged.\n * - `visibleCount`: if modifying a list object, the number of visible (i.e. non-deleted) list\n *   elements that precede the position where the new operations should be applied.\n */\nfunction seekToOp(docState, ops) {\n  const { objActor, objActorNum, objCtr, keyActor, keyCtr, keyStr } = ops\n  let blockIndex = 0, totalVisible = 0\n\n  // Skip any blocks that contain only objects with lower objectIds\n  if (objCtr !== null) {\n    while (blockIndex < docState.blocks.length - 1) {\n      const blockActor = docState.blocks[blockIndex].lastObjectActor === undefined ? undefined\n        : docState.actorIds[docState.blocks[blockIndex].lastObjectActor]\n      const blockCtr = docState.blocks[blockIndex].lastObjectCtr\n      if (blockCtr === null || blockCtr < objCtr || (blockCtr === objCtr && blockActor < objActor)) {\n        blockIndex++\n      } else {\n        break\n      }\n    }\n  }\n\n  if (keyStr !== null) {\n    // String key is used. First skip any blocks that contain only lower keys\n    while (blockIndex < docState.blocks.length - 1) {\n      const { lastObjectActor, lastObjectCtr, lastKey } = docState.blocks[blockIndex]\n      if (objCtr === lastObjectCtr && objActorNum === lastObjectActor &&\n          lastKey !== undefined && lastKey < keyStr) blockIndex++; else break\n    }\n\n    // When we have a candidate block, decode it to find the exact insertion position\n    const {skipCount} = seekWithinBlock(ops, docState.blocks[blockIndex].columns, docState.actorIds, false)\n    return {blockIndex, skipCount, visibleCount: 0}\n\n  } else {\n    // List operation\n    const insertAtHead = keyCtr === null || keyCtr === 0 || keyActor === null\n    const keyActorNum = keyActor === null ? null : docState.actorIds.indexOf(keyActor)\n    let resumeInsertion = false\n\n    while (true) {\n      // Search for the reference element, skipping any blocks whose Bloom filter does not contain\n      // the reference element. We only do this if not inserting at the head (in which case there is\n      // no reference element), or if we already found the reference element in an earlier block (in\n      // which case we have resumeInsertion === true). The latter case arises with concurrent\n      // insertions at the same position, and so we have to scan beyond the reference element to\n      // find the actual insertion position, and that further scan crosses a block boundary.\n      if (!insertAtHead && !resumeInsertion) {\n        while (blockIndex < docState.blocks.length - 1 &&\n               docState.blocks[blockIndex].lastObjectActor === objActorNum &&\n               docState.blocks[blockIndex].lastObjectCtr === objCtr &&\n               !bloomFilterContains(docState.blocks[blockIndex].bloom, keyActorNum, keyCtr)) {\n          // If we reach the end of the list object without a Bloom filter hit, the reference element\n          // doesn't exist\n          if (docState.blocks[blockIndex].lastObjectCtr > objCtr) {\n            throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`)\n          }\n\n          // Add up number of visible list elements in any blocks we skip, for list index computation\n          totalVisible += visibleListElements(docState, blockIndex, objActorNum, objCtr)\n          blockIndex++\n        }\n      }\n\n      // We have a candidate block. Decode it to see whether it really contains the reference element\n      const {found, skipCount, visibleCount} = seekWithinBlock(ops,\n                                                               docState.blocks[blockIndex].columns,\n                                                               docState.actorIds,\n                                                               resumeInsertion)\n\n      if (blockIndex === docState.blocks.length - 1 ||\n          docState.blocks[blockIndex].lastObjectActor !== objActorNum ||\n          docState.blocks[blockIndex].lastObjectCtr !== objCtr) {\n        // Last block: if we haven't found the reference element by now, it's an error\n        if (found) {\n          return {blockIndex, skipCount, visibleCount: totalVisible + visibleCount}\n        } else {\n          throw new RangeError(`Reference element not found: ${keyCtr}@${keyActor}`)\n        }\n\n      } else if (found && skipCount < docState.blocks[blockIndex].numOps) {\n        // The insertion position lies within the current block\n        return {blockIndex, skipCount, visibleCount: totalVisible + visibleCount}\n      }\n\n      // Reference element not found and there are still blocks left ==> it was probably a false positive.\n      // Reference element found, but we skipped all the way to the end of the block ==> we need to\n      // continue scanning the next block to find the actual insertion position.\n      // Either way, go back round the loop again to skip blocks until the next Bloom filter hit.\n      resumeInsertion = found && ops.insert\n      totalVisible += visibleListElements(docState, blockIndex, objActorNum, objCtr)\n      blockIndex++\n    }\n  }\n}\n\n/**\n * Updates Bloom filter `bloom`, given as a Uint8Array, to contain the list element ID consisting of\n * counter `elemIdCtr` and actor number `elemIdActor`. We don't actually bother computing a hash\n * function, since those two integers serve perfectly fine as input. We turn the two integers into a\n * sequence of probe indexes using the triple hashing algorithm from the following paper:\n *\n * Peter C. Dillinger and Panagiotis Manolios. Bloom Filters in Probabilistic Verification.\n * 5th International Conference on Formal Methods in Computer-Aided Design (FMCAD), November 2004.\n * http://www.ccis.northeastern.edu/home/pete/pub/bloom-filters-verification.pdf\n */\nfunction bloomFilterAdd(bloom, elemIdActor, elemIdCtr) {\n  let modulo = 8 * bloom.byteLength, x = elemIdCtr % modulo, y = elemIdActor % modulo\n\n  // Use one step of FNV-1a to compute a third value from the two inputs.\n  // Taken from http://www.isthe.com/chongo/tech/comp/fnv/index.html\n  // The prime is just over 2^24, so elemIdCtr can be up to about 2^29 = 500 million before the\n  // result of the multiplication exceeds 2^53. And even if it does exceed 2^53 and loses precision,\n  // that shouldn't be a problem as it should still be deterministic, and the Bloom filter\n  // computation only needs to be internally consistent within this library.\n  let z = ((elemIdCtr ^ elemIdActor) * 16777619 >>> 0) % modulo\n\n  for (let i = 0; i < BLOOM_NUM_PROBES; i++) {\n    bloom[x >>> 3] |= 1 << (x & 7)\n    x = (x + y) % modulo\n    y = (y + z) % modulo\n  }\n}\n\n/**\n * Returns true if the list element ID consisting of counter `elemIdCtr` and actor number\n * `elemIdActor` is likely to be contained in the Bloom filter `bloom`.\n */\nfunction bloomFilterContains(bloom, elemIdActor, elemIdCtr) {\n  let modulo = 8 * bloom.byteLength, x = elemIdCtr % modulo, y = elemIdActor % modulo\n  let z = ((elemIdCtr ^ elemIdActor) * 16777619 >>> 0) % modulo\n\n  // See comments in the bloomFilterAdd function for an explanation\n  for (let i = 0; i < BLOOM_NUM_PROBES; i++) {\n    if ((bloom[x >>> 3] & (1 << (x & 7))) === 0) {\n      return false\n    }\n    x = (x + y) % modulo\n    y = (y + z) % modulo\n  }\n  return true\n}\n\n/**\n * Reads the relevant columns of a block of operations and updates that block to contain the\n * metadata we need to efficiently figure out where to insert new operations.\n */\nfunction updateBlockMetadata(block) {\n  block.bloom = new Uint8Array(BLOOM_FILTER_SIZE)\n  block.numOps = 0\n  block.lastKey = undefined\n  block.numVisible = undefined\n  block.lastObjectActor = undefined\n  block.lastObjectCtr = undefined\n  block.firstVisibleActor = undefined\n  block.firstVisibleCtr = undefined\n  block.lastVisibleActor = undefined\n  block.lastVisibleCtr = undefined\n\n  for (let col of block.columns) col.decoder.reset()\n  const [objActorD, objCtrD, keyActorD, keyCtrD, keyStrD, idActorD, idCtrD, insertD, /* actionD */,\n    /* valLenD */, /* valRawD */, /* chldActorD */, /* chldCtrD */, succNumD] = block.columns.map(col => col.decoder)\n\n  while (!idCtrD.done) {\n    block.numOps += 1\n    const objActor = objActorD.readValue(), objCtr = objCtrD.readValue()\n    const keyActor = keyActorD.readValue(), keyCtr = keyCtrD.readValue(), keyStr = keyStrD.readValue()\n    const idActor = idActorD.readValue(), idCtr = idCtrD.readValue()\n    const insert = insertD.readValue(), succNum = succNumD.readValue()\n\n    if (block.lastObjectActor !== objActor || block.lastObjectCtr !== objCtr) {\n      block.numVisible = 0\n      block.lastObjectActor = objActor\n      block.lastObjectCtr = objCtr\n    }\n\n    if (keyStr !== null) {\n      // Map key: for each object, record the highest key contained in the block\n      block.lastKey = keyStr\n    } else if (insert || keyCtr !== null) {\n      // List element\n      block.lastKey = undefined\n      const elemIdActor = insert ? idActor : keyActor\n      const elemIdCtr = insert ? idCtr : keyCtr\n      bloomFilterAdd(block.bloom, elemIdActor, elemIdCtr)\n\n      // If the list element is visible, update the block metadata accordingly\n      if (succNum === 0) {\n        if (block.firstVisibleActor === undefined) block.firstVisibleActor = elemIdActor\n        if (block.firstVisibleCtr === undefined) block.firstVisibleCtr = elemIdCtr\n        if (block.lastVisibleActor !== elemIdActor || block.lastVisibleCtr !== elemIdCtr) {\n          block.numVisible += 1\n          block.lastVisibleActor = elemIdActor\n          block.lastVisibleCtr = elemIdCtr\n        }\n      }\n    }\n  }\n}\n\n/**\n * Updates a block's metadata based on an operation being added to a block.\n */\nfunction addBlockOperation(block, op, actorIds, isChangeOp) {\n  if (op[keyStrIdx] !== null) {\n    // TODO this comparison should use UTF-8 encoding, not JavaScript's UTF-16\n    if (block.lastObjectCtr === op[objCtrIdx] && block.lastObjectActor === op[objActorIdx] &&\n        (block.lastKey === undefined || block.lastKey < op[keyStrIdx])) {\n      block.lastKey = op[keyStrIdx]\n    }\n  } else {\n    // List element\n    const elemIdActor = op[insertIdx] ? op[idActorIdx] : op[keyActorIdx]\n    const elemIdCtr = op[insertIdx] ? op[idCtrIdx] : op[keyCtrIdx]\n    bloomFilterAdd(block.bloom, elemIdActor, elemIdCtr)\n\n    // Set lastVisible on the assumption that this is the last op in the block; if there are further\n    // ops after this one in the block, lastVisible will be overwritten again later.\n    if (op[succNumIdx] === 0 || isChangeOp) {\n      if (block.firstVisibleActor === undefined) block.firstVisibleActor = elemIdActor\n      if (block.firstVisibleCtr === undefined) block.firstVisibleCtr = elemIdCtr\n      block.lastVisibleActor = elemIdActor\n      block.lastVisibleCtr = elemIdCtr\n    }\n  }\n\n  // Keep track of the largest objectId contained within a block\n  if (block.lastObjectCtr === undefined ||\n      op[objActorIdx] !== null && op[objCtrIdx] !== null &&\n      (block.lastObjectCtr === null || block.lastObjectCtr < op[objCtrIdx] ||\n       (block.lastObjectCtr === op[objCtrIdx] && actorIds[block.lastObjectActor] < actorIds[op[objActorIdx]]))) {\n    block.lastObjectActor = op[objActorIdx]\n    block.lastObjectCtr = op[objCtrIdx]\n    block.lastKey = (op[keyStrIdx] !== null ? op[keyStrIdx] : undefined)\n    block.numVisible = 0\n  }\n}\n\n/**\n * Takes a block containing too many operations, and splits it into a sequence of adjacent blocks of\n * roughly equal size.\n */\nfunction splitBlock(block) {\n  for (let col of block.columns) col.decoder.reset()\n\n  // Make each of the resulting blocks between 50% and 80% full (leaving a bit of space in each\n  // block so that it doesn't get split again right away the next time an operation is added).\n  // The upper bound cannot be lower than 75% since otherwise we would end up with a block less than\n  // 50% full when going from two to three blocks.\n  const numBlocks = Math.ceil(block.numOps / (0.8 * MAX_BLOCK_SIZE))\n  let blocks = [], opsSoFar = 0\n\n  for (let i = 1; i <= numBlocks; i++) {\n    const opsToCopy = Math.ceil(i * block.numOps / numBlocks) - opsSoFar\n    const encoders = block.columns.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n    copyColumns(encoders, block.columns, opsToCopy)\n    const decoders = encoders.map(col => {\n      const decoder = decoderByColumnId(col.columnId, col.encoder.buffer)\n      return {columnId: col.columnId, decoder}\n    })\n\n    const newBlock = {columns: decoders}\n    updateBlockMetadata(newBlock)\n    blocks.push(newBlock)\n    opsSoFar += opsToCopy\n  }\n\n  return blocks\n}\n\n/**\n * Takes an array of blocks and concatenates the corresponding columns across all of the blocks.\n */\nfunction concatBlocks(blocks) {\n  const encoders = blocks[0].columns.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n\n  for (let block of blocks) {\n    for (let col of block.columns) col.decoder.reset()\n    copyColumns(encoders, block.columns, block.numOps)\n  }\n  return encoders\n}\n\n/**\n * Copies `count` rows from the set of input columns `inCols` to the set of output columns\n * `outCols`. The input columns are given as an array of `{columnId, decoder}` objects, and the\n * output columns are given as an array of `{columnId, encoder}` objects. Both are sorted in\n * increasing order of columnId. If there is no matching input column for a given output column, it\n * is filled in with `count` blank values (according to the column type).\n */\nfunction copyColumns(outCols, inCols, count) {\n  if (count === 0) return\n  let inIndex = 0, lastGroup = -1, lastCardinality = 0, valueColumn = -1, valueBytes = 0\n  for (let outCol of outCols) {\n    while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++\n    let inCol = null\n    if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId &&\n        inCols[inIndex].decoder.buf.byteLength > 0) {\n      inCol = inCols[inIndex].decoder\n    }\n    const colCount = (outCol.columnId >> 4 === lastGroup) ? lastCardinality : count\n\n    if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = outCol.columnId >> 4\n      if (inCol) {\n        lastCardinality = outCol.encoder.copyFrom(inCol, {count, sumValues: true}).sum\n      } else {\n        outCol.encoder.appendValue(0, count)\n        lastCardinality = 0\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n      if (inCol) {\n        if (inIndex + 1 === inCols.length || inCols[inIndex + 1].columnId !== outCol.columnId + 1) {\n          throw new RangeError('VALUE_LEN column without accompanying VALUE_RAW column')\n        }\n        valueColumn = outCol.columnId + 1\n        valueBytes = outCol.encoder.copyFrom(inCol, {count: colCount, sumValues: true, sumShift: 4}).sum\n      } else {\n        outCol.encoder.appendValue(null, colCount)\n        valueColumn = outCol.columnId + 1\n        valueBytes = 0\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n      if (outCol.columnId !== valueColumn) {\n        throw new RangeError('VALUE_RAW column without accompanying VALUE_LEN column')\n      }\n      if (valueBytes > 0) {\n        outCol.encoder.appendRawBytes(inCol.readRawBytes(valueBytes))\n      }\n    } else { // ACTOR_ID, INT_RLE, INT_DELTA, BOOLEAN, or STRING_RLE\n      if (inCol) {\n        outCol.encoder.copyFrom(inCol, {count: colCount})\n      } else {\n        const blankValue = (outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN) ? false : null\n        outCol.encoder.appendValue(blankValue, colCount)\n      }\n    }\n  }\n}\n\n/**\n * Parses one operation from a set of columns. The argument `columns` contains a list of objects\n * with `columnId` and `decoder` properties. Returns an array in which the i'th element is the\n * value read from the i'th column in `columns`. Does not interpret datatypes; the only\n * interpretation of values is that if `actorTable` is given, a value `v` in a column of type\n * ACTOR_ID is replaced with `actorTable[v]`.\n */\nfunction readOperation(columns, actorTable) {\n  let operation = [], colValue, lastGroup = -1, lastCardinality = 0, valueColumn = -1, valueBytes = 0\n  for (let col of columns) {\n    if (col.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n      if (col.columnId !== valueColumn) throw new RangeError('unexpected VALUE_RAW column')\n      colValue = col.decoder.readRawBytes(valueBytes)\n    } else if (col.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = col.columnId >> 4\n      lastCardinality = col.decoder.readValue() || 0\n      colValue = lastCardinality\n    } else if (col.columnId >> 4 === lastGroup) {\n      colValue = []\n      if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n        valueColumn = col.columnId + 1\n        valueBytes = 0\n      }\n      for (let i = 0; i < lastCardinality; i++) {\n        let value = col.decoder.readValue()\n        if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof value === 'number') {\n          value = actorTable[value]\n        }\n        if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n          valueBytes += colValue >>> 4\n        }\n        colValue.push(value)\n      }\n    } else {\n      colValue = col.decoder.readValue()\n      if (col.columnId % 8 === COLUMN_TYPE.ACTOR_ID && actorTable && typeof colValue === 'number') {\n        colValue = actorTable[colValue]\n      }\n      if (col.columnId % 8 === COLUMN_TYPE.VALUE_LEN) {\n        valueColumn = col.columnId + 1\n        valueBytes = colValue >>> 4\n      }\n    }\n\n    operation.push(colValue)\n  }\n  return operation\n}\n\n/**\n * Appends `operation`, in the form returned by `readOperation()`, to the columns in `outCols`. The\n * argument `inCols` provides metadata about the types of columns in `operation`; the value\n * `operation[i]` comes from the column `inCols[i]`.\n */\nfunction appendOperation(outCols, inCols, operation) {\n  let inIndex = 0, lastGroup = -1, lastCardinality = 0\n  for (let outCol of outCols) {\n    while (inIndex < inCols.length && inCols[inIndex].columnId < outCol.columnId) inIndex++\n\n    if (inIndex < inCols.length && inCols[inIndex].columnId === outCol.columnId) {\n      const colValue = operation[inIndex]\n      if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n        lastGroup = outCol.columnId >> 4\n        lastCardinality = colValue\n        outCol.encoder.appendValue(colValue)\n      } else if (outCol.columnId >> 4 === lastGroup) {\n        if (!Array.isArray(colValue) || colValue.length !== lastCardinality) {\n          throw new RangeError('bad group value')\n        }\n        for (let v of colValue) outCol.encoder.appendValue(v)\n      } else if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_RAW) {\n        if (colValue) outCol.encoder.appendRawBytes(colValue)\n      } else {\n        outCol.encoder.appendValue(colValue)\n      }\n    } else if (outCol.columnId % 8 === COLUMN_TYPE.GROUP_CARD) {\n      lastGroup = outCol.columnId >> 4\n      lastCardinality = 0\n      outCol.encoder.appendValue(0)\n    } else if (outCol.columnId % 8 !== COLUMN_TYPE.VALUE_RAW) {\n      const count = (outCol.columnId >> 4 === lastGroup) ? lastCardinality : 1\n      let blankValue = null\n      if (outCol.columnId % 8 === COLUMN_TYPE.BOOLEAN) blankValue = false\n      if (outCol.columnId % 8 === COLUMN_TYPE.VALUE_LEN) blankValue = 0\n      outCol.encoder.appendValue(blankValue, count)\n    }\n  }\n}\n\n/**\n * Parses the next operation from block `blockIndex` of the document. Returns an object of the form\n * `{docOp, blockIndex}` where `docOp` is an operation in the form returned by `readOperation()`,\n * and `blockIndex` is the block number to use on the next call (it moves on to the next block when\n * we reach the end of the current block). `docOp` is null if there are no more operations.\n */\nfunction readNextDocOp(docState, blockIndex) {\n  let block = docState.blocks[blockIndex]\n  if (!block.columns[actionIdx].decoder.done) {\n    return {docOp: readOperation(block.columns), blockIndex}\n  } else if (blockIndex === docState.blocks.length - 1) {\n    return {docOp: null, blockIndex}\n  } else {\n    blockIndex += 1\n    block = docState.blocks[blockIndex]\n    for (let col of block.columns) col.decoder.reset()\n    return {docOp: readOperation(block.columns), blockIndex}\n  }\n}\n\n/**\n * Parses the next operation from a sequence of changes. `changeState` serves as the state of this\n * pseudo-iterator, and it is mutated to reflect the new operation. In particular,\n * `changeState.nextOp` is set to the operation that was read, and `changeState.done` is set to true\n * when we have finished reading the last operation in the last change.\n */\nfunction readNextChangeOp(docState, changeState) {\n  // If we've finished reading one change, move to the next change that contains at least one op\n  while (changeState.changeIndex < changeState.changes.length - 1 &&\n         (!changeState.columns || changeState.columns[actionIdx].decoder.done)) {\n    changeState.changeIndex += 1\n    const change = changeState.changes[changeState.changeIndex]\n    changeState.columns = makeDecoders(change.columns, CHANGE_COLUMNS)\n    changeState.opCtr = change.startOp\n\n    // If it's an empty change (no ops), set its maxOp here since it won't be set below\n    if (changeState.columns[actionIdx].decoder.done) {\n      change.maxOp = change.startOp - 1\n    }\n\n    // Update docState based on the information in the change\n    updateBlockColumns(docState, changeState.columns)\n    const {actorIds, actorTable} = getActorTable(docState.actorIds, change)\n    docState.actorIds = actorIds\n    changeState.actorTable = actorTable\n    changeState.actorIndex = docState.actorIds.indexOf(change.actorIds[0])\n  }\n\n  // Reached the end of the last change?\n  if (changeState.columns[actionIdx].decoder.done) {\n    changeState.done = true\n    changeState.nextOp = null\n    return\n  }\n\n  changeState.nextOp = readOperation(changeState.columns, changeState.actorTable)\n  changeState.nextOp[idActorIdx] = changeState.actorIndex\n  changeState.nextOp[idCtrIdx] = changeState.opCtr\n  changeState.changes[changeState.changeIndex].maxOp = changeState.opCtr\n  if (changeState.opCtr > docState.maxOp) docState.maxOp = changeState.opCtr\n  changeState.opCtr += 1\n\n  const op = changeState.nextOp\n  if ((op[objCtrIdx] === null && op[objActorIdx] !== null) ||\n      (op[objCtrIdx] !== null && op[objActorIdx] === null)) {\n    throw new RangeError(`Mismatched object reference: (${op[objCtrIdx]}, ${op[objActorIdx]})`)\n  }\n  if ((op[keyCtrIdx] === null && op[keyActorIdx] !== null) ||\n      (op[keyCtrIdx] === 0    && op[keyActorIdx] !== null) ||\n      (op[keyCtrIdx] >   0    && op[keyActorIdx] === null)) {\n    throw new RangeError(`Mismatched operation key: (${op[keyCtrIdx]}, ${op[keyActorIdx]})`)\n  }\n}\n\nfunction emptyObjectPatch(objectId, type) {\n  if (type === 'list' || type === 'text') {\n    return {objectId, type, edits: []}\n  } else {\n    return {objectId, type, props: {}}\n  }\n}\n\n/**\n * Returns true if the two given operation IDs have the same actor ID, and the counter of `id2` is\n * exactly `delta` greater than the counter of `id1`.\n */\nfunction opIdDelta(id1, id2, delta = 1) {\n  const parsed1 = parseOpId(id1), parsed2 = parseOpId(id2)\n  return parsed1.actorId === parsed2.actorId && parsed1.counter + delta === parsed2.counter\n}\n\n/**\n * Appends a list edit operation (insert, update, remove) to an array of existing operations. If the\n * last existing operation can be extended (as a multi-op), we do that.\n */\nfunction appendEdit(existingEdits, nextEdit) {\n  if (existingEdits.length === 0) {\n    existingEdits.push(nextEdit)\n    return\n  }\n\n  let lastEdit = existingEdits[existingEdits.length - 1]\n  if (lastEdit.action === 'insert' && nextEdit.action === 'insert' &&\n      lastEdit.index === nextEdit.index - 1 &&\n      lastEdit.value.type === 'value' && nextEdit.value.type === 'value' &&\n      lastEdit.elemId === lastEdit.opId && nextEdit.elemId === nextEdit.opId &&\n      opIdDelta(lastEdit.elemId, nextEdit.elemId, 1) &&\n      lastEdit.value.datatype === nextEdit.value.datatype &&\n      typeof lastEdit.value.value === typeof nextEdit.value.value) {\n    lastEdit.action = 'multi-insert'\n    if (nextEdit.value.datatype) lastEdit.datatype = nextEdit.value.datatype\n    lastEdit.values = [lastEdit.value.value, nextEdit.value.value]\n    delete lastEdit.value\n    delete lastEdit.opId\n\n  } else if (lastEdit.action === 'multi-insert' && nextEdit.action === 'insert' &&\n             lastEdit.index + lastEdit.values.length === nextEdit.index &&\n             nextEdit.value.type === 'value' && nextEdit.elemId === nextEdit.opId &&\n             opIdDelta(lastEdit.elemId, nextEdit.elemId, lastEdit.values.length) &&\n             lastEdit.datatype === nextEdit.value.datatype &&\n             typeof lastEdit.values[0] === typeof nextEdit.value.value) {\n    lastEdit.values.push(nextEdit.value.value)\n\n  } else if (lastEdit.action === 'remove' && nextEdit.action === 'remove' &&\n             lastEdit.index === nextEdit.index) {\n    lastEdit.count += nextEdit.count\n\n  } else {\n    existingEdits.push(nextEdit)\n  }\n}\n\n/**\n * `edits` is an array of (SingleInsertEdit | MultiInsertEdit | UpdateEdit | RemoveEdit) list edits\n * for a patch. This function appends an UpdateEdit to this array. A conflict is represented by\n * having several consecutive edits with the same index, and this can be realised by calling\n * `appendUpdate` several times for the same list element. On the first such call, `firstUpdate`\n * must be true.\n *\n * It is possible that coincidentally the previous edit (potentially arising from a different\n * change) is for the same index. If this is the case, to avoid accidentally treating consecutive\n * updates for the same index as a conflict, we remove the previous edit for the same index. This is\n * safe because the previous edit is overwritten by the new edit being appended, and we know that\n * it's for the same list elements because there are no intervening insertions/deletions that could\n * have changed the indexes.\n */\nfunction appendUpdate(edits, index, elemId, opId, value, firstUpdate) {\n  let insert = false\n  if (firstUpdate) {\n    // Pop all edits for the same index off the end of the edits array. This sequence may begin with\n    // either an insert or an update. If it's an insert, we remember that fact, and use it below.\n    while (!insert && edits.length > 0) {\n      const lastEdit = edits[edits.length - 1]\n      if ((lastEdit.action === 'insert' || lastEdit.action === 'update') && lastEdit.index === index) {\n        edits.pop()\n        insert = (lastEdit.action === 'insert')\n      } else if (lastEdit.action === 'multi-insert' && lastEdit.index + lastEdit.values.length - 1 === index) {\n        lastEdit.values.pop()\n        insert = true\n      } else {\n        break\n      }\n    }\n  }\n\n  // If we popped an insert edit off the edits array, we need to turn the new update into an insert\n  // in order to ensure the list element still gets inserted (just with a new value).\n  if (insert) {\n    appendEdit(edits, {action: 'insert', index, elemId, opId, value})\n  } else {\n    appendEdit(edits, {action: 'update', index, opId, value})\n  }\n}\n\n/**\n * `edits` is an array of (SingleInsertEdit | MultiInsertEdit | UpdateEdit | RemoveEdit) list edits\n * for a patch. We assume that there is a suffix of this array that consists of an insertion at\n * position `index`, followed by zero or more UpdateEdits at the same index. This function rewrites\n * that suffix to be all updates instead. This is needed because sometimes when generating a patch\n * we think we are performing a list insertion, but then it later turns out that there was already\n * an existing value at that list element, and so we actually need to do an update, not an insert.\n *\n * If the suffix is preceded by one or more updates at the same index, those earlier updates are\n * removed by `appendUpdate()` to ensure we don't inadvertently treat them as part of the same\n * conflict.\n */\nfunction convertInsertToUpdate(edits, index, elemId) {\n  let updates = []\n  while (edits.length > 0) {\n    let lastEdit = edits[edits.length - 1]\n    if (lastEdit.action === 'insert') {\n      if (lastEdit.index !== index) throw new RangeError('last edit has unexpected index')\n      updates.unshift(edits.pop())\n      break\n    } else if (lastEdit.action === 'update') {\n      if (lastEdit.index !== index) throw new RangeError('last edit has unexpected index')\n      updates.unshift(edits.pop())\n    } else {\n      // It's impossible to encounter a remove edit here because the state machine in\n      // updatePatchProperty() ensures that a property can have either an insert or a remove edit,\n      // but not both. It's impossible to encounter a multi-insert here because multi-inserts always\n      // have equal elemId and opId (i.e. they can only be used for the operation that first inserts\n      // an element, but not for any subsequent assignments to that list element); moreover,\n      // convertInsertToUpdate is only called if an insert action is followed by a non-overwritten\n      // document op. The fact that there is a non-overwritten document op after another op on the\n      // same list element implies that the original insertion op for that list element must be\n      // overwritten, and thus the original insertion op cannot have given rise to a multi-insert.\n      throw new RangeError('last edit has unexpected action')\n    }\n  }\n\n  // Now take the edits we popped off and push them back onto the list again\n  let firstUpdate = true\n  for (let update of updates) {\n    appendUpdate(edits, index, elemId, update.opId, update.value, firstUpdate)\n    firstUpdate = false\n  }\n}\n\n/**\n * Updates `patches` to reflect the operation `op` within the document with state `docState`.\n * Can be called multiple times if there are multiple operations for the same property (e.g. due\n * to a conflict). `propState` is an object that carries over state between such successive\n * invocations for the same property. If the current object is a list, `listIndex` is the index\n * into that list (counting only visible elements). If the operation `op` was already previously\n * in the document, `oldSuccNum` is the value of `op[succNumIdx]` before the current change was\n * applied (allowing us to determine whether this operation was overwritten or deleted in the\n * current change). `oldSuccNum` must be undefined if the operation came from the current change.\n * If we are creating an incremental patch as a result of applying one or more changes, `newBlock`\n * is the block to which the operations are getting written; we will update the metadata on this\n * block. `newBlock` should be null if we are creating a patch for the whole document.\n */\nfunction updatePatchProperty(patches, newBlock, objectId, op, docState, propState, listIndex, oldSuccNum) {\n  const isWholeDoc = !newBlock\n  const type = op[actionIdx] < ACTIONS.length ? OBJECT_TYPE[ACTIONS[op[actionIdx]]] : null\n  const opId = `${op[idCtrIdx]}@${docState.actorIds[op[idActorIdx]]}`\n  const elemIdActor = op[insertIdx] ? op[idActorIdx] : op[keyActorIdx]\n  const elemIdCtr = op[insertIdx] ? op[idCtrIdx] : op[keyCtrIdx]\n  const elemId = op[keyStrIdx] ? op[keyStrIdx] : `${elemIdCtr}@${docState.actorIds[elemIdActor]}`\n\n  // When the change contains a new make* operation (i.e. with an even-numbered action), record the\n  // new parent-child relationship in objectMeta. TODO: also handle link/move operations.\n  if (op[actionIdx] % 2 === 0 && !docState.objectMeta[opId]) {\n    docState.objectMeta[opId] = {parentObj: objectId, parentKey: elemId, opId, type, children: {}}\n    deepCopyUpdate(docState.objectMeta, [objectId, 'children', elemId, opId], {objectId: opId, type, props: {}})\n  }\n\n  // firstOp is true if the current operation is the first of a sequence of ops for the same key\n  const firstOp = !propState[elemId]\n  if (!propState[elemId]) propState[elemId] = {visibleOps: [], hasChild: false}\n\n  // An operation is overwritten if it is a document operation that has at least one successor\n  const isOverwritten = (oldSuccNum !== undefined && op[succNumIdx] > 0)\n\n  // Record all visible values for the property, and whether it has any child object\n  if (!isOverwritten) {\n    propState[elemId].visibleOps.push(op)\n    propState[elemId].hasChild = propState[elemId].hasChild || (op[actionIdx] % 2) === 0 // even-numbered action == make* operation\n  }\n\n  // If one or more of the values of the property is a child object, we update objectMeta to store\n  // all of the visible values of the property (even the non-child-object values). Then, when we\n  // subsequently process an update within that child object, we can construct the patch to\n  // contain the conflicting values.\n  const prevChildren = docState.objectMeta[objectId].children[elemId]\n  if (propState[elemId].hasChild || (prevChildren && Object.keys(prevChildren).length > 0)) {\n    let values = {}\n    for (let visible of propState[elemId].visibleOps) {\n      const opId = `${visible[idCtrIdx]}@${docState.actorIds[visible[idActorIdx]]}`\n      if (ACTIONS[visible[actionIdx]] === 'set') {\n        values[opId] = Object.assign({type: 'value'}, decodeValue(visible[valLenIdx], visible[valRawIdx]))\n      } else if (visible[actionIdx] % 2 === 0) {\n        const objType = visible[actionIdx] < ACTIONS.length ? OBJECT_TYPE[ACTIONS[visible[actionIdx]]] : null\n        values[opId] = emptyObjectPatch(opId, objType)\n      }\n    }\n\n    // Copy so that objectMeta is not modified if an exception is thrown while applying change\n    deepCopyUpdate(docState.objectMeta, [objectId, 'children', elemId], values)\n  }\n\n  let patchKey, patchValue\n\n  // For counters, increment operations are succs to the set operation that created the counter,\n  // but in this case we want to add the values rather than overwriting them.\n  if (isOverwritten && ACTIONS[op[actionIdx]] === 'set' && (op[valLenIdx] & 0x0f) === VALUE_TYPE.COUNTER) {\n    // This is the initial set operation that creates a counter. Initialise the counter state\n    // to contain all successors of the set operation. Only if we later find that each of these\n    // successor operations is an increment, we make the counter visible in the patch.\n    if (!propState[elemId]) propState[elemId] = {visibleOps: [], hasChild: false}\n    if (!propState[elemId].counterStates) propState[elemId].counterStates = {}\n    let counterStates = propState[elemId].counterStates\n    let counterState = {opId, value: decodeValue(op[valLenIdx], op[valRawIdx]).value, succs: {}}\n\n    for (let i = 0; i < op[succNumIdx]; i++) {\n      const succOp = `${op[succCtrIdx][i]}@${docState.actorIds[op[succActorIdx][i]]}`\n      counterStates[succOp] = counterState\n      counterState.succs[succOp] = true\n    }\n\n  } else if (ACTIONS[op[actionIdx]] === 'inc') {\n    // Incrementing a previously created counter.\n    if (!propState[elemId] || !propState[elemId].counterStates || !propState[elemId].counterStates[opId]) {\n      throw new RangeError(`increment operation ${opId} for unknown counter`)\n    }\n    let counterState = propState[elemId].counterStates[opId]\n    counterState.value += decodeValue(op[valLenIdx], op[valRawIdx]).value\n    delete counterState.succs[opId]\n\n    if (Object.keys(counterState.succs).length === 0) {\n      patchKey = counterState.opId\n      patchValue = {type: 'value', datatype: 'counter', value: counterState.value}\n      // TODO if the counter is in a list element, we need to add a 'remove' action when deleted\n    }\n\n  } else if (!isOverwritten) {\n    // Add the value to the patch if it is not overwritten (i.e. if it has no succs).\n    if (ACTIONS[op[actionIdx]] === 'set') {\n      patchKey = opId\n      patchValue = Object.assign({type: 'value'}, decodeValue(op[valLenIdx], op[valRawIdx]))\n    } else if (op[actionIdx] % 2 === 0) { // even-numbered action == make* operation\n      if (!patches[opId]) patches[opId] = emptyObjectPatch(opId, type)\n      patchKey = opId\n      patchValue = patches[opId]\n    }\n  }\n\n  if (!patches[objectId]) patches[objectId] = emptyObjectPatch(objectId, docState.objectMeta[objectId].type)\n  const patch = patches[objectId]\n\n  // Updating a list or text object (with elemId key)\n  if (op[keyStrIdx] === null) {\n    // If we come across any document op that was previously non-overwritten/non-deleted, that\n    // means the current list element already had a value before this change was applied, and\n    // therefore the current element cannot be an insert. If we already registered an insert, we\n    // have to convert it into an update.\n    if (oldSuccNum === 0 && !isWholeDoc && propState[elemId].action === 'insert') {\n      propState[elemId].action = 'update'\n      convertInsertToUpdate(patch.edits, listIndex, elemId)\n      if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n        newBlock.numVisible -= 1\n      }\n    }\n\n    if (patchValue) {\n      // If the op has a non-overwritten value and it came from the change, it's an insert.\n      // (It's not necessarily the case that op[insertIdx] is true: if a list element is concurrently\n      // deleted and updated, the node that first processes the deletion and then the update will\n      // observe the update as a re-insertion of the deleted list element.)\n      if (!propState[elemId].action && (oldSuccNum === undefined || isWholeDoc)) {\n        propState[elemId].action = 'insert'\n        appendEdit(patch.edits, {action: 'insert', index: listIndex, elemId, opId: patchKey, value: patchValue})\n        if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n          newBlock.numVisible += 1\n        }\n\n      // If the property has a value and it's not an insert, then it must be an update.\n      // We might have previously registered it as a remove, in which case we convert it to update.\n      } else if (propState[elemId].action === 'remove') {\n        let lastEdit = patch.edits[patch.edits.length - 1]\n        if (lastEdit.action !== 'remove') throw new RangeError('last edit has unexpected type')\n        if (lastEdit.count > 1) lastEdit.count -= 1; else patch.edits.pop()\n        propState[elemId].action = 'update'\n        appendUpdate(patch.edits, listIndex, elemId, patchKey, patchValue, true)\n        if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n          newBlock.numVisible += 1\n        }\n\n      } else {\n        // A 'normal' update\n        appendUpdate(patch.edits, listIndex, elemId, patchKey, patchValue, !propState[elemId].action)\n        if (!propState[elemId].action) propState[elemId].action = 'update'\n      }\n\n    } else if (oldSuccNum === 0 && !propState[elemId].action) {\n      // If the property used to have a non-overwritten/non-deleted value, but no longer, it's a remove\n      propState[elemId].action = 'remove'\n      appendEdit(patch.edits, {action: 'remove', index: listIndex, count: 1})\n      if (newBlock && newBlock.lastObjectActor === op[objActorIdx] && newBlock.lastObjectCtr === op[objCtrIdx]) {\n        newBlock.numVisible -= 1\n      }\n    }\n\n  } else if (patchValue || !isWholeDoc) {\n    // Updating a map or table (with string key)\n    if (firstOp || !patch.props[op[keyStrIdx]]) patch.props[op[keyStrIdx]] = {}\n    if (patchValue) patch.props[op[keyStrIdx]][patchKey] = patchValue\n  }\n}\n\n/**\n * Applies operations (from one or more changes) to the document by merging the sequence of change\n * ops into the sequence of document ops. The two inputs are `changeState` and `docState`\n * respectively. Assumes that the decoders of both sets of columns are at the position where we want\n * to start merging. `patches` is mutated to reflect the effect of the change operations. `ops` is\n * the operation sequence to apply (as decoded by `groupRelatedOps()`). `docState` is as\n * documented in `applyOps()`. If the operations are updating a list or text object, `listIndex`\n * is the number of visible elements that precede the position at which we start merging.\n * `blockIndex` is the document block number from which we are currently reading.\n */\nfunction mergeDocChangeOps(patches, newBlock, outCols, changeState, docState, listIndex, blockIndex) {\n  const firstOp = changeState.nextOp, insert = firstOp[insertIdx]\n  const objActor = firstOp[objActorIdx], objCtr = firstOp[objCtrIdx]\n  const objectId = objActor === null ? '_root' : `${objCtr}@${docState.actorIds[objActor]}`\n  const idActorIndex = changeState.actorIndex, idActor = docState.actorIds[idActorIndex]\n  let foundListElem = false, elemVisible = false, propState = {}, docOp\n  ;({ docOp, blockIndex } = readNextDocOp(docState, blockIndex))\n  let docOpsConsumed = (docOp === null ? 0 : 1)\n  let docOpOldSuccNum = (docOp === null ? 0 : docOp[succNumIdx])\n  let changeOp = null, changeOps = [], changeCols = [], predSeen = [], lastChangeKey = null\n  changeState.objectIds.add(objectId)\n\n  // Merge the two inputs: the sequence of ops in the doc, and the sequence of ops in the change.\n  // At each iteration, we either output the doc's op (possibly updated based on the change's ops)\n  // or output an op from the change.\n  while (true) {\n    // The array `changeOps` contains operations from the change(s) we're applying. When the array\n    // is empty, we load changes from the change. Typically we load only a single operation at a\n    // time, with two exceptions: 1. all operations that update the same key or list element in the\n    // same object are put into changeOps at the same time (this is needed so that we can update the\n    // succ columns of the document ops correctly); 2. a run of consecutive insertions is also\n    // placed into changeOps in one go.\n    //\n    // When we have processed all the ops in changeOps we try to see whether there are further\n    // operations that we can also process while we're at it. Those operations must be for the same\n    // object, they must be for a key or list element that appears later in the document, they must\n    // either all be insertions or all be non-insertions, and if insertions, they must be\n    // consecutive. If these conditions are satisfied, that means the operations can be processed in\n    // the same pass. If we encounter an operation that does not meet these conditions, we leave\n    // changeOps empty, and this function returns after having processed any remaining document ops.\n    //\n    // Any operations that could not be processed in a single pass remain in changeState; applyOps\n    // will seek to the appropriate position and then call mergeDocChangeOps again.\n    if (changeOps.length === 0) {\n      foundListElem = false\n\n      let nextOp = changeState.nextOp\n      while (!changeState.done && nextOp[idActorIdx] === idActorIndex && nextOp[insertIdx] === insert &&\n             nextOp[objActorIdx] === firstOp[objActorIdx] && nextOp[objCtrIdx] === firstOp[objCtrIdx]) {\n\n        // Check if the operation's pred references a previous operation in changeOps\n        const lastOp = (changeOps.length > 0) ? changeOps[changeOps.length - 1] : null\n        let isOverwrite = false\n        for (let i = 0; i < nextOp[predNumIdx]; i++) {\n          for (let prevOp of changeOps) {\n            if (nextOp[predActorIdx][i] === prevOp[idActorIdx] && nextOp[predCtrIdx][i] === prevOp[idCtrIdx]) {\n              isOverwrite = true\n            }\n          }\n        }\n\n        // If any of the following `if` statements is true, we add `nextOp` to `changeOps`. If they\n        // are all false, we break out of the loop and stop adding to `changeOps`.\n        if (nextOp === firstOp) {\n          // First change operation in a mergeDocChangeOps call is always used\n        } else if (insert && lastOp !== null && nextOp[keyStrIdx] === null &&\n                   nextOp[keyActorIdx] === lastOp[idActorIdx] &&\n                   nextOp[keyCtrIdx] === lastOp[idCtrIdx]) {\n          // Collect consecutive insertions\n        } else if (!insert && lastOp !== null && nextOp[keyStrIdx] !== null &&\n                   nextOp[keyStrIdx] === lastOp[keyStrIdx] && !isOverwrite) {\n          // Collect several updates to the same key\n        } else if (!insert && lastOp !== null &&\n                   nextOp[keyStrIdx] === null && lastOp[keyStrIdx] === null &&\n                   nextOp[keyActorIdx] === lastOp[keyActorIdx] &&\n                   nextOp[keyCtrIdx] === lastOp[keyCtrIdx] && !isOverwrite) {\n          // Collect several updates to the same list element\n        } else if (!insert && lastOp === null && nextOp[keyStrIdx] === null &&\n                   docOp && docOp[insertIdx] && docOp[keyStrIdx] === null &&\n                   docOp[idActorIdx] === nextOp[keyActorIdx] &&\n                   docOp[idCtrIdx] === nextOp[keyCtrIdx]) {\n          // When updating/deleting list elements, keep going if the next elemId in the change\n          // equals the next elemId in the doc (i.e. we're updating several consecutive elements)\n        } else if (!insert && lastOp === null && nextOp[keyStrIdx] !== null &&\n                   lastChangeKey !== null && lastChangeKey < nextOp[keyStrIdx]) {\n          // Allow a single mergeDocChangeOps call to process changes to several keys in the same\n          // object, provided that they appear in ascending order\n        } else break\n\n        lastChangeKey = (nextOp !== null) ? nextOp[keyStrIdx] : null\n        changeOps.push(changeState.nextOp)\n        changeCols.push(changeState.columns)\n        predSeen.push(new Array(changeState.nextOp[predNumIdx]))\n        readNextChangeOp(docState, changeState)\n        nextOp = changeState.nextOp\n      }\n    }\n\n    if (changeOps.length > 0) changeOp = changeOps[0]\n    const inCorrectObject = docOp && docOp[objActorIdx] === changeOp[objActorIdx] && docOp[objCtrIdx] === changeOp[objCtrIdx]\n    const keyMatches      = docOp && docOp[keyStrIdx] !== null && docOp[keyStrIdx] === changeOp[keyStrIdx]\n    const listElemMatches = docOp && docOp[keyStrIdx] === null && changeOp[keyStrIdx] === null &&\n      ((!docOp[insertIdx] && docOp[keyActorIdx] === changeOp[keyActorIdx] && docOp[keyCtrIdx] === changeOp[keyCtrIdx]) ||\n        (docOp[insertIdx] && docOp[idActorIdx]  === changeOp[keyActorIdx] && docOp[idCtrIdx]  === changeOp[keyCtrIdx]))\n\n    // We keep going until we run out of ops in the change, except that even when we run out, we\n    // keep going until we have processed all doc ops for the current key/list element.\n    if (changeOps.length === 0 && !(inCorrectObject && (keyMatches || listElemMatches))) break\n\n    let takeDocOp = false, takeChangeOps = 0\n\n    // The change operations come first if we are inserting list elements (seekToOp already\n    // determines the correct insertion position), if there is no document operation, if the next\n    // document operation is for a different object, or if the change op's string key is\n    // lexicographically first (TODO check ordering of keys beyond the basic multilingual plane).\n    if (insert || !inCorrectObject ||\n        (docOp[keyStrIdx] === null && changeOp[keyStrIdx] !== null) ||\n        (docOp[keyStrIdx] !== null && changeOp[keyStrIdx] !== null && changeOp[keyStrIdx] < docOp[keyStrIdx])) {\n      // Take the operations from the change\n      takeChangeOps = changeOps.length\n      if (!inCorrectObject && !foundListElem && changeOp[keyStrIdx] === null && !changeOp[insertIdx]) {\n        // This can happen if we first update one list element, then another one earlier in the\n        // list. That is not allowed: list element updates must occur in ascending order.\n        throw new RangeError(\"could not find list element with ID: \" +\n                             `${changeOp[keyCtrIdx]}@${docState.actorIds[changeOp[keyActorIdx]]}`)\n      }\n\n    } else if (keyMatches || listElemMatches || foundListElem) {\n      // The doc operation is for the same key or list element in the same object as the change\n      // ops, so we merge them. First, if any of the change ops' `pred` matches the opId of the\n      // document operation, we update the document operation's `succ` accordingly.\n      for (let opIndex = 0; opIndex < changeOps.length; opIndex++) {\n        const op = changeOps[opIndex]\n        for (let i = 0; i < op[predNumIdx]; i++) {\n          if (op[predActorIdx][i] === docOp[idActorIdx] && op[predCtrIdx][i] === docOp[idCtrIdx]) {\n            // Insert into the doc op's succ list such that the lists remains sorted\n            let j = 0\n            while (j < docOp[succNumIdx] && (docOp[succCtrIdx][j] < op[idCtrIdx] ||\n                   docOp[succCtrIdx][j] === op[idCtrIdx] && docState.actorIds[docOp[succActorIdx][j]] < idActor)) j++\n            docOp[succCtrIdx].splice(j, 0, op[idCtrIdx])\n            docOp[succActorIdx].splice(j, 0, idActorIndex)\n            docOp[succNumIdx]++\n            predSeen[opIndex][i] = true\n            break\n          }\n        }\n      }\n\n      if (listElemMatches) foundListElem = true\n\n      if (foundListElem && !listElemMatches) {\n        // If the previous docOp was for the correct list element, and the current docOp is for\n        // the wrong list element, then place the current changeOp before the docOp.\n        takeChangeOps = changeOps.length\n\n      } else if (changeOps.length === 0 || docOp[idCtrIdx] < changeOp[idCtrIdx] ||\n          (docOp[idCtrIdx] === changeOp[idCtrIdx] && docState.actorIds[docOp[idActorIdx]] < idActor)) {\n        // When we have several operations for the same object and the same key, we want to keep\n        // them sorted in ascending order by opId. Here we have docOp with a lower opId, so we\n        // output it first.\n        takeDocOp = true\n        updatePatchProperty(patches, newBlock, objectId, docOp, docState, propState, listIndex, docOpOldSuccNum)\n\n        // A deletion op in the change is represented in the document only by its entries in the\n        // succ list of the operations it overwrites; it has no separate row in the set of ops.\n        for (let i = changeOps.length - 1; i >= 0; i--) {\n          let deleted = true\n          for (let j = 0; j < changeOps[i][predNumIdx]; j++) {\n            if (!predSeen[i][j]) deleted = false\n          }\n          if (ACTIONS[changeOps[i][actionIdx]] === 'del' && deleted) {\n            changeOps.splice(i, 1)\n            changeCols.splice(i, 1)\n            predSeen.splice(i, 1)\n          }\n        }\n\n      } else if (docOp[idCtrIdx] === changeOp[idCtrIdx] && docState.actorIds[docOp[idActorIdx]] === idActor) {\n        throw new RangeError(`duplicate operation ID: ${changeOp[idCtrIdx]}@${idActor}`)\n      } else {\n        // The changeOp has the lower opId, so we output it first.\n        takeChangeOps = 1\n      }\n    } else {\n      // The document operation comes first if its string key is lexicographically first, or if\n      // we're using opId keys and the keys don't match (i.e. we scan the document until we find a\n      // matching key).\n      takeDocOp = true\n    }\n\n    if (takeDocOp) {\n      appendOperation(outCols, docState.blocks[blockIndex].columns, docOp)\n      addBlockOperation(newBlock, docOp, docState.actorIds, false)\n\n      if (docOp[insertIdx] && elemVisible) {\n        elemVisible = false\n        listIndex++\n      }\n      if (docOp[succNumIdx] === 0) elemVisible = true\n      newBlock.numOps++\n      ;({ docOp, blockIndex } = readNextDocOp(docState, blockIndex))\n      if (docOp !== null) {\n        docOpsConsumed++\n        docOpOldSuccNum = docOp[succNumIdx]\n      }\n    }\n\n    if (takeChangeOps > 0) {\n      for (let i = 0; i < takeChangeOps; i++) {\n        let op = changeOps[i]\n        // Check that we've seen all ops mentioned in `pred` (they must all have lower opIds than\n        // the change op's own opId, so we must have seen them already)\n        for (let j = 0; j < op[predNumIdx]; j++) {\n          if (!predSeen[i][j]) {\n            throw new RangeError(`no matching operation for pred: ${op[predCtrIdx][j]}@${docState.actorIds[op[predActorIdx][j]]}`)\n          }\n        }\n        appendOperation(outCols, changeCols[i], op)\n        addBlockOperation(newBlock, op, docState.actorIds, true)\n        updatePatchProperty(patches, newBlock, objectId, op, docState, propState, listIndex)\n\n        if (op[insertIdx]) {\n          elemVisible = false\n          listIndex++\n        } else {\n          elemVisible = true\n        }\n      }\n\n      if (takeChangeOps === changeOps.length) {\n        changeOps.length = 0\n        changeCols.length = 0\n        predSeen.length = 0\n      } else {\n        changeOps.splice(0, takeChangeOps)\n        changeCols.splice(0, takeChangeOps)\n        predSeen.splice(0, takeChangeOps)\n      }\n      newBlock.numOps += takeChangeOps\n    }\n  }\n\n  if (docOp) {\n    appendOperation(outCols, docState.blocks[blockIndex].columns, docOp)\n    newBlock.numOps++\n    addBlockOperation(newBlock, docOp, docState.actorIds, false)\n  }\n  return {docOpsConsumed, blockIndex}\n}\n\n/**\n * Applies operations from the change (or series of changes) in `changeState` to the document\n * `docState`. Passing `changeState` to `readNextChangeOp` allows iterating over the change ops.\n * `docState` is an object with keys:\n *   - `actorIds` is an array of actorIds (as hex strings) occurring in the document (values in\n *     the document's objActor/keyActor/idActor/... columns are indexes into this array).\n *   - `blocks` is an array of all the blocks of operations in the document.\n *   - `objectMeta` is a map from objectId to metadata about that object.\n *\n * `docState` is mutated to contain the updated document state.\n * `patches` is a patch object that is mutated to reflect the operations applied by this function.\n */\nfunction applyOps(patches, changeState, docState) {\n  const [objActorNum, objCtr, keyActorNum, keyCtr, keyStr, idActorNum, idCtr, insert] = changeState.nextOp\n  const objActor = objActorNum === null ? null : docState.actorIds[objActorNum]\n  const keyActor = keyActorNum === null ? null : docState.actorIds[keyActorNum]\n  const ops = {\n    objActor, objActorNum, objCtr, keyActor, keyActorNum, keyCtr, keyStr,\n    idActor: docState.actorIds[idActorNum], idCtr, insert,\n    objId: objActor === null ? '_root' : `${objCtr}@${objActor}`\n  }\n\n  const {blockIndex, skipCount, visibleCount} = seekToOp(docState, ops)\n  const block = docState.blocks[blockIndex]\n  for (let col of block.columns) col.decoder.reset()\n\n  const resetFirstVisible = (skipCount === 0) || (block.firstVisibleActor === undefined) ||\n    (!insert && block.firstVisibleActor === keyActorNum && block.firstVisibleCtr === keyCtr)\n  const newBlock = {\n    columns: undefined,\n    bloom: new Uint8Array(block.bloom),\n    numOps: skipCount,\n    lastKey: block.lastKey,\n    numVisible: block.numVisible,\n    lastObjectActor: block.lastObjectActor,\n    lastObjectCtr: block.lastObjectCtr,\n    firstVisibleActor: resetFirstVisible ? undefined : block.firstVisibleActor,\n    firstVisibleCtr: resetFirstVisible ? undefined : block.firstVisibleCtr,\n    lastVisibleActor: undefined,\n    lastVisibleCtr: undefined\n  }\n\n  // Copy the operations up to the insertion position (the first skipCount operations)\n  const outCols = block.columns.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n  copyColumns(outCols, block.columns, skipCount)\n\n  // Apply the operations from the change. This may cause blockIndex to move forwards if the\n  // property being updated straddles a block boundary.\n  const {blockIndex: lastBlockIndex, docOpsConsumed} =\n    mergeDocChangeOps(patches, newBlock, outCols, changeState, docState, visibleCount, blockIndex)\n\n  // Copy the remaining operations after the insertion position\n  const lastBlock = docState.blocks[lastBlockIndex]\n  let copyAfterMerge = -skipCount - docOpsConsumed\n  for (let i = blockIndex; i <= lastBlockIndex; i++) copyAfterMerge += docState.blocks[i].numOps\n  copyColumns(outCols, lastBlock.columns, copyAfterMerge)\n  newBlock.numOps += copyAfterMerge\n\n  for (let col of lastBlock.columns) {\n    if (!col.decoder.done) throw new RangeError(`excess ops in column ${col.columnId}`)\n  }\n\n  newBlock.columns = outCols.map(col => {\n    const decoder = decoderByColumnId(col.columnId, col.encoder.buffer)\n    return {columnId: col.columnId, decoder}\n  })\n\n  if (blockIndex === lastBlockIndex && newBlock.numOps <= MAX_BLOCK_SIZE) {\n    // The result is just one output block\n    if (copyAfterMerge > 0 && block.lastVisibleActor !== undefined && block.lastVisibleCtr !== undefined) {\n      // It's possible that none of the ops after the merge point are visible, in which case the\n      // lastVisible may not be strictly correct, because it may refer to an operation before the\n      // merge point rather than a list element inserted by the current change. However, this doesn't\n      // matter, because the only purpose for which we need it is to check whether one block ends with\n      // the same visible element as the next block starts with (to avoid double-counting its index);\n      // if the last list element of a block is invisible, the exact value of lastVisible doesn't\n      // matter since it will be different from the next block's firstVisible in any case.\n      newBlock.lastVisibleActor = block.lastVisibleActor\n      newBlock.lastVisibleCtr = block.lastVisibleCtr\n    }\n\n    docState.blocks[blockIndex] = newBlock\n\n  } else {\n    // Oversized output block must be split into smaller blocks\n    const newBlocks = splitBlock(newBlock)\n    docState.blocks.splice(blockIndex, lastBlockIndex - blockIndex + 1, ...newBlocks)\n  }\n}\n\n/**\n * Updates the columns in a document's operation blocks to contain all the columns in a change\n * (including any column types we don't recognise, which have been generated by a future version\n * of Automerge).\n */\nfunction updateBlockColumns(docState, changeCols) {\n  // Check that the columns of a change appear at the index at which we expect them to be\n  if (changeCols[objActorIdx ].columnId !== CHANGE_COLUMNS[objActorIdx ].columnId || CHANGE_COLUMNS[objActorIdx ].columnName !== 'objActor'  ||\n      changeCols[objCtrIdx   ].columnId !== CHANGE_COLUMNS[objCtrIdx   ].columnId || CHANGE_COLUMNS[objCtrIdx   ].columnName !== 'objCtr'    ||\n      changeCols[keyActorIdx ].columnId !== CHANGE_COLUMNS[keyActorIdx ].columnId || CHANGE_COLUMNS[keyActorIdx ].columnName !== 'keyActor'  ||\n      changeCols[keyCtrIdx   ].columnId !== CHANGE_COLUMNS[keyCtrIdx   ].columnId || CHANGE_COLUMNS[keyCtrIdx   ].columnName !== 'keyCtr'    ||\n      changeCols[keyStrIdx   ].columnId !== CHANGE_COLUMNS[keyStrIdx   ].columnId || CHANGE_COLUMNS[keyStrIdx   ].columnName !== 'keyStr'    ||\n      changeCols[idActorIdx  ].columnId !== CHANGE_COLUMNS[idActorIdx  ].columnId || CHANGE_COLUMNS[idActorIdx  ].columnName !== 'idActor'   ||\n      changeCols[idCtrIdx    ].columnId !== CHANGE_COLUMNS[idCtrIdx    ].columnId || CHANGE_COLUMNS[idCtrIdx    ].columnName !== 'idCtr'     ||\n      changeCols[insertIdx   ].columnId !== CHANGE_COLUMNS[insertIdx   ].columnId || CHANGE_COLUMNS[insertIdx   ].columnName !== 'insert'    ||\n      changeCols[actionIdx   ].columnId !== CHANGE_COLUMNS[actionIdx   ].columnId || CHANGE_COLUMNS[actionIdx   ].columnName !== 'action'    ||\n      changeCols[valLenIdx   ].columnId !== CHANGE_COLUMNS[valLenIdx   ].columnId || CHANGE_COLUMNS[valLenIdx   ].columnName !== 'valLen'    ||\n      changeCols[valRawIdx   ].columnId !== CHANGE_COLUMNS[valRawIdx   ].columnId || CHANGE_COLUMNS[valRawIdx   ].columnName !== 'valRaw'    ||\n      changeCols[predNumIdx  ].columnId !== CHANGE_COLUMNS[predNumIdx  ].columnId || CHANGE_COLUMNS[predNumIdx  ].columnName !== 'predNum'   ||\n      changeCols[predActorIdx].columnId !== CHANGE_COLUMNS[predActorIdx].columnId || CHANGE_COLUMNS[predActorIdx].columnName !== 'predActor' ||\n      changeCols[predCtrIdx  ].columnId !== CHANGE_COLUMNS[predCtrIdx  ].columnId || CHANGE_COLUMNS[predCtrIdx  ].columnName !== 'predCtr') {\n    throw new RangeError('unexpected columnId')\n  }\n\n  // Check if there any columns in the change that are not in the document, apart from pred*\n  const docCols = docState.blocks[0].columns\n  if (!changeCols.every(changeCol => PRED_COLUMN_IDS.includes(changeCol.columnId) ||\n                                     docCols.find(docCol => docCol.columnId === changeCol.columnId))) {\n    let allCols = docCols.map(docCol => ({columnId: docCol.columnId}))\n    for (let changeCol of changeCols) {\n      const { columnId } = changeCol\n      if (!PRED_COLUMN_IDS.includes(columnId) && !docCols.find(docCol => docCol.columnId === columnId)) {\n        allCols.push({columnId})\n      }\n    }\n    allCols.sort((a, b) => a.columnId - b.columnId)\n\n    for (let blockIndex = 0; blockIndex < docState.blocks.length; blockIndex++) {\n      let block = copyObject(docState.blocks[blockIndex])\n      block.columns = makeDecoders(block.columns.map(col => ({columnId: col.columnId, buffer: col.decoder.buf})), allCols)\n      docState.blocks[blockIndex] = block\n    }\n  }\n}\n\n/**\n * Takes a decoded change header, including an array of actorIds. Returns an object of the form\n * `{actorIds, actorTable}`, where `actorIds` is an updated array of actorIds appearing in the\n * document (including the new change's actorId). `actorTable` is an array of integers where\n * `actorTable[i]` contains the document's actor index for the actor that has index `i` in the\n * change (`i == 0` is the author of the change).\n */\nfunction getActorTable(actorIds, change) {\n  if (actorIds.indexOf(change.actorIds[0]) < 0) {\n    if (change.seq !== 1) {\n      throw new RangeError(`Seq ${change.seq} is the first change for actor ${change.actorIds[0]}`)\n    }\n    // Use concat, not push, so that the original array is not mutated\n    actorIds = actorIds.concat([change.actorIds[0]])\n  }\n  const actorTable = [] // translate from change's actor index to doc's actor index\n  for (let actorId of change.actorIds) {\n    const index = actorIds.indexOf(actorId)\n    if (index < 0) {\n      throw new RangeError(`actorId ${actorId} is not known to document`)\n    }\n    actorTable.push(index)\n  }\n  return {actorIds, actorTable}\n}\n\n/**\n * Finalises the patch for a change. `patches` is a map from objectIds to patch for that\n * particular object, `objectIds` is the array of IDs of objects that are created or updated in the\n * change, and `docState` is an object containing various bits of document state, including\n * `objectMeta`, a map from objectIds to metadata about that object (such as its parent in the\n * document tree). Mutates `patches` such that child objects are linked into their parent object,\n * all the way to the root object.\n */\nfunction setupPatches(patches, objectIds, docState) {\n  for (let objectId of objectIds) {\n    let meta = docState.objectMeta[objectId], childMeta = null, patchExists = false\n    while (true) {\n      const hasChildren = childMeta && Object.keys(meta.children[childMeta.parentKey]).length > 0\n      if (!patches[objectId]) patches[objectId] = emptyObjectPatch(objectId, meta.type)\n\n      if (childMeta && hasChildren) {\n        if (meta.type === 'list' || meta.type === 'text') {\n          // In list/text objects, parentKey is an elemID. First see if it already appears in an edit\n          for (let edit of patches[objectId].edits) {\n            if (edit.opId && meta.children[childMeta.parentKey][edit.opId]) {\n              patchExists = true\n            }\n          }\n\n          // If we need to add an edit, we first have to translate the elemId into an index\n          if (!patchExists) {\n            const obj = parseOpId(objectId), elem = parseOpId(childMeta.parentKey)\n            const seekPos = {\n              objActor: obj.actorId,  objCtr: obj.counter,\n              keyActor: elem.actorId, keyCtr: elem.counter,\n              objActorNum: docState.actorIds.indexOf(obj.actorId),\n              keyActorNum: docState.actorIds.indexOf(elem.actorId),\n              keyStr:   null,         insert: false,\n              objId:    objectId\n            }\n            const { visibleCount } = seekToOp(docState, seekPos)\n\n            for (let [opId, value] of Object.entries(meta.children[childMeta.parentKey])) {\n              let patchValue = value\n              if (value.objectId) {\n                if (!patches[value.objectId]) patches[value.objectId] = emptyObjectPatch(value.objectId, value.type)\n                patchValue = patches[value.objectId]\n              }\n              const edit = {action: 'update', index: visibleCount, opId, value: patchValue}\n              appendEdit(patches[objectId].edits, edit)\n            }\n          }\n\n        } else {\n          // Non-list object: parentKey is the name of the property being updated (a string)\n          if (!patches[objectId].props[childMeta.parentKey]) {\n            patches[objectId].props[childMeta.parentKey] = {}\n          }\n          let values = patches[objectId].props[childMeta.parentKey]\n\n          for (let [opId, value] of Object.entries(meta.children[childMeta.parentKey])) {\n            if (values[opId]) {\n              patchExists = true\n            } else if (value.objectId) {\n              if (!patches[value.objectId]) patches[value.objectId] = emptyObjectPatch(value.objectId, value.type)\n              values[opId] = patches[value.objectId]\n            } else {\n              values[opId] = value\n            }\n          }\n        }\n      }\n\n      if (patchExists || !meta.parentObj || (childMeta && !hasChildren)) break\n      childMeta = meta\n      objectId = meta.parentObj\n      meta = docState.objectMeta[objectId]\n    }\n  }\n  return patches\n}\n\n/**\n * Takes an array of decoded changes and applies them to a document. `docState` contains a bunch of\n * fields describing the document state. This function mutates `docState` to contain the updated\n * document state, and mutates `patches` to contain a patch to return to the frontend. Only the\n * top-level `docState` object is mutated; all nested objects within it are treated as immutable.\n * `objectIds` is mutated to contain the IDs of objects that are updated in any of the changes.\n *\n * The function detects duplicate changes that we've already applied by looking up each change's\n * hash in `docState.changeIndexByHash`. If we deferred the hash graph computation, that structure\n * will be incomplete, and we run the risk of applying the same change twice. However, we still have\n * the sequence numbers for detecting duplicates. If `throwExceptions` is true, we assume that the\n * set of change hashes is complete, and therefore a duplicate sequence number indicates illegal\n * behaviour. If `throwExceptions` is false, and we detect a possible sequence number reuse, we\n * don't throw an exception but instead enqueue all of the changes. This gives us a chance to\n * recompute the hash graph and eliminate duplicates before raising an error to the application.\n *\n * Returns a two-element array `[applied, enqueued]`, where `applied` is an array of changes that\n * have been applied to the document, and `enqueued` is an array of changes that have not yet been\n * applied because they are missing a dependency.\n */\nfunction applyChanges(patches, decodedChanges, docState, objectIds, throwExceptions) {\n  let heads = new Set(docState.heads), changeHashes = new Set()\n  let clock = copyObject(docState.clock)\n  let applied = [], enqueued = []\n\n  for (let change of decodedChanges) {\n    // Skip any duplicate changes that we have already seen\n    if (docState.changeIndexByHash[change.hash] !== undefined || changeHashes.has(change.hash)) continue\n\n    const expectedSeq = (clock[change.actor] || 0) + 1\n    let causallyReady = true\n\n    for (let dep of change.deps) {\n      const depIndex = docState.changeIndexByHash[dep]\n      if ((depIndex === undefined || depIndex === -1) && !changeHashes.has(dep)) {\n        causallyReady = false\n      }\n    }\n\n    if (!causallyReady) {\n      enqueued.push(change)\n    } else if (change.seq < expectedSeq) {\n      if (throwExceptions) {\n        throw new RangeError(`Reuse of sequence number ${change.seq} for actor ${change.actor}`)\n      } else {\n        return [[], decodedChanges]\n      }\n    } else if (change.seq > expectedSeq) {\n      throw new RangeError(`Skipped sequence number ${expectedSeq} for actor ${change.actor}`)\n    } else {\n      clock[change.actor] = change.seq\n      changeHashes.add(change.hash)\n      for (let dep of change.deps) heads.delete(dep)\n      heads.add(change.hash)\n      applied.push(change)\n    }\n  }\n\n  if (applied.length > 0) {\n    let changeState = {changes: applied, changeIndex: -1, objectIds}\n    readNextChangeOp(docState, changeState)\n    while (!changeState.done) applyOps(patches, changeState, docState)\n\n    docState.heads = [...heads].sort()\n    docState.clock = clock\n  }\n  return [applied, enqueued]\n}\n\n/**\n * Scans the operations in a document and generates a patch that can be sent to the frontend to\n * instantiate the current state of the document. `objectMeta` is mutated to contain information\n * about the parent and children of each object in the document.\n */\nfunction documentPatch(docState) {\n  for (let col of docState.blocks[0].columns) col.decoder.reset()\n  let propState = {}, docOp = null, blockIndex = 0\n  let patches = {_root: {objectId: '_root', type: 'map', props: {}}}\n  let lastObjActor = null, lastObjCtr = null, objectId = '_root', elemVisible = false, listIndex = 0\n\n  while (true) {\n    ({ docOp, blockIndex } = readNextDocOp(docState, blockIndex))\n    if (docOp === null) break\n    if (docOp[objActorIdx] !== lastObjActor || docOp[objCtrIdx] !== lastObjCtr) {\n      objectId = `${docOp[objCtrIdx]}@${docState.actorIds[docOp[objActorIdx]]}`\n      lastObjActor = docOp[objActorIdx]\n      lastObjCtr = docOp[objCtrIdx]\n      propState = {}\n      listIndex = 0\n      elemVisible = false\n    }\n\n    if (docOp[insertIdx] && elemVisible) {\n      elemVisible = false\n      listIndex++\n    }\n    if (docOp[succNumIdx] === 0) elemVisible = true\n    if (docOp[idCtrIdx] > docState.maxOp) docState.maxOp = docOp[idCtrIdx]\n    for (let i = 0; i < docOp[succNumIdx]; i++) {\n      if (docOp[succCtrIdx][i] > docState.maxOp) docState.maxOp = docOp[succCtrIdx][i]\n    }\n\n    updatePatchProperty(patches, null, objectId, docOp, docState, propState, listIndex, docOp[succNumIdx])\n  }\n  return patches._root\n}\n\n/**\n * Takes an encoded document whose headers have been parsed using `decodeDocumentHeader()` and reads\n * from it the list of changes. Returns the document's current vector clock, i.e. an object mapping\n * each actor ID (as a hex string) to the number of changes seen from that actor. Also returns an\n * array of the actorIds whose most recent change has no dependents (i.e. the actors that\n * contributed the current heads of the document), and an array of encoders that has been\n * initialised to contain the columns of the changes list.\n */\nfunction readDocumentChanges(doc) {\n  const columns = makeDecoders(doc.changesColumns, DOCUMENT_COLUMNS)\n  const actorD = columns[0].decoder, seqD = columns[1].decoder\n  const depsNumD = columns[5].decoder, depsIndexD = columns[6].decoder\n  if (columns[0].columnId !== DOCUMENT_COLUMNS[0].columnId || DOCUMENT_COLUMNS[0].columnName !== 'actor' ||\n      columns[1].columnId !== DOCUMENT_COLUMNS[1].columnId || DOCUMENT_COLUMNS[1].columnName !== 'seq' ||\n      columns[5].columnId !== DOCUMENT_COLUMNS[5].columnId || DOCUMENT_COLUMNS[5].columnName !== 'depsNum' ||\n      columns[6].columnId !== DOCUMENT_COLUMNS[6].columnId || DOCUMENT_COLUMNS[6].columnName !== 'depsIndex') {\n    throw new RangeError('unexpected columnId')\n  }\n\n  let numChanges = 0, clock = {}, actorNums = [], headIndexes = new Set()\n  while (!actorD.done) {\n    const actorNum = actorD.readValue(), seq = seqD.readValue(), depsNum = depsNumD.readValue()\n    const actorId = doc.actorIds[actorNum]\n    if (seq !== 1 && seq !== clock[actorId] + 1) {\n      throw new RangeError(`Expected seq ${clock[actorId] + 1}, got ${seq} for actor ${actorId}`)\n    }\n    actorNums.push(actorNum)\n    clock[actorId] = seq\n    headIndexes.add(numChanges)\n    for (let j = 0; j < depsNum; j++) headIndexes.delete(depsIndexD.readValue())\n    numChanges++\n  }\n  const headActors = [...headIndexes].map(index => doc.actorIds[actorNums[index]]).sort()\n\n  for (let col of columns) col.decoder.reset()\n  const encoders = columns.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n  copyColumns(encoders, columns, numChanges)\n  return {clock, headActors, encoders, numChanges}\n}\n\n/**\n * Records the metadata about a change in the appropriate columns.\n */\nfunction appendChange(columns, change, actorIds, changeIndexByHash) {\n  appendOperation(columns, DOCUMENT_COLUMNS, [\n    actorIds.indexOf(change.actor), // actor\n    change.seq, // seq\n    change.maxOp, // maxOp\n    change.time, // time\n    change.message, // message\n    change.deps.length, // depsNum\n    change.deps.map(dep => changeIndexByHash[dep]), // depsIndex\n    change.extraBytes ? (change.extraBytes.byteLength << 4 | VALUE_TYPE.BYTES) : VALUE_TYPE.BYTES, // extraLen\n    change.extraBytes // extraRaw\n  ])\n}\n\nclass BackendDoc {\n  constructor(buffer) {\n    this.maxOp = 0\n    this.haveHashGraph = false\n    this.changes = []\n    this.changeIndexByHash = {}\n    this.dependenciesByHash = {}\n    this.dependentsByHash = {}\n    this.hashesByActor = {}\n    this.actorIds = []\n    this.heads = []\n    this.clock = {}\n    this.queue = []\n    this.objectMeta = {_root: {parentObj: null, parentKey: null, opId: null, type: 'map', children: {}}}\n\n    if (buffer) {\n      const doc = decodeDocumentHeader(buffer)\n      const {clock, headActors, encoders, numChanges} = readDocumentChanges(doc)\n      this.binaryDoc = buffer\n      this.changes = new Array(numChanges)\n      this.actorIds = doc.actorIds\n      this.heads = doc.heads\n      this.clock = clock\n      this.changesEncoders = encoders\n      this.extraBytes = doc.extraBytes\n\n      // If there is a single head, we can unambiguously point at the actorId and sequence number of\n      // the head hash without having to reconstruct the hash graph\n      if (doc.heads.length === 1 && headActors.length === 1) {\n        this.hashesByActor[headActors[0]] = []\n        this.hashesByActor[headActors[0]][clock[headActors[0]] - 1] = doc.heads[0]\n      }\n\n      // The encoded document gives each change an index, and expresses dependencies in terms of\n      // those indexes. Initialise the translation table from hash to index.\n      if (doc.heads.length === doc.headsIndexes.length) {\n        for (let i = 0; i < doc.heads.length; i++) {\n          this.changeIndexByHash[doc.heads[i]] = doc.headsIndexes[i]\n        }\n      } else if (doc.heads.length === 1) {\n        // If there is only one head, it must be the last change\n        this.changeIndexByHash[doc.heads[0]] = numChanges - 1\n      } else {\n        // We know the heads hashes, but not their indexes\n        for (let head of doc.heads) this.changeIndexByHash[head] = -1\n      }\n\n      this.blocks = [{columns: makeDecoders(doc.opsColumns, DOC_OPS_COLUMNS)}]\n      updateBlockMetadata(this.blocks[0])\n      if (this.blocks[0].numOps > MAX_BLOCK_SIZE) {\n        this.blocks = splitBlock(this.blocks[0])\n      }\n\n      let docState = {blocks: this.blocks, actorIds: this.actorIds, objectMeta: this.objectMeta, maxOp: 0}\n      this.initPatch = documentPatch(docState)\n      this.maxOp = docState.maxOp\n\n    } else {\n      this.haveHashGraph = true\n      this.changesEncoders = DOCUMENT_COLUMNS.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n      this.blocks = [{\n        columns: makeDecoders([], DOC_OPS_COLUMNS),\n        bloom: new Uint8Array(BLOOM_FILTER_SIZE),\n        numOps: 0,\n        lastKey: undefined,\n        numVisible: undefined,\n        lastObjectActor: undefined,\n        lastObjectCtr: undefined,\n        firstVisibleActor: undefined,\n        firstVisibleCtr: undefined,\n        lastVisibleActor: undefined,\n        lastVisibleCtr: undefined\n      }]\n    }\n  }\n\n  /**\n   * Makes a copy of this BackendDoc that can be independently modified.\n   */\n  clone() {\n    let copy = new BackendDoc()\n    copy.maxOp = this.maxOp\n    copy.haveHashGraph = this.haveHashGraph\n    copy.changes = this.changes.slice()\n    copy.changeIndexByHash = copyObject(this.changeIndexByHash)\n    copy.dependenciesByHash = copyObject(this.dependenciesByHash)\n    copy.dependentsByHash = Object.entries(this.dependentsByHash).reduce((acc, [k, v]) => { acc[k] = v.slice(); return acc }, {})\n    copy.hashesByActor = Object.entries(this.hashesByActor).reduce((acc, [k, v]) => { acc[k] = v.slice(); return acc }, {})\n    copy.actorIds = this.actorIds // immutable, no copying needed\n    copy.heads = this.heads // immutable, no copying needed\n    copy.clock = this.clock // immutable, no copying needed\n    copy.blocks = this.blocks // immutable, no copying needed\n    copy.objectMeta = this.objectMeta // immutable, no copying needed\n    copy.queue = this.queue // immutable, no copying needed\n    return copy\n  }\n\n  /**\n   * Parses the changes given as Uint8Arrays in `changeBuffers`, and applies them to the current\n   * document. Returns a patch to apply to the frontend. If an exception is thrown, the document\n   * object is not modified.\n   */\n  applyChanges(changeBuffers, isLocal = false) {\n    // decoded change has the form { actor, seq, startOp, time, message, deps, actorIds, hash, columns, buffer }\n    let decodedChanges = changeBuffers.map(buffer => {\n      const decoded = decodeChangeColumns(buffer)\n      decoded.buffer = buffer\n      return decoded\n    })\n\n    let patches = {_root: {objectId: '_root', type: 'map', props: {}}}\n    let docState = {\n      maxOp: this.maxOp,\n      changeIndexByHash: this.changeIndexByHash,\n      actorIds: this.actorIds,\n      heads: this.heads,\n      clock: this.clock,\n      blocks: this.blocks.slice(),\n      objectMeta: Object.assign({}, this.objectMeta)\n    }\n    let queue = (this.queue.length === 0) ? decodedChanges : decodedChanges.concat(this.queue)\n    let allApplied = [], objectIds = new Set()\n\n    while (true) {\n      const [applied, enqueued] = applyChanges(patches, queue, docState, objectIds, this.haveHashGraph)\n      queue = enqueued\n      for (let i = 0; i < applied.length; i++) {\n        docState.changeIndexByHash[applied[i].hash] = this.changes.length + allApplied.length + i\n      }\n      if (applied.length > 0) allApplied = allApplied.concat(applied)\n      if (queue.length === 0) break\n\n      // If we are missing a dependency, and we haven't computed the hash graph yet, first compute\n      // the hashes to see if we actually have it already\n      if (applied.length === 0) {\n        if (this.haveHashGraph) break\n        this.computeHashGraph()\n        docState.changeIndexByHash = this.changeIndexByHash\n      }\n    }\n\n    setupPatches(patches, objectIds, docState)\n\n    // Update the document state only if `applyChanges` does not throw an exception\n    for (let change of allApplied) {\n      this.changes.push(change.buffer)\n      if (!this.hashesByActor[change.actor]) this.hashesByActor[change.actor] = []\n      this.hashesByActor[change.actor][change.seq - 1] = change.hash\n      this.changeIndexByHash[change.hash] = this.changes.length - 1\n      this.dependenciesByHash[change.hash] = change.deps\n      this.dependentsByHash[change.hash] = []\n      for (let dep of change.deps) {\n        if (!this.dependentsByHash[dep]) this.dependentsByHash[dep] = []\n        this.dependentsByHash[dep].push(change.hash)\n      }\n      appendChange(this.changesEncoders, change, docState.actorIds, this.changeIndexByHash)\n    }\n\n    this.maxOp        = docState.maxOp\n    this.actorIds     = docState.actorIds\n    this.heads        = docState.heads\n    this.clock        = docState.clock\n    this.blocks       = docState.blocks\n    this.objectMeta   = docState.objectMeta\n    this.queue        = queue\n    this.binaryDoc    = null\n    this.initPatch    = null\n\n    let patch = {\n      maxOp: this.maxOp, clock: this.clock, deps: this.heads,\n      pendingChanges: this.queue.length, diffs: patches._root\n    }\n    if (isLocal && decodedChanges.length === 1) {\n      patch.actor = decodedChanges[0].actor\n      patch.seq = decodedChanges[0].seq\n    }\n    return patch\n  }\n\n  /**\n   * Reconstructs the full change history of a document, and initialises the variables that allow us\n   * to traverse the hash graph of changes and their dependencies. When a compressed document is\n   * loaded we defer the computation of this hash graph to make loading faster, but if the hash\n   * graph is later needed (e.g. for the sync protocol), this function fills it in.\n   */\n  computeHashGraph() {\n    const binaryDoc = this.save()\n    this.haveHashGraph = true\n    this.changes = []\n    this.changeIndexByHash = {}\n    this.dependenciesByHash = {}\n    this.dependentsByHash = {}\n    this.hashesByActor = {}\n    this.clock = {}\n\n    for (let change of decodeChanges([binaryDoc])) {\n      const binaryChange = encodeChange(change) // TODO: avoid decoding and re-encoding again\n      this.changes.push(binaryChange)\n      this.changeIndexByHash[change.hash] = this.changes.length - 1\n      this.dependenciesByHash[change.hash] = change.deps\n      this.dependentsByHash[change.hash] = []\n      for (let dep of change.deps) this.dependentsByHash[dep].push(change.hash)\n      if (change.seq === 1) this.hashesByActor[change.actor] = []\n      this.hashesByActor[change.actor].push(change.hash)\n      const expectedSeq = (this.clock[change.actor] || 0) + 1\n      if (change.seq !== expectedSeq) {\n        throw new RangeError(`Expected seq ${expectedSeq}, got seq ${change.seq} from actor ${change.actor}`)\n      }\n      this.clock[change.actor] = change.seq\n    }\n  }\n\n  /**\n   * Returns all the changes that need to be sent to another replica. `haveDeps` is a list of change\n   * hashes (as hex strings) of the heads that the other replica has. The changes in `haveDeps` and\n   * any of their transitive dependencies will not be returned; any changes later than or concurrent\n   * to the hashes in `haveDeps` will be returned. If `haveDeps` is an empty array, all changes are\n   * returned. Throws an exception if any of the given hashes are not known to this replica.\n   */\n  getChanges(haveDeps) {\n    if (!this.haveHashGraph) this.computeHashGraph()\n\n    // If the other replica has nothing, return all changes in history order\n    if (haveDeps.length === 0) {\n      return this.changes.slice()\n    }\n\n    // Fast path for the common case where all new changes depend only on haveDeps\n    let stack = [], seenHashes = {}, toReturn = []\n    for (let hash of haveDeps) {\n      seenHashes[hash] = true\n      const successors = this.dependentsByHash[hash]\n      if (!successors) throw new RangeError(`hash not found: ${hash}`)\n      stack.push(...successors)\n    }\n\n    // Depth-first traversal of the hash graph to find all changes that depend on `haveDeps`\n    while (stack.length > 0) {\n      const hash = stack.pop()\n      seenHashes[hash] = true\n      toReturn.push(hash)\n      if (!this.dependenciesByHash[hash].every(dep => seenHashes[dep])) {\n        // If a change depends on a hash we have not seen, abort the traversal and fall back to the\n        // slower algorithm. This will sometimes abort even if all new changes depend on `haveDeps`,\n        // because our depth-first traversal is not necessarily a topological sort of the graph.\n        break\n      }\n      stack.push(...this.dependentsByHash[hash])\n    }\n\n    // If the traversal above has encountered all the heads, and was not aborted early due to\n    // a missing dependency, then the set of changes it has found is complete, so we can return it\n    if (stack.length === 0 && this.heads.every(head => seenHashes[head])) {\n      return toReturn.map(hash => this.changes[this.changeIndexByHash[hash]])\n    }\n\n    // If we haven't encountered all of the heads, we have to search harder. This will happen if\n    // changes were added that are concurrent to `haveDeps`\n    stack = haveDeps.slice()\n    seenHashes = {}\n    while (stack.length > 0) {\n      const hash = stack.pop()\n      if (!seenHashes[hash]) {\n        const deps = this.dependenciesByHash[hash]\n        if (!deps) throw new RangeError(`hash not found: ${hash}`)\n        stack.push(...deps)\n        seenHashes[hash] = true\n      }\n    }\n\n    return this.changes.filter(change => !seenHashes[decodeChangeMeta(change, true).hash])\n  }\n\n  /**\n   * Returns all changes that are present in this BackendDoc, but not present in the `other`\n   * BackendDoc.\n   */\n  getChangesAdded(other) {\n    if (!this.haveHashGraph) this.computeHashGraph()\n\n    // Depth-first traversal from the heads through the dependency graph,\n    // until we reach a change that is already present in opSet1\n    let stack = this.heads.slice(), seenHashes = {}, toReturn = []\n    while (stack.length > 0) {\n      const hash = stack.pop()\n      if (!seenHashes[hash] && other.changeIndexByHash[hash] === undefined) {\n        seenHashes[hash] = true\n        toReturn.push(hash)\n        stack.push(...this.dependenciesByHash[hash])\n      }\n    }\n\n    // Return those changes in the reverse of the order in which the depth-first search\n    // found them. This is not necessarily a topological sort, but should usually be close.\n    return toReturn.reverse().map(hash => this.changes[this.changeIndexByHash[hash]])\n  }\n\n  getChangeByHash(hash) {\n    if (!this.haveHashGraph) this.computeHashGraph()\n    return this.changes[this.changeIndexByHash[hash]]\n  }\n\n  /**\n   * Returns the hashes of any missing dependencies, i.e. where we have tried to apply a change that\n   * has a dependency on a change we have not seen.\n   *\n   * If the argument `heads` is given (an array of hexadecimal strings representing hashes as\n   * returned by `getHeads()`), this function also ensures that all of those hashes resolve to\n   * either a change that has been applied to the document, or that has been enqueued for later\n   * application once missing dependencies have arrived. Any missing heads hashes are included in\n   * the returned array.\n   */\n  getMissingDeps(heads = []) {\n    if (!this.haveHashGraph) this.computeHashGraph()\n\n    let allDeps = new Set(heads), inQueue = new Set()\n    for (let change of this.queue) {\n      inQueue.add(change.hash)\n      for (let dep of change.deps) allDeps.add(dep)\n    }\n\n    let missing = []\n    for (let hash of allDeps) {\n      if (this.changeIndexByHash[hash] === undefined && !inQueue.has(hash)) missing.push(hash)\n    }\n    return missing.sort()\n  }\n\n  /**\n   * Serialises the current document state into a single byte array.\n   */\n  save() {\n    if (this.binaryDoc) return this.binaryDoc\n\n    // Getting the byte array for the changes columns finalises their encoders, after which we can\n    // no longer append values to them. We therefore copy their data over to fresh encoders.\n    const newEncoders = this.changesEncoders.map(col => ({columnId: col.columnId, encoder: encoderByColumnId(col.columnId)}))\n    const decoders = this.changesEncoders.map(col => {\n      const decoder = decoderByColumnId(col.columnId, col.encoder.buffer)\n      return {columnId: col.columnId, decoder}\n    })\n    copyColumns(newEncoders, decoders, this.changes.length)\n\n    this.binaryDoc = encodeDocumentHeader({\n      changesColumns: this.changesEncoders,\n      opsColumns: concatBlocks(this.blocks),\n      actorIds: this.actorIds, // TODO: sort actorIds (requires transforming all actorId columns in opsColumns)\n      heads: this.heads,\n      headsIndexes: this.heads.map(hash => this.changeIndexByHash[hash]),\n      extraBytes: this.extraBytes\n    })\n    this.changesEncoders = newEncoders\n    return this.binaryDoc\n  }\n\n  /**\n   * Returns a patch from which we can initialise the current state of the backend.\n   */\n  getPatch() {\n    const objectMeta = {_root: {parentObj: null, parentKey: null, opId: null, type: 'map', children: {}}}\n    const docState = {blocks: this.blocks, actorIds: this.actorIds, objectMeta, maxOp: 0}\n    const diffs = this.initPatch ? this.initPatch : documentPatch(docState)\n    return {\n      maxOp: this.maxOp, clock: this.clock, deps: this.heads,\n      pendingChanges: this.queue.length, diffs\n    }\n  }\n}\n\nmodule.exports = { MAX_BLOCK_SIZE, BackendDoc, bloomFilterContains }\n","/**\n * Implementation of the data synchronisation protocol that brings a local and a remote document\n * into the same state. This is typically used when two nodes have been disconnected for some time,\n * and need to exchange any changes that happened while they were disconnected. The two nodes that\n * are syncing could be client and server, or server and client, or two peers with symmetric roles.\n *\n * The protocol is based on this paper: Martin Kleppmann and Heidi Howard. Byzantine Eventual\n * Consistency and the Fundamental Limits of Peer-to-Peer Databases. https://arxiv.org/abs/2012.00472\n *\n * The protocol assumes that every time a node successfully syncs with another node, it remembers\n * the current heads (as returned by `Backend.getHeads()`) after the last sync with that node. The\n * next time we try to sync with the same node, we start from the assumption that the other node's\n * document version is no older than the outcome of the last sync, so we only need to exchange any\n * changes that are more recent than the last sync. This assumption may not be true if the other\n * node did not correctly persist its state (perhaps it crashed before writing the result of the\n * last sync to disk), and we fall back to sending the entire document in this case.\n */\n\nconst Backend = require('./backend')\nconst { hexStringToBytes, bytesToHexString, Encoder, Decoder } = require('./encoding')\nconst { decodeChangeMeta } = require('./columnar')\nconst { copyObject } = require('../src/common')\n\nconst HASH_SIZE = 32 // 256 bits = 32 bytes\nconst MESSAGE_TYPE_SYNC = 0x42 // first byte of a sync message, for identification\nconst PEER_STATE_TYPE = 0x43 // first byte of an encoded peer state, for identification\n\n// These constants correspond to a 1% false positive rate. The values can be changed without\n// breaking compatibility of the network protocol, since the parameters used for a particular\n// Bloom filter are encoded in the wire format.\nconst BITS_PER_ENTRY = 10, NUM_PROBES = 7\n\n/**\n * A Bloom filter implementation that can be serialised to a byte array for transmission\n * over a network. The entries that are added are assumed to already be SHA-256 hashes,\n * so this implementation does not perform its own hashing.\n */\nclass BloomFilter {\n  constructor (arg) {\n    if (Array.isArray(arg)) {\n      // arg is an array of SHA256 hashes in hexadecimal encoding\n      this.numEntries = arg.length\n      this.numBitsPerEntry = BITS_PER_ENTRY\n      this.numProbes = NUM_PROBES\n      this.bits = new Uint8Array(Math.ceil(this.numEntries * this.numBitsPerEntry / 8))\n      for (let hash of arg) this.addHash(hash)\n    } else if (arg instanceof Uint8Array) {\n      if (arg.byteLength === 0) {\n        this.numEntries = 0\n        this.numBitsPerEntry = 0\n        this.numProbes = 0\n        this.bits = arg\n      } else {\n        const decoder = new Decoder(arg)\n        this.numEntries = decoder.readUint32()\n        this.numBitsPerEntry = decoder.readUint32()\n        this.numProbes = decoder.readUint32()\n        this.bits = decoder.readRawBytes(Math.ceil(this.numEntries * this.numBitsPerEntry / 8))\n      }\n    } else {\n      throw new TypeError('invalid argument')\n    }\n  }\n\n  /**\n   * Returns the Bloom filter state, encoded as a byte array.\n   */\n  get bytes() {\n    if (this.numEntries === 0) return new Uint8Array(0)\n    const encoder = new Encoder()\n    encoder.appendUint32(this.numEntries)\n    encoder.appendUint32(this.numBitsPerEntry)\n    encoder.appendUint32(this.numProbes)\n    encoder.appendRawBytes(this.bits)\n    return encoder.buffer\n  }\n\n  /**\n   * Given a SHA-256 hash (as hex string), returns an array of probe indexes indicating which bits\n   * in the Bloom filter need to be tested or set for this particular entry. We do this by\n   * interpreting the first 12 bytes of the hash as three little-endian 32-bit unsigned integers,\n   * and then using triple hashing to compute the probe indexes. The algorithm comes from:\n   *\n   * Peter C. Dillinger and Panagiotis Manolios. Bloom Filters in Probabilistic Verification.\n   * 5th International Conference on Formal Methods in Computer-Aided Design (FMCAD), November 2004.\n   * http://www.ccis.northeastern.edu/home/pete/pub/bloom-filters-verification.pdf\n   */\n  getProbes(hash) {\n    const hashBytes = hexStringToBytes(hash), modulo = 8 * this.bits.byteLength\n    if (hashBytes.byteLength !== 32) throw new RangeError(`Not a 256-bit hash: ${hash}`)\n    // on the next three lines, the right shift means interpret value as unsigned\n    let x = ((hashBytes[0] | hashBytes[1] << 8 | hashBytes[2]  << 16 | hashBytes[3]  << 24) >>> 0) % modulo\n    let y = ((hashBytes[4] | hashBytes[5] << 8 | hashBytes[6]  << 16 | hashBytes[7]  << 24) >>> 0) % modulo\n    let z = ((hashBytes[8] | hashBytes[9] << 8 | hashBytes[10] << 16 | hashBytes[11] << 24) >>> 0) % modulo\n    const probes = [x]\n    for (let i = 1; i < this.numProbes; i++) {\n      x = (x + y) % modulo\n      y = (y + z) % modulo\n      probes.push(x)\n    }\n    return probes\n  }\n\n  /**\n   * Sets the Bloom filter bits corresponding to a given SHA-256 hash (given as hex string).\n   */\n  addHash(hash) {\n    for (let probe of this.getProbes(hash)) {\n      this.bits[probe >>> 3] |= 1 << (probe & 7)\n    }\n  }\n\n  /**\n   * Tests whether a given SHA-256 hash (given as hex string) is contained in the Bloom filter.\n   */\n  containsHash(hash) {\n    if (this.numEntries === 0) return false\n    for (let probe of this.getProbes(hash)) {\n      if ((this.bits[probe >>> 3] & (1 << (probe & 7))) === 0) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n/**\n * Encodes a sorted array of SHA-256 hashes (as hexadecimal strings) into a byte array.\n */\nfunction encodeHashes(encoder, hashes) {\n  if (!Array.isArray(hashes)) throw new TypeError('hashes must be an array')\n  encoder.appendUint32(hashes.length)\n  for (let i = 0; i < hashes.length; i++) {\n    if (i > 0 && hashes[i - 1] >= hashes[i]) throw new RangeError('hashes must be sorted')\n    const bytes = hexStringToBytes(hashes[i])\n    if (bytes.byteLength !== HASH_SIZE) throw new TypeError('heads hashes must be 256 bits')\n    encoder.appendRawBytes(bytes)\n  }\n}\n\n/**\n * Decodes a byte array in the format returned by encodeHashes(), and returns its content as an\n * array of hex strings.\n */\nfunction decodeHashes(decoder) {\n  let length = decoder.readUint32(), hashes = []\n  for (let i = 0; i < length; i++) {\n    hashes.push(bytesToHexString(decoder.readRawBytes(HASH_SIZE)))\n  }\n  return hashes\n}\n\n/**\n * Takes a sync message of the form `{heads, need, have, changes}` and encodes it as a byte array for\n * transmission.\n */\nfunction encodeSyncMessage(message) {\n  const encoder = new Encoder()\n  encoder.appendByte(MESSAGE_TYPE_SYNC)\n  encodeHashes(encoder, message.heads)\n  encodeHashes(encoder, message.need)\n  encoder.appendUint32(message.have.length)\n  for (let have of message.have) {\n    encodeHashes(encoder, have.lastSync)\n    encoder.appendPrefixedBytes(have.bloom)\n  }\n  encoder.appendUint32(message.changes.length)\n  for (let change of message.changes) {\n    encoder.appendPrefixedBytes(change)\n  }\n  return encoder.buffer\n}\n\n/**\n * Takes a binary-encoded sync message and decodes it into the form `{heads, need, have, changes}`.\n */\nfunction decodeSyncMessage(bytes) {\n  const decoder = new Decoder(bytes)\n  const messageType = decoder.readByte()\n  if (messageType !== MESSAGE_TYPE_SYNC) {\n    throw new RangeError(`Unexpected message type: ${messageType}`)\n  }\n  const heads = decodeHashes(decoder)\n  const need = decodeHashes(decoder)\n  const haveCount = decoder.readUint32()\n  let message = {heads, need, have: [], changes: []}\n  for (let i = 0; i < haveCount; i++) {\n    const lastSync = decodeHashes(decoder)\n    const bloom = decoder.readPrefixedBytes(decoder)\n    message.have.push({lastSync, bloom})\n  }\n  const changeCount = decoder.readUint32()\n  for (let i = 0; i < changeCount; i++) {\n    const change = decoder.readPrefixedBytes()\n    message.changes.push(change)\n  }\n  // Ignore any trailing bytes -- they can be used for extensions by future versions of the protocol\n  return message\n}\n\n/**\n * Takes a SyncState and encodes as a byte array those parts of the state that should persist across\n * an application restart or disconnect and reconnect. The ephemeral parts of the state that should\n * be cleared on reconnect are not encoded.\n */\nfunction encodeSyncState(syncState) {\n  const encoder = new Encoder()\n  encoder.appendByte(PEER_STATE_TYPE)\n  encodeHashes(encoder, syncState.sharedHeads)\n  return encoder.buffer\n}\n\n/**\n * Takes a persisted peer state as encoded by `encodeSyncState` and decodes it into a SyncState\n * object. The parts of the peer state that were not encoded are initialised with default values.\n */\nfunction decodeSyncState(bytes) {\n  const decoder = new Decoder(bytes)\n  const recordType = decoder.readByte()\n  if (recordType !== PEER_STATE_TYPE) {\n    throw new RangeError(`Unexpected record type: ${recordType}`)\n  }\n  const sharedHeads = decodeHashes(decoder)\n  return Object.assign(initSyncState(), { sharedHeads })\n}\n\n/**\n * Constructs a Bloom filter containing all changes that are not one of the hashes in\n * `lastSync` or its transitive dependencies. In other words, the filter contains those\n * changes that have been applied since the version identified by `lastSync`. Returns\n * an object of the form `{lastSync, bloom}` as required for the `have` field of a sync\n * message.\n */\nfunction makeBloomFilter(backend, lastSync) {\n  const newChanges = Backend.getChanges(backend, lastSync)\n  const hashes = newChanges.map(change => decodeChangeMeta(change, true).hash)\n  return {lastSync, bloom: new BloomFilter(hashes).bytes}\n}\n\n/**\n * Call this function when a sync message is received from another node. The `message` argument\n * needs to already have been decoded using `decodeSyncMessage()`. This function determines the\n * changes that we need to send to the other node in response. Returns an array of changes (as\n * byte arrays).\n */\nfunction getChangesToSend(backend, have, need) {\n  if (have.length === 0) {\n    return need.map(hash => Backend.getChangeByHash(backend, hash)).filter(change => change !== undefined)\n  }\n\n  let lastSyncHashes = {}, bloomFilters = []\n  for (let h of have) {\n    for (let hash of h.lastSync) lastSyncHashes[hash] = true\n    bloomFilters.push(new BloomFilter(h.bloom))\n  }\n\n  // Get all changes that were added since the last sync\n  const changes = Backend.getChanges(backend, Object.keys(lastSyncHashes))\n    .map(change => decodeChangeMeta(change, true))\n\n  let changeHashes = {}, dependents = {}, hashesToSend = {}\n  for (let change of changes) {\n    changeHashes[change.hash] = true\n\n    // For each change, make a list of changes that depend on it\n    for (let dep of change.deps) {\n      if (!dependents[dep]) dependents[dep] = []\n      dependents[dep].push(change.hash)\n    }\n\n    // Exclude any change hashes contained in one or more Bloom filters\n    if (bloomFilters.every(bloom => !bloom.containsHash(change.hash))) {\n      hashesToSend[change.hash] = true\n    }\n  }\n\n  // Include any changes that depend on a Bloom-negative change\n  let stack = Object.keys(hashesToSend)\n  while (stack.length > 0) {\n    const hash = stack.pop()\n    if (dependents[hash]) {\n      for (let dep of dependents[hash]) {\n        if (!hashesToSend[dep]) {\n          hashesToSend[dep] = true\n          stack.push(dep)\n        }\n      }\n    }\n  }\n\n  // Include any explicitly requested changes\n  let changesToSend = []\n  for (let hash of need) {\n    hashesToSend[hash] = true\n    if (!changeHashes[hash]) { // Change is not among those returned by getMissingChanges()?\n      const change = Backend.getChangeByHash(backend, hash)\n      if (change) changesToSend.push(change)\n    }\n  }\n\n  // Return changes in the order they were returned by getMissingChanges()\n  for (let change of changes) {\n    if (hashesToSend[change.hash]) changesToSend.push(change.change)\n  }\n  return changesToSend\n}\n\nfunction initSyncState() {\n  return {\n    sharedHeads: [],\n    lastSentHeads: [],\n    theirHeads: null,\n    theirNeed: null,\n    theirHave: null,\n    sentHashes: {},\n  }\n}\n\nfunction compareArrays(a, b) {\n    return (a.length === b.length) && a.every((v, i) => v === b[i])\n}\n\n/**\n * Given a backend and what we believe to be the state of our peer, generate a message which tells\n * them about we have and includes any changes we believe they need\n */\nfunction generateSyncMessage(backend, syncState) {\n  if (!backend) {\n    throw new Error(\"generateSyncMessage called with no Automerge document\")\n  }\n  if (!syncState) {\n    throw new Error(\"generateSyncMessage requires a syncState, which can be created with initSyncState()\")\n  }\n\n  let { sharedHeads, lastSentHeads, theirHeads, theirNeed, theirHave, sentHashes } = syncState\n  const ourHeads = Backend.getHeads(backend)\n\n  // Hashes to explicitly request from the remote peer: any missing dependencies of unapplied\n  // changes, and any of the remote peer's heads that we don't know about\n  const ourNeed = Backend.getMissingDeps(backend, theirHeads || [])\n\n  // There are two reasons why ourNeed may be nonempty: 1. we might be missing dependencies due to\n  // Bloom filter false positives; 2. we might be missing heads that the other peer mentioned\n  // because they (intentionally) only sent us a subset of changes. In case 1, we leave the `have`\n  // field of the message empty because we just want to fill in the missing dependencies for now.\n  // In case 2, or if ourNeed is empty, we send a Bloom filter to request any unsent changes.\n  let ourHave = []\n  if (!theirHeads || ourNeed.every(hash => theirHeads.includes(hash))) {\n    ourHave = [makeBloomFilter(backend, sharedHeads)]\n  }\n\n  // Fall back to a full re-sync if the sender's last sync state includes hashes\n  // that we don't know. This could happen if we crashed after the last sync and\n  // failed to persist changes that the other node already sent us.\n  if (theirHave && theirHave.length > 0) {\n    const lastSync = theirHave[0].lastSync\n    if (!lastSync.every(hash => Backend.getChangeByHash(backend, hash))) {\n      // we need to queue them to send us a fresh sync message, the one they sent is uninteligible so we don't know what they need\n      const resetMsg = {heads: ourHeads, need: [], have: [{ lastSync: [], bloom: new Uint8Array(0) }], changes: []}\n      return [syncState, encodeSyncMessage(resetMsg)]\n    }\n  }\n\n  // XXX: we should limit ourselves to only sending a subset of all the messages, probably limited by a total message size\n  //      these changes should ideally be RLE encoded but we haven't implemented that yet.\n  let changesToSend = Array.isArray(theirHave) && Array.isArray(theirNeed) ? getChangesToSend(backend, theirHave, theirNeed) : []\n\n  // If the heads are equal, we're in sync and don't need to do anything further\n  const headsUnchanged = Array.isArray(lastSentHeads) && compareArrays(ourHeads, lastSentHeads)\n  const headsEqual = Array.isArray(theirHeads) && compareArrays(ourHeads, theirHeads)\n  if (headsUnchanged && headsEqual && changesToSend.length === 0) {\n    // no need to send a sync message if we know we're synced!\n    return [syncState, null]\n  }\n\n  // TODO: this recomputes the SHA-256 hash of each change; we should restructure this to avoid the\n  // unnecessary recomputation\n  changesToSend = changesToSend.filter(change => !sentHashes[decodeChangeMeta(change, true).hash])\n\n  // Regular response to a sync message: send any changes that the other node\n  // doesn't have. We leave the \"have\" field empty because the previous message\n  // generated by `syncStart` already indicated what changes we have.\n  const syncMessage = {heads: ourHeads, have: ourHave, need: ourNeed, changes: changesToSend}\n  if (changesToSend.length > 0) {\n    sentHashes = copyObject(sentHashes)\n    for (const change of changesToSend) {\n      sentHashes[decodeChangeMeta(change, true).hash] = true\n    }\n  }\n\n  syncState = Object.assign({}, syncState, {lastSentHeads: ourHeads, sentHashes})\n  return [syncState, encodeSyncMessage(syncMessage)]\n}\n\n/**\n * Computes the heads that we share with a peer after we have just received some changes from that\n * peer and applied them. This may not be sufficient to bring our heads in sync with the other\n * peer's heads, since they may have only sent us a subset of their outstanding changes.\n *\n * `myOldHeads` are the local heads before the most recent changes were applied, `myNewHeads` are\n * the local heads after those changes were applied, and `ourOldSharedHeads` is the previous set of\n * shared heads. Applying the changes will have replaced some heads with others, but some heads may\n * have remained unchanged (because they are for branches on which no changes have been added). Any\n * such unchanged heads remain in the sharedHeads. Any sharedHeads that were replaced by applying\n * changes are also replaced as sharedHeads. This is safe because if we received some changes from\n * another peer, that means that peer had those changes, and therefore we now both know about them.\n */\nfunction advanceHeads(myOldHeads, myNewHeads, ourOldSharedHeads) {\n  const newHeads = myNewHeads.filter((head) => !myOldHeads.includes(head))\n  const commonHeads = ourOldSharedHeads.filter((head) => myNewHeads.includes(head))\n  const advancedHeads = [...new Set([...newHeads, ...commonHeads])].sort()\n  return advancedHeads\n}\n\n\n/**\n * Given a backend, a message message and the state of our peer, apply any changes, update what\n * we believe about the peer, and (if there were applied changes) produce a patch for the frontend\n */\nfunction receiveSyncMessage(backend, oldSyncState, binaryMessage) {\n  if (!backend) {\n    throw new Error(\"generateSyncMessage called with no Automerge document\")\n  }\n  if (!oldSyncState) {\n    throw new Error(\"generateSyncMessage requires a syncState, which can be created with initSyncState()\")\n  }\n\n  let { sharedHeads, lastSentHeads, sentHashes } = oldSyncState, patch = null\n  const message = decodeSyncMessage(binaryMessage)\n  const beforeHeads = Backend.getHeads(backend)\n\n  // If we received changes, we try to apply them to the document. There may still be missing\n  // dependencies due to Bloom filter false positives, in which case the backend will enqueue the\n  // changes without applying them. The set of changes may also be incomplete if the sender decided\n  // to break a large set of changes into chunks.\n  if (message.changes.length > 0) {\n    [backend, patch] = Backend.applyChanges(backend, message.changes)\n    sharedHeads = advanceHeads(beforeHeads, Backend.getHeads(backend), sharedHeads)\n  }\n\n  // If heads are equal, indicate we don't need to send a response message\n  if (message.changes.length === 0 && compareArrays(message.heads, beforeHeads)) {\n    lastSentHeads = message.heads\n  }\n\n  // If all of the remote heads are known to us, that means either our heads are equal, or we are\n  // ahead of the remote peer. In this case, take the remote heads to be our shared heads.\n  const knownHeads = message.heads.filter(head => Backend.getChangeByHash(backend, head))\n  if (knownHeads.length === message.heads.length) {\n    sharedHeads = message.heads\n    // If the remote peer has lost all its data, reset our state to perform a full resync\n    if (message.heads.length === 0) {\n      lastSentHeads = []\n      sentHashes = []\n    }\n  } else {\n    // If some remote heads are unknown to us, we add all the remote heads we know to\n    // sharedHeads, but don't remove anything from sharedHeads. This might cause sharedHeads to\n    // contain some redundant hashes (where one hash is actually a transitive dependency of\n    // another), but this will be cleared up as soon as we know all the remote heads.\n    sharedHeads = [...new Set(knownHeads.concat(sharedHeads))].sort()\n  }\n\n  const syncState = {\n    sharedHeads, // what we have in common to generate an efficient bloom filter\n    lastSentHeads,\n    theirHave: message.have, // the information we need to calculate the changes they need\n    theirHeads: message.heads,\n    theirNeed: message.need,\n    sentHashes\n  }\n  return [backend, syncState, patch]\n}\n\nmodule.exports = {\n  receiveSyncMessage, generateSyncMessage,\n  encodeSyncMessage, decodeSyncMessage,\n  initSyncState, encodeSyncState, decodeSyncState,\n  BloomFilter // BloomFilter is a private API, exported only for testing purposes\n}\n","function backendState(backend) {\n  if (backend.frozen) {\n    throw new Error(\n      'Attempting to use an outdated Automerge document that has already been updated. ' +\n      'Please use the latest document state, or call Automerge.clone() if you really ' +\n      'need to use this old document state.'\n    )\n  }\n  return backend.state\n}\n\nmodule.exports = {\n  backendState\n}\n","const { isObject, copyObject, parseOpId } = require('../src/common')\nconst { OBJECT_ID, CONFLICTS, ELEM_IDS } = require('./constants')\nconst { instantiateText } = require('./text')\nconst { instantiateTable } = require('./table')\nconst { Counter } = require('./counter')\n\n/**\n * Reconstructs the value from the patch object `patch`.\n */\nfunction getValue(patch, object, updated) {\n  if (patch.objectId) {\n    // If the objectId of the existing object does not match the objectId in the patch,\n    // that means the patch is replacing the object with a new one made from scratch\n    if (object && object[OBJECT_ID] !== patch.objectId) {\n      object = undefined\n    }\n    return interpretPatch(patch, object, updated)\n  } else if (patch.datatype === 'timestamp') {\n    // Timestamp: value is milliseconds since 1970 epoch\n    return new Date(patch.value)\n  } else if (patch.datatype === 'counter') {\n    return new Counter(patch.value)\n  } else {\n    // Primitive value (int, uint, float64, string, boolean, or null)\n    return patch.value\n  }\n}\n\n/**\n * Compares two strings, interpreted as Lamport timestamps of the form\n * 'counter@actorId'. Returns 1 if ts1 is greater, or -1 if ts2 is greater.\n */\nfunction lamportCompare(ts1, ts2) {\n  const regex = /^(\\d+)@(.*)$/\n  const time1 = regex.test(ts1) ? parseOpId(ts1) : {counter: 0, actorId: ts1}\n  const time2 = regex.test(ts2) ? parseOpId(ts2) : {counter: 0, actorId: ts2}\n  if (time1.counter < time2.counter) return -1\n  if (time1.counter > time2.counter) return  1\n  if (time1.actorId < time2.actorId) return -1\n  if (time1.actorId > time2.actorId) return  1\n  return 0\n}\n\n/**\n * `props` is an object of the form:\n * `{key1: {opId1: {...}, opId2: {...}}, key2: {opId3: {...}}}`\n * where the outer object is a mapping from property names to inner objects,\n * and the inner objects are a mapping from operation ID to sub-patch.\n * This function interprets that structure and updates the objects `object` and\n * `conflicts` to reflect it. For each key, the greatest opId (by Lamport TS\n * order) is chosen as the default resolution; that op's value is assigned\n * to `object[key]`. Moreover, all the opIds and values are packed into a\n * conflicts object of the form `{opId1: value1, opId2: value2}` and assigned\n * to `conflicts[key]`. If there is no conflict, the conflicts object contains\n * just a single opId-value mapping.\n */\nfunction applyProperties(props, object, conflicts, updated) {\n  if (!props) return\n\n  for (let key of Object.keys(props)) {\n    const values = {}, opIds = Object.keys(props[key]).sort(lamportCompare).reverse()\n    for (let opId of opIds) {\n      const subpatch = props[key][opId]\n      if (conflicts[key] && conflicts[key][opId]) {\n        values[opId] = getValue(subpatch, conflicts[key][opId], updated)\n      } else {\n        values[opId] = getValue(subpatch, undefined, updated)\n      }\n    }\n\n    if (opIds.length === 0) {\n      delete object[key]\n      delete conflicts[key]\n    } else {\n      object[key] = values[opIds[0]]\n      conflicts[key] = values\n    }\n  }\n}\n\n/**\n * Creates a writable copy of an immutable map object. If `originalObject`\n * is undefined, creates an empty object with ID `objectId`.\n */\nfunction cloneMapObject(originalObject, objectId) {\n  const object    = copyObject(originalObject)\n  const conflicts = copyObject(originalObject ? originalObject[CONFLICTS] : undefined)\n  Object.defineProperty(object, OBJECT_ID, {value: objectId})\n  Object.defineProperty(object, CONFLICTS, {value: conflicts})\n  return object\n}\n\n/**\n * Updates the map object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateMapObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = cloneMapObject(obj, objectId)\n  }\n\n  const object = updated[objectId]\n  applyProperties(patch.props, object, object[CONFLICTS], updated)\n  return object\n}\n\n/**\n * Updates the table object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateTableObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = obj ? obj._clone() : instantiateTable(objectId)\n  }\n\n  const object = updated[objectId]\n\n  for (let key of Object.keys(patch.props || {})) {\n    const opIds = Object.keys(patch.props[key])\n\n    if (opIds.length === 0) {\n      object.remove(key)\n    } else if (opIds.length === 1) {\n      const subpatch = patch.props[key][opIds[0]]\n      object._set(key, getValue(subpatch, object.byId(key), updated), opIds[0])\n    } else {\n      throw new RangeError('Conflicts are not supported on properties of a table')\n    }\n  }\n  return object\n}\n\n/**\n * Creates a writable copy of an immutable list object. If `originalList` is\n * undefined, creates an empty list with ID `objectId`.\n */\nfunction cloneListObject(originalList, objectId) {\n  const list = originalList ? originalList.slice() : [] // slice() makes a shallow clone\n  const conflicts = (originalList && originalList[CONFLICTS]) ? originalList[CONFLICTS].slice() : []\n  const elemIds = (originalList && originalList[ELEM_IDS]) ? originalList[ELEM_IDS].slice() : []\n  Object.defineProperty(list, OBJECT_ID, {value: objectId})\n  Object.defineProperty(list, CONFLICTS, {value: conflicts})\n  Object.defineProperty(list, ELEM_IDS,  {value: elemIds})\n  return list\n}\n\n/**\n * Updates the list object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateListObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  if (!updated[objectId]) {\n    updated[objectId] = cloneListObject(obj, objectId)\n  }\n\n  const list = updated[objectId], conflicts = list[CONFLICTS], elemIds = list[ELEM_IDS]\n  for (let i = 0; i < patch.edits.length; i++) {\n    const edit = patch.edits[i]\n\n    if (edit.action === 'insert' || edit.action === 'update') {\n      const oldValue = conflicts[edit.index] && conflicts[edit.index][edit.opId]\n      let lastValue = getValue(edit.value, oldValue, updated)\n      let values = {[edit.opId]: lastValue}\n\n      // Successive updates for the same index are an indication of a conflict on that list element.\n      // Edits are sorted in increasing order by Lamport timestamp, so the last value (with the\n      // greatest timestamp) is the default resolution of the conflict.\n      while (i < patch.edits.length - 1 && patch.edits[i + 1].index === edit.index &&\n             patch.edits[i + 1].action === 'update') {\n        i++\n        const conflict = patch.edits[i]\n        const oldValue2 = conflicts[conflict.index] && conflicts[conflict.index][conflict.opId]\n        lastValue = getValue(conflict.value, oldValue2, updated)\n        values[conflict.opId] = lastValue\n      }\n\n      if (edit.action === 'insert') {\n        list.splice(edit.index, 0, lastValue)\n        conflicts.splice(edit.index, 0, values)\n        elemIds.splice(edit.index, 0, edit.elemId)\n      } else {\n        list[edit.index] = lastValue\n        conflicts[edit.index] = values\n      }\n\n    } else if (edit.action === 'multi-insert') {\n      const startElemId = parseOpId(edit.elemId), newElems = [], newValues = [], newConflicts = []\n      const datatype = edit.datatype\n      edit.values.forEach((value, index) => {\n        const elemId = `${startElemId.counter + index}@${startElemId.actorId}`\n        value = getValue({ value, datatype }, undefined, updated)\n        newValues.push(value)\n        newConflicts.push({[elemId]: {value, datatype, type: 'value'}})\n        newElems.push(elemId)\n      })\n      list.splice(edit.index, 0, ...newValues)\n      conflicts.splice(edit.index, 0, ...newConflicts)\n      elemIds.splice(edit.index, 0, ...newElems)\n\n    } else if (edit.action === 'remove') {\n      list.splice(edit.index, edit.count)\n      conflicts.splice(edit.index, edit.count)\n      elemIds.splice(edit.index, edit.count)\n    }\n  }\n  return list\n}\n\n/**\n * Updates the text object `obj` according to the modifications described in\n * `patch`, or creates a new object if `obj` is undefined. Mutates `updated`\n * to map the objectId to the new object, and returns the new object.\n */\nfunction updateTextObject(patch, obj, updated) {\n  const objectId = patch.objectId\n  let elems\n  if (updated[objectId]) {\n    elems = updated[objectId].elems\n  } else if (obj) {\n    elems = obj.elems.slice()\n  } else {\n    elems = []\n  }\n\n  for (const edit of patch.edits) {\n    if (edit.action === 'insert') {\n      const value = getValue(edit.value, undefined, updated)\n      const elem = {elemId: edit.elemId, pred: [edit.opId], value}\n      elems.splice(edit.index, 0, elem)\n\n    } else if (edit.action === 'multi-insert') {\n      const startElemId = parseOpId(edit.elemId)\n      const datatype = edit.datatype\n      const newElems = edit.values.map((value, index) => {\n        value = getValue({ datatype, value }, undefined, updated)\n        const elemId = `${startElemId.counter + index}@${startElemId.actorId}`\n        return {elemId, pred: [elemId], value}\n      })\n      elems.splice(edit.index, 0, ...newElems)\n\n    } else if (edit.action === 'update') {\n      const elemId = elems[edit.index].elemId\n      const value = getValue(edit.value, elems[edit.index].value, updated)\n      elems[edit.index] = {elemId, pred: [edit.opId], value}\n\n    } else if (edit.action === 'remove') {\n      elems.splice(edit.index, edit.count)\n    }\n  }\n\n  updated[objectId] = instantiateText(objectId, elems)\n  return updated[objectId]\n}\n\n/**\n * Applies the patch object `patch` to the read-only document object `obj`.\n * Clones a writable copy of `obj` and places it in `updated` (indexed by\n * objectId), if that has not already been done. Returns the updated object.\n */\nfunction interpretPatch(patch, obj, updated) {\n  // Return original object if it already exists and isn't being modified\n  if (isObject(obj) && (!patch.props || Object.keys(patch.props).length === 0) &&\n      (!patch.edits || patch.edits.length === 0) && !updated[patch.objectId]) {\n    return obj\n  }\n\n  if (patch.type === 'map') {\n    return updateMapObject(patch, obj, updated)\n  } else if (patch.type === 'table') {\n    return updateTableObject(patch, obj, updated)\n  } else if (patch.type === 'list') {\n    return updateListObject(patch, obj, updated)\n  } else if (patch.type === 'text') {\n    return updateTextObject(patch, obj, updated)\n  } else {\n    throw new TypeError(`Unknown object type: ${patch.type}`)\n  }\n}\n\n/**\n * Creates a writable copy of the immutable document root object `root`.\n */\nfunction cloneRootObject(root) {\n  if (root[OBJECT_ID] !== '_root') {\n    throw new RangeError(`Not the root object: ${root[OBJECT_ID]}`)\n  }\n  return cloneMapObject(root, '_root')\n}\n\nmodule.exports = {\n  interpretPatch, cloneRootObject\n}\n","// Properties of the document root object\nconst OPTIONS   = Symbol('_options')   // object containing options passed to init()\nconst CACHE     = Symbol('_cache')     // map from objectId to immutable object\nconst STATE     = Symbol('_state')     // object containing metadata about current state (e.g. sequence numbers)\n\n// Properties of all Automerge objects\nconst OBJECT_ID = Symbol('_objectId')  // the object ID of the current object (string)\nconst CONFLICTS = Symbol('_conflicts') // map or list (depending on object type) of conflicts\nconst CHANGE    = Symbol('_change')    // the context object on proxy objects used in change callback\nconst ELEM_IDS  = Symbol('_elemIds')   // list containing the element ID of each list element\n\nmodule.exports = {\n  OPTIONS, CACHE, STATE, OBJECT_ID, CONFLICTS, CHANGE, ELEM_IDS\n}\n","const { CACHE, OBJECT_ID, CONFLICTS, ELEM_IDS, STATE } = require('./constants')\nconst { interpretPatch } = require('./apply_patch')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\nconst { Counter, getWriteableCounter } = require('./counter')\nconst { Int, Uint, Float64 } = require('./numbers')\nconst { isObject, parseOpId, createArrayOfNulls } = require('../src/common')\nconst uuid = require('../src/uuid')\n\n\n/**\n * An instance of this class is passed to `rootObjectProxy()`. The methods are\n * called by proxy object mutation functions to query the current object state\n * and to apply the requested changes.\n */\nclass Context {\n  constructor (doc, actorId, applyPatch) {\n    this.actorId = actorId\n    this.nextOpNum = doc[STATE].maxOp + 1\n    this.cache = doc[CACHE]\n    this.updated = {}\n    this.ops = []\n    this.applyPatch = applyPatch ? applyPatch : interpretPatch\n  }\n\n  /**\n   * Adds an operation object to the list of changes made in the current context.\n   */\n  addOp(operation) {\n    this.ops.push(operation)\n\n    if (operation.action === 'set' && operation.values) {\n      this.nextOpNum += operation.values.length\n    } else if (operation.action === 'del' && operation.multiOp) {\n      this.nextOpNum += operation.multiOp\n    } else {\n      this.nextOpNum += 1\n    }\n  }\n\n  /**\n   * Returns the operation ID of the next operation to be added to the context.\n   */\n  nextOpId() {\n    return `${this.nextOpNum}@${this.actorId}`\n  }\n\n  /**\n   * Takes a value and returns an object describing the value (in the format used by patches).\n   */\n  getValueDescription(value) {\n    if (!['object', 'boolean', 'number', 'string'].includes(typeof value)) {\n      throw new TypeError(`Unsupported type of value: ${typeof value}`)\n    }\n\n    if (isObject(value)) {\n      if (value instanceof Date) {\n        // Date object, represented as milliseconds since epoch\n        return {type: 'value', value: value.getTime(), datatype: 'timestamp'}\n\n      } else if (value instanceof Int) {\n        return {type: 'value', value: value.value, datatype: 'int'}\n      } else if (value instanceof Uint) {\n        return {type: 'value', value: value.value, datatype: 'uint'}\n      } else if (value instanceof Float64) {\n        return {type: 'value', value: value.value, datatype: 'float64'}\n      } else if (value instanceof Counter) {\n        // Counter object\n        return {type: 'value', value: value.value, datatype: 'counter'}\n\n      } else {\n        // Nested object (map, list, text, or table)\n        const objectId = value[OBJECT_ID], type = this.getObjectType(objectId)\n        if (!objectId) {\n          throw new RangeError(`Object ${JSON.stringify(value)} has no objectId`)\n        }\n        if (type === 'list' || type === 'text') {\n          return {objectId, type, edits: []}\n        } else {\n          return {objectId, type, props: {}}\n        }\n      }\n    } else if (typeof value === 'number') {\n      if (Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER) {\n        return {type: 'value', value, datatype: 'int'}\n      } else {\n        return {type: 'value', value, datatype: 'float64'}\n      }\n    } else {\n      // Primitive value (string, boolean, or null)\n      return {type: 'value', value}\n    }\n  }\n\n  /**\n   * Builds the values structure describing a single property in a patch. Finds all the values of\n   * property `key` of `object` (there might be multiple values in the case of a conflict), and\n   * returns an object that maps operation IDs to descriptions of values.\n   */\n  getValuesDescriptions(path, object, key) {\n    if (object instanceof Table) {\n      // Table objects don't have conflicts, since rows are identified by their unique objectId\n      const value = object.byId(key)\n      const opId = object.opIds[key]\n      return value ? {[opId]: this.getValueDescription(value)} : {}\n    } else if (object instanceof Text) {\n      // Text objects don't support conflicts\n      const value = object.get(key)\n      const elemId = object.getElemId(key)\n      return value ? {[elemId]: this.getValueDescription(value)} : {}\n    } else {\n      // Map or list objects\n      const conflicts = object[CONFLICTS][key], values = {}\n      if (!conflicts) {\n        throw new RangeError(`No children at key ${key} of path ${JSON.stringify(path)}`)\n      }\n      for (let opId of Object.keys(conflicts)) {\n        values[opId] = this.getValueDescription(conflicts[opId])\n      }\n      return values\n    }\n  }\n\n  /**\n   * Returns the value at property `key` of object `object`. In the case of a conflict, returns\n   * the value whose assignment operation has the ID `opId`.\n   */\n  getPropertyValue(object, key, opId) {\n    if (object instanceof Table) {\n      return object.byId(key)\n    } else if (object instanceof Text) {\n      return object.get(key)\n    } else {\n      return object[CONFLICTS][key][opId]\n    }\n  }\n\n  /**\n   * Recurses along `path` into the patch object `patch`, creating nodes along the way as needed\n   * by mutating the patch object. Returns the subpatch at the given path.\n   */\n  getSubpatch(patch, path) {\n    if (path.length == 0) return patch\n    let subpatch = patch, object = this.getObject('_root')\n\n    for (let pathElem of path) {\n      let values = this.getValuesDescriptions(path, object, pathElem.key)\n      if (subpatch.props) {\n        if (!subpatch.props[pathElem.key]) {\n          subpatch.props[pathElem.key] = values\n        }\n      } else if (subpatch.edits) {\n        for (const opId of Object.keys(values)) {\n          subpatch.edits.push({action: 'update', index: pathElem.key, opId, value: values[opId]})\n        }\n      }\n\n      let nextOpId = null\n      for (let opId of Object.keys(values)) {\n        if (values[opId].objectId === pathElem.objectId) {\n          nextOpId = opId\n        }\n      }\n      if (!nextOpId) {\n        throw new RangeError(`Cannot find path object with objectId ${pathElem.objectId}`)\n      }\n\n      subpatch = values[nextOpId]\n      object = this.getPropertyValue(object, pathElem.key, nextOpId)\n    }\n\n    return subpatch\n  }\n\n  /**\n   * Returns an object (not proxied) from the cache or updated set, as appropriate.\n   */\n  getObject(objectId) {\n    const object = this.updated[objectId] || this.cache[objectId]\n    if (!object) throw new RangeError(`Target object does not exist: ${objectId}`)\n    return object\n  }\n\n  /**\n   * Returns a string that is either 'map', 'table', 'list', or 'text', indicating\n   * the type of the object with ID `objectId`.\n   */\n  getObjectType(objectId) {\n    if (objectId === '_root') return 'map'\n    const object = this.getObject(objectId)\n    if (object instanceof Text) return 'text'\n    if (object instanceof Table) return 'table'\n    if (Array.isArray(object)) return 'list'\n    return 'map'\n  }\n\n  /**\n   * Returns the value associated with the property named `key` on the object\n   * at path `path`. If the value is an object, returns a proxy for it.\n   */\n  getObjectField(path, objectId, key) {\n    if (!['string', 'number'].includes(typeof key)) return\n    const object = this.getObject(objectId)\n\n    if (object[key] instanceof Counter) {\n      return getWriteableCounter(object[key].value, this, path, objectId, key)\n\n    } else if (isObject(object[key])) {\n      const childId = object[key][OBJECT_ID]\n      const subpath = path.concat([{key, objectId: childId}])\n      // The instantiateObject function is added to the context object by rootObjectProxy()\n      return this.instantiateObject(subpath, childId)\n\n    } else {\n      return object[key]\n    }\n  }\n\n  /**\n   * Recursively creates Automerge versions of all the objects and nested objects in `value`,\n   * constructing a patch and operations that describe the object tree. The new object is\n   * assigned to the property `key` in the object with ID `obj`. If the object is a list or\n   * text, `key` must be set to the list index being updated, and `elemId` must be set to the\n   * elemId of the element being updated. If `insert` is true, we insert a new list element\n   * (or text character) at index `key`, and `elemId` must be the elemId of the immediate\n   * predecessor element (or the string '_head' if inserting at index 0). If the assignment\n   * overwrites a previous value at this key/element, `pred` must be set to the array of the\n   * prior operations we are overwriting (empty array if there is no existing value).\n   */\n  createNestedObjects(obj, key, value, insert, pred, elemId) {\n    if (value[OBJECT_ID]) {\n      throw new RangeError('Cannot create a reference to an existing document object')\n    }\n    const objectId = this.nextOpId()\n\n    if (value instanceof Text) {\n      // Create a new Text object\n      this.addOp(elemId ? {action: 'makeText', obj, elemId, insert, pred}\n                        : {action: 'makeText', obj, key, insert, pred})\n      const subpatch = {objectId, type: 'text', edits: []}\n      this.insertListItems(subpatch, 0, [...value], true)\n      return subpatch\n\n    } else if (value instanceof Table) {\n      // Create a new Table object\n      if (value.count > 0) {\n        throw new RangeError('Assigning a non-empty Table object is not supported')\n      }\n      this.addOp(elemId ? {action: 'makeTable', obj, elemId, insert, pred}\n                        : {action: 'makeTable', obj, key, insert, pred})\n      return {objectId, type: 'table', props: {}}\n\n    } else if (Array.isArray(value)) {\n      // Create a new list object\n      this.addOp(elemId ? {action: 'makeList', obj, elemId, insert, pred}\n                        : {action: 'makeList', obj, key, insert, pred})\n      const subpatch = {objectId, type: 'list', edits: []}\n      this.insertListItems(subpatch, 0, value, true)\n      return subpatch\n\n    } else {\n      // Create a new map object\n      this.addOp(elemId ? {action: 'makeMap', obj, elemId, insert, pred}\n                        : {action: 'makeMap', obj, key, insert, pred})\n      let props = {}\n      for (let nested of Object.keys(value).sort()) {\n        const opId = this.nextOpId()\n        const valuePatch = this.setValue(objectId, nested, value[nested], false, [])\n        props[nested] = {[opId]: valuePatch}\n      }\n      return {objectId, type: 'map', props}\n    }\n  }\n\n  /**\n   * Records an assignment to a particular key in a map, or a particular index in a list.\n   * `objectId` is the ID of the object being modified, `key` is the property name or list\n   * index being updated, and `value` is the new value being assigned. If `insert` is true,\n   * a new list element is inserted at index `key`, and `value` is assigned to that new list\n   * element. `pred` is an array of opIds for previous values of the property being assigned,\n   * which are overwritten by this operation. If the object being modified is a list or text,\n   * `elemId` is the element ID of the list element being updated (if insert=false), or the\n   * element ID of the list element immediately preceding the insertion (if insert=true).\n   *\n   * Returns a patch describing the new value. The return value is of the form\n   * `{objectId, type, props}` if `value` is an object, or `{value, datatype}` if it is a\n   * primitive value. For string, number, boolean, or null the datatype is omitted.\n   */\n  setValue(objectId, key, value, insert, pred, elemId) {\n    if (!objectId) {\n      throw new RangeError('setValue needs an objectId')\n    }\n    if (key === '') {\n      throw new RangeError('The key of a map entry must not be an empty string')\n    }\n\n    if (isObject(value) && !(value instanceof Date) && !(value instanceof Counter) && !(value instanceof Int) && !(value instanceof Uint) && !(value instanceof Float64)) {\n      // Nested object (map, list, text, or table)\n      return this.createNestedObjects(objectId, key, value, insert, pred, elemId)\n    } else {\n      // Date or counter object, or primitive value (number, string, boolean, or null)\n      const description = this.getValueDescription(value)\n      const op = {action: 'set', obj: objectId, insert, value: description.value, pred}\n      if (elemId) op.elemId = elemId; else op.key = key\n      if (description.datatype) op.datatype = description.datatype\n      this.addOp(op)\n      return description\n    }\n  }\n\n  /**\n   * Constructs a new patch, calls `callback` with the subpatch at the location `path`,\n   * and then immediately applies the patch to the document.\n   */\n  applyAtPath(path, callback) {\n    let diff = {objectId: '_root', type: 'map', props: {}}\n    callback(this.getSubpatch(diff, path))\n    this.applyPatch(diff, this.cache._root, this.updated)\n  }\n\n  /**\n   * Updates the map object at path `path`, setting the property with name\n   * `key` to `value`.\n   */\n  setMapKey(path, key, value) {\n    if (typeof key !== 'string') {\n      throw new RangeError(`The key of a map entry must be a string, not ${typeof key}`)\n    }\n\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n    if (object[key] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.')\n    }\n\n    // If the assigned field value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n    if (object[key] !== value || Object.keys(object[CONFLICTS][key] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const pred = getPred(object, key)\n        const opId = this.nextOpId()\n        const valuePatch = this.setValue(objectId, key, value, false, pred)\n        subpatch.props[key] = {[opId]: valuePatch}\n      })\n    }\n  }\n\n  /**\n   * Updates the map object at path `path`, deleting the property `key`.\n   */\n  deleteMapKey(path, key) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n\n    if (object[key] !== undefined) {\n      const pred = getPred(object, key)\n      this.addOp({action: 'del', obj: objectId, key, insert: false, pred})\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[key] = {}\n      })\n    }\n  }\n\n  /**\n   * Inserts a sequence of new list elements `values` into a list, starting at position `index`.\n   * `newObject` is true if we are creating a new list object, and false if we are updating an\n   * existing one. `subpatch` is the patch for the list object being modified. Mutates\n   * `subpatch` to reflect the sequence of values.\n   */\n  insertListItems(subpatch, index, values, newObject) {\n    const list = newObject ? [] : this.getObject(subpatch.objectId)\n    if (index < 0 || index > list.length) {\n      throw new RangeError(`List index ${index} is out of bounds for list of length ${list.length}`)\n    }\n    if (values.length === 0) return\n\n    let elemId = getElemId(list, index, true)\n    const allPrimitive = values.every(v => typeof v === 'string' || typeof v === 'number' ||\n                                           typeof v === 'boolean' || v === null ||\n                                           (isObject(v) && (v instanceof Date || v instanceof Counter || v instanceof Int ||\n                                                            v instanceof Uint || v instanceof Float64)))\n    const allValueDescriptions = allPrimitive ? values.map(v => this.getValueDescription(v)) : []\n    const allDatatypesSame = allValueDescriptions.every(t => t.datatype === allValueDescriptions[0].datatype)\n\n    if (allPrimitive && allDatatypesSame && values.length > 1) {\n      const nextElemId = this.nextOpId()\n      const datatype = allValueDescriptions[0].datatype\n      const values = allValueDescriptions.map(v => v.value)\n      const op = {action: 'set', obj: subpatch.objectId, elemId, insert: true, values, pred: []}\n      const edit = {action: 'multi-insert', elemId: nextElemId, index, values}\n      if (datatype) {\n        op.datatype = datatype\n        edit.datatype = datatype\n      }\n      this.addOp(op)\n      subpatch.edits.push(edit)\n    } else {\n      for (let offset = 0; offset < values.length; offset++) {\n        let nextElemId = this.nextOpId()\n        const valuePatch = this.setValue(subpatch.objectId, index + offset, values[offset], true, [], elemId)\n        elemId = nextElemId\n        subpatch.edits.push({action: 'insert', index: index + offset, elemId, opId: elemId, value: valuePatch})\n      }\n    }\n  }\n\n  /**\n   * Updates the list object at path `path`, replacing the current value at\n   * position `index` with the new value `value`.\n   */\n  setListIndex(path, index, value) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    const list = this.getObject(objectId)\n\n    // Assignment past the end of the list => insert nulls followed by new value\n    if (index >= list.length) {\n      const insertions = createArrayOfNulls(index - list.length)\n      insertions.push(value)\n      return this.splice(path, list.length, 0, insertions)\n    }\n    if (list[index] instanceof Counter) {\n      throw new RangeError('Cannot overwrite a Counter object; use .increment() or .decrement() to change its value.')\n    }\n\n    // If the assigned list element value is the same as the existing value, and\n    // the assignment does not resolve a conflict, do nothing\n    if (list[index] !== value || Object.keys(list[CONFLICTS][index] || {}).length > 1 || value === undefined) {\n      this.applyAtPath(path, subpatch => {\n        const pred = getPred(list, index)\n        const opId = this.nextOpId()\n        const valuePatch = this.setValue(objectId, index, value, false, pred, getElemId(list, index))\n        subpatch.edits.push({action: 'update', index, opId, value: valuePatch})\n      })\n    }\n  }\n\n  /**\n   * Updates the list object at path `path`, deleting `deletions` list elements starting from\n   * list index `start`, and inserting the list of new elements `insertions` at that position.\n   */\n  splice(path, start, deletions, insertions) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    let list = this.getObject(objectId)\n    if (start < 0 || deletions < 0 || start > list.length - deletions) {\n      throw new RangeError(`${deletions} deletions starting at index ${start} are out of bounds for list of length ${list.length}`)\n    }\n    if (deletions === 0 && insertions.length === 0) return\n\n    let patch = {diffs: {objectId: '_root', type: 'map', props: {}}}\n    let subpatch = this.getSubpatch(patch.diffs, path)\n\n    if (deletions > 0) {\n      let op, lastElemParsed, lastPredParsed\n      for (let i = 0; i < deletions; i++) {\n        if (this.getObjectField(path, objectId, start + i) instanceof Counter) {\n          // This may seem bizarre, but it's really fiddly to implement deletion of counters from\n          // lists, and I doubt anyone ever needs to do this, so I'm just going to throw an\n          // exception for now. The reason is: a counter is created by a set operation with counter\n          // datatype, and subsequent increment ops are successors to the set operation. Normally, a\n          // set operation with successor indicates a value that has been overwritten, so a set\n          // operation with successors is normally invisible. Counters are an exception, because the\n          // increment operations don't make the set operation invisible. When a counter appears in\n          // a map, this is not too bad: if all successors are increments, then the counter remains\n          // visible; if one or more successors are deletions, it goes away. However, when deleting\n          // a list element, we have the additional challenge that we need to distinguish between a\n          // list element that is being deleted by the current change (in which case we need to put\n          // a 'remove' action in the patch's edits for that list) and a list element that was\n          // already deleted previously (in which case the patch should not reflect the deletion).\n          // This can be done, but as I said, it's fiddly. If someone wants to pick this up in the\n          // future, hopefully the above description will be enough to get you started. Good luck!\n          throw new TypeError('Unsupported operation: deleting a counter from a list')\n        }\n\n        // Any sequences of deletions with consecutive elemId and pred values get combined into a\n        // single multiOp; any others become individual deletion operations. This optimisation only\n        // kicks in if the user deletes a sequence of elements at once (in a single call to splice);\n        // it might be nice to also detect such runs of deletions in the case where the user deletes\n        // a sequence of list elements one by one.\n        const thisElem = getElemId(list, start + i), thisElemParsed = parseOpId(thisElem)\n        const thisPred = getPred(list, start + i)\n        const thisPredParsed = (thisPred.length === 1) ? parseOpId(thisPred[0]) : undefined\n\n        if (op && lastElemParsed && lastPredParsed && thisPredParsed &&\n            lastElemParsed.actorId === thisElemParsed.actorId && lastElemParsed.counter + 1 === thisElemParsed.counter &&\n            lastPredParsed.actorId === thisPredParsed.actorId && lastPredParsed.counter + 1 === thisPredParsed.counter) {\n          op.multiOp = (op.multiOp || 1) + 1\n        } else {\n          if (op) this.addOp(op)\n          op = {action: 'del', obj: objectId, elemId: thisElem, insert: false, pred: thisPred}\n        }\n        lastElemParsed = thisElemParsed\n        lastPredParsed = thisPredParsed\n      }\n      this.addOp(op)\n      subpatch.edits.push({action: 'remove', index: start, count: deletions})\n    }\n\n    if (insertions.length > 0) {\n      this.insertListItems(subpatch, start, insertions, false)\n    }\n    this.applyPatch(patch.diffs, this.cache._root, this.updated)\n  }\n\n  /**\n   * Updates the table object at path `path`, adding a new entry `row`.\n   * Returns the objectId of the new row.\n   */\n  addTableRow(path, row) {\n    if (!isObject(row) || Array.isArray(row)) {\n      throw new TypeError('A table row must be an object')\n    }\n    if (row[OBJECT_ID]) {\n      throw new TypeError('Cannot reuse an existing object as table row')\n    }\n    if (row.id) {\n      throw new TypeError('A table row must not have an \"id\" property; it is generated automatically')\n    }\n\n    const id = uuid()\n    const valuePatch = this.setValue(path[path.length - 1].objectId, id, row, false, [])\n    this.applyAtPath(path, subpatch => {\n      subpatch.props[id] = {[valuePatch.objectId]: valuePatch}\n    })\n    return id\n  }\n\n  /**\n   * Updates the table object at path `path`, deleting the row with ID `rowId`.\n   * `pred` is the opId of the operation that originally created the row.\n   */\n  deleteTableRow(path, rowId, pred) {\n    const objectId = path[path.length - 1].objectId, table = this.getObject(objectId)\n\n    if (table.byId(rowId)) {\n      this.addOp({action: 'del', obj: objectId, key: rowId, insert: false, pred: [pred]})\n      this.applyAtPath(path, subpatch => {\n        subpatch.props[rowId] = {}\n      })\n    }\n  }\n\n  /**\n   * Adds the integer `delta` to the value of the counter located at property\n   * `key` in the object at path `path`.\n   */\n  increment(path, key, delta) {\n    const objectId = path.length === 0 ? '_root' : path[path.length - 1].objectId\n    const object = this.getObject(objectId)\n    if (!(object[key] instanceof Counter)) {\n      throw new TypeError('Only counter values can be incremented')\n    }\n\n    // TODO what if there is a conflicting value on the same key as the counter?\n    const type = this.getObjectType(objectId)\n    const value = object[key].value + delta\n    const opId = this.nextOpId()\n    const pred = getPred(object, key)\n\n    if (type === 'list' || type === 'text') {\n      const elemId = getElemId(object, key, false)\n      this.addOp({action: 'inc', obj: objectId, elemId, value: delta, insert: false, pred})\n    } else {\n      this.addOp({action: 'inc', obj: objectId, key, value: delta, insert: false, pred})\n    }\n\n    this.applyAtPath(path, subpatch => {\n      if (type === 'list' || type === 'text') {\n        subpatch.edits.push({action: 'update', index: key, opId, value: {value, datatype: 'counter'}})\n      } else {\n        subpatch.props[key] = {[opId]: {value, datatype: 'counter'}}\n      }\n    })\n  }\n}\n\nfunction getPred(object, key) {\n  if (object instanceof Table) {\n    return [object.opIds[key]]\n  } else if (object instanceof Text) {\n    return object.elems[key].pred\n  } else if (object[CONFLICTS]) {\n    return object[CONFLICTS][key] ? Object.keys(object[CONFLICTS][key]) : []\n  } else {\n    return []\n  }\n}\n\nfunction getElemId(list, index, insert = false) {\n  if (insert) {\n    if (index === 0) return '_head'\n    index -= 1\n  }\n  if (list[ELEM_IDS]) return list[ELEM_IDS][index]\n  if (list.getElemId) return list.getElemId(index)\n  throw new RangeError(`Cannot find elemId at list index ${index}`)\n}\n\nmodule.exports = {\n  Context\n}\n","/**\n * The most basic CRDT: an integer value that can be changed only by\n * incrementing and decrementing. Since addition of integers is commutative,\n * the value trivially converges.\n */\nclass Counter {\n  constructor(value) {\n    this.value = value || 0\n    Object.freeze(this)\n  }\n\n  /**\n   * A peculiar JavaScript language feature from its early days: if the object\n   * `x` has a `valueOf()` method that returns a number, you can use numerical\n   * operators on the object `x` directly, such as `x + 1` or `x < 4`.\n   * This method is also called when coercing a value to a string by\n   * concatenating it with another string, as in `x + ''`.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\n   */\n  valueOf() {\n    return this.value\n  }\n\n  /**\n   * Returns the counter value as a decimal string. If `x` is a counter object,\n   * this method is called e.g. when you do `['value: ', x].join('')` or when\n   * you use string interpolation: `value: ${x}`.\n   */\n  toString() {\n    return this.valueOf().toString()\n  }\n\n  /**\n   * Returns the counter value, so that a JSON serialization of an Automerge\n   * document represents the counter simply as an integer.\n   */\n  toJSON() {\n    return this.value\n  }\n}\n\n/**\n * An instance of this class is used when a counter is accessed within a change\n * callback.\n */\nclass WriteableCounter extends Counter {\n  /**\n   * Increases the value of the counter by `delta`. If `delta` is not given,\n   * increases the value of the counter by 1.\n   */\n  increment(delta) {\n    delta = typeof delta === 'number' ? delta : 1\n    this.context.increment(this.path, this.key, delta)\n    this.value += delta\n    return this.value\n  }\n\n  /**\n   * Decreases the value of the counter by `delta`. If `delta` is not given,\n   * decreases the value of the counter by 1.\n   */\n  decrement(delta) {\n    return this.increment(typeof delta === 'number' ? -delta : -1)\n  }\n}\n\n/**\n * Returns an instance of `WriteableCounter` for use in a change callback.\n * `context` is the proxy context that keeps track of the mutations.\n * `objectId` is the ID of the object containing the counter, and `key` is\n * the property name (key in map, or index in list) where the counter is\n * located.\n*/\nfunction getWriteableCounter(value, context, path, objectId, key) {\n  const instance = Object.create(WriteableCounter.prototype)\n  instance.value = value\n  instance.context = context\n  instance.path = path\n  instance.objectId = objectId\n  instance.key = key\n  return instance\n}\n\nmodule.exports = { Counter, getWriteableCounter }\n","const { OPTIONS, CACHE, STATE, OBJECT_ID, CONFLICTS, CHANGE, ELEM_IDS } = require('./constants')\nconst { isObject, copyObject } = require('../src/common')\nconst uuid = require('../src/uuid')\nconst { interpretPatch, cloneRootObject } = require('./apply_patch')\nconst { rootObjectProxy } = require('./proxies')\nconst { Context } = require('./context')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\nconst { Counter } = require('./counter')\nconst { Float64, Int, Uint } = require('./numbers')\nconst { Observable } = require('./observable')\n\n/**\n * Actor IDs must consist only of hexadecimal digits so that they can be encoded\n * compactly in binary form.\n */\nfunction checkActorId(actorId) {\n  if (typeof actorId !== 'string') {\n    throw new TypeError(`Unsupported type of actorId: ${typeof actorId}`)\n  }\n  if (!/^[0-9a-f]+$/.test(actorId)) {\n    throw new RangeError('actorId must consist only of lowercase hex digits')\n  }\n  if (actorId.length % 2 !== 0) {\n    throw new RangeError('actorId must consist of an even number of digits')\n  }\n}\n\n/**\n * Takes a set of objects that have been updated (in `updated`) and an updated state object\n * `state`, and returns a new immutable document root object based on `doc` that reflects\n * those updates.\n */\nfunction updateRootObject(doc, updated, state) {\n  let newDoc = updated._root\n  if (!newDoc) {\n    newDoc = cloneRootObject(doc[CACHE]._root)\n    updated._root = newDoc\n  }\n  Object.defineProperty(newDoc, OPTIONS,  {value: doc[OPTIONS]})\n  Object.defineProperty(newDoc, CACHE,    {value: updated})\n  Object.defineProperty(newDoc, STATE,    {value: state})\n\n  if (doc[OPTIONS].freeze) {\n    for (let objectId of Object.keys(updated)) {\n      if (updated[objectId] instanceof Table) {\n        updated[objectId]._freeze()\n      } else if (updated[objectId] instanceof Text) {\n        Object.freeze(updated[objectId].elems)\n        Object.freeze(updated[objectId])\n      } else {\n        Object.freeze(updated[objectId])\n        Object.freeze(updated[objectId][CONFLICTS])\n      }\n    }\n  }\n\n  for (let objectId of Object.keys(doc[CACHE])) {\n    if (!updated[objectId]) {\n      updated[objectId] = doc[CACHE][objectId]\n    }\n  }\n\n  if (doc[OPTIONS].freeze) {\n    Object.freeze(updated)\n  }\n  return newDoc\n}\n\n/**\n * Adds a new change request to the list of pending requests, and returns an\n * updated document root object.\n * The details of the change are taken from the context object `context`.\n * `options` contains properties that may affect how the change is processed; in\n * particular, the `message` property of `options` is an optional human-readable\n * string describing the change.\n */\nfunction makeChange(doc, context, options) {\n  const actor = getActorId(doc)\n  if (!actor) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  const state = copyObject(doc[STATE])\n  state.seq += 1\n\n  const change = {\n    actor,\n    seq: state.seq,\n    startOp: state.maxOp + 1,\n    deps: state.deps,\n    time: (options && typeof options.time === 'number') ? options.time\n                                                        : Math.round(new Date().getTime() / 1000),\n    message: (options && typeof options.message === 'string') ? options.message : '',\n    ops: context.ops\n  }\n\n  if (doc[OPTIONS].backend) {\n    const [backendState, patch, binaryChange] = doc[OPTIONS].backend.applyLocalChange(state.backendState, change)\n    state.backendState = backendState\n    state.lastLocalChange = binaryChange\n    // NOTE: When performing a local change, the patch is effectively applied twice -- once by the\n    // context invoking interpretPatch as soon as any change is made, and the second time here\n    // (after a round-trip through the backend). This is perhaps more robust, as changes only take\n    // effect in the form processed by the backend, but the downside is a performance cost.\n    // Should we change this?\n    const newDoc = applyPatchToDoc(doc, patch, state, true)\n    const patchCallback = options && options.patchCallback || doc[OPTIONS].patchCallback\n    if (patchCallback) patchCallback(patch, doc, newDoc, true, [binaryChange])\n    return [newDoc, change]\n\n  } else {\n    const queuedRequest = {actor, seq: change.seq, before: doc}\n    state.requests = state.requests.concat([queuedRequest])\n    state.maxOp = state.maxOp + countOps(change.ops)\n    state.deps = []\n    return [updateRootObject(doc, context ? context.updated : {}, state), change]\n  }\n}\n\nfunction countOps(ops) {\n  let count = 0\n  for (const op of ops) {\n    if (op.action === 'set' && op.values) {\n      count += op.values.length\n    } else {\n      count += 1\n    }\n  }\n  return count\n}\n\n/**\n * Returns the binary encoding of the last change made by the local actor.\n */\nfunction getLastLocalChange(doc) {\n  return doc[STATE] && doc[STATE].lastLocalChange ? doc[STATE].lastLocalChange : null\n}\n\n/**\n * Applies the changes described in `patch` to the document with root object\n * `doc`. The state object `state` is attached to the new root object.\n * `fromBackend` should be set to `true` if the patch came from the backend,\n * and to `false` if the patch is a transient local (optimistically applied)\n * change from the frontend.\n */\nfunction applyPatchToDoc(doc, patch, state, fromBackend) {\n  const actor = getActorId(doc)\n  const updated = {}\n  interpretPatch(patch.diffs, doc, updated)\n\n  if (fromBackend) {\n    if (!patch.clock) throw new RangeError('patch is missing clock field')\n    if (patch.clock[actor] && patch.clock[actor] > state.seq) {\n      state.seq = patch.clock[actor]\n    }\n    state.clock = patch.clock\n    state.deps  = patch.deps\n    state.maxOp = Math.max(state.maxOp, patch.maxOp)\n  }\n  return updateRootObject(doc, updated, state)\n}\n\n/**\n * Creates an empty document object with no changes.\n */\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {actorId: options}\n  } else if (typeof options === 'undefined') {\n    options = {}\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported value for init() options: ${options}`)\n  }\n\n  if (!options.deferActorId) {\n    if (options.actorId === undefined) {\n      options.actorId = uuid()\n    }\n    checkActorId(options.actorId)\n  }\n\n  if (options.observable) {\n    const patchCallback = options.patchCallback, observable = options.observable\n    options.patchCallback = (patch, before, after, local, changes) => {\n      if (patchCallback) patchCallback(patch, before, after, local, changes)\n      observable.patchCallback(patch, before, after, local, changes)\n    }\n  }\n\n  const root = {}, cache = {_root: root}\n  const state = {seq: 0, maxOp: 0, requests: [], clock: {}, deps: []}\n  if (options.backend) {\n    state.backendState = options.backend.init()\n    state.lastLocalChange = null\n  }\n  Object.defineProperty(root, OBJECT_ID, {value: '_root'})\n  Object.defineProperty(root, OPTIONS,   {value: Object.freeze(options)})\n  Object.defineProperty(root, CONFLICTS, {value: Object.freeze({})})\n  Object.defineProperty(root, CACHE,     {value: Object.freeze(cache)})\n  Object.defineProperty(root, STATE,     {value: Object.freeze(state)})\n  return Object.freeze(root)\n}\n\n/**\n * Returns a new document object initialized with the given state.\n */\nfunction from(initialState, options) {\n  return change(init(options), 'Initialization', doc => Object.assign(doc, initialState))\n}\n\n\n/**\n * Changes a document `doc` according to actions taken by the local user.\n * `options` is an object that can contain the following properties:\n *  - `message`: an optional descriptive string that is attached to the change.\n * If `options` is a string, it is treated as `message`.\n *\n * The actual change is made within the callback function `callback`, which is\n * given a mutable version of the document as argument. Returns a two-element\n * array `[doc, request]` where `doc` is the updated document, and `request`\n * is the change request to send to the backend. If nothing was actually\n * changed, returns the original `doc` and a `null` change request.\n */\nfunction change(doc, options, callback) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Automerge.change must be the document root')\n  }\n  if (doc[CHANGE]) {\n    throw new TypeError('Calls to Automerge.change cannot be nested')\n  }\n  if (typeof options === 'function' && callback === undefined) {\n    [options, callback] = [callback, options]\n  }\n  if (typeof options === 'string') {\n    options = {message: options}\n  }\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options')\n  }\n\n  const actorId = getActorId(doc)\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  const context = new Context(doc, actorId)\n  callback(rootObjectProxy(context))\n\n  if (Object.keys(context.updated).length === 0) {\n    // If the callback didn't change anything, return the original document object unchanged\n    return [doc, null]\n  } else {\n    return makeChange(doc, context, options)\n  }\n}\n\n/**\n * Triggers a new change request on the document `doc` without actually\n * modifying its data. `options` is an object as described in the documentation\n * for the `change` function. This function can be useful for acknowledging the\n * receipt of some message (as it's incorported into the `deps` field of the\n * change). Returns a two-element array `[doc, request]` where `doc` is the\n * updated document, and `request` is the change request to send to the backend.\n */\nfunction emptyChange(doc, options) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Automerge.emptyChange must be the document root')\n  }\n  if (typeof options === 'string') {\n    options = {message: options}\n  }\n  if (options !== undefined && !isObject(options)) {\n    throw new TypeError('Unsupported type of options')\n  }\n\n  const actorId = getActorId(doc)\n  if (!actorId) {\n    throw new Error('Actor ID must be initialized with setActorId() before making a change')\n  }\n  return makeChange(doc, new Context(doc, actorId), options)\n}\n\n/**\n * Applies `patch` to the document root object `doc`. This patch must come\n * from the backend; it may be the result of a local change or a remote change.\n * If it is the result of a local change, the `seq` field from the change\n * request should be included in the patch, so that we can match them up here.\n */\nfunction applyPatch(doc, patch, backendState = undefined) {\n  if (doc[OBJECT_ID] !== '_root') {\n    throw new TypeError('The first argument to Frontend.applyPatch must be the document root')\n  }\n  const state = copyObject(doc[STATE])\n\n  if (doc[OPTIONS].backend) {\n    if (!backendState) {\n      throw new RangeError('applyPatch must be called with the updated backend state')\n    }\n    state.backendState = backendState\n    return applyPatchToDoc(doc, patch, state, true)\n  }\n\n  let baseDoc\n\n  if (state.requests.length > 0) {\n    baseDoc = state.requests[0].before\n    if (patch.actor === getActorId(doc)) {\n      if (state.requests[0].seq !== patch.seq) {\n        throw new RangeError(`Mismatched sequence number: patch ${patch.seq} does not match next request ${state.requests[0].seq}`)\n      }\n      state.requests = state.requests.slice(1)\n    } else {\n      state.requests = state.requests.slice()\n    }\n  } else {\n    baseDoc = doc\n    state.requests = []\n  }\n\n  let newDoc = applyPatchToDoc(baseDoc, patch, state, true)\n  if (state.requests.length === 0) {\n    return newDoc\n  } else {\n    state.requests[0] = copyObject(state.requests[0])\n    state.requests[0].before = newDoc\n    return updateRootObject(doc, {}, state)\n  }\n}\n\n/**\n * Returns the Automerge object ID of the given object.\n */\nfunction getObjectId(object) {\n  return object[OBJECT_ID]\n}\n\n/**\n * Returns the object with the given Automerge object ID. Note: when called\n * within a change callback, the returned object is read-only (not a mutable\n * proxy object).\n */\nfunction getObjectById(doc, objectId) {\n  // It would be nice to return a proxied object in a change callback.\n  // However, that requires knowing the path from the root to the current\n  // object, which we don't have if we jumped straight to the object by its ID.\n  // If we maintained an index from object ID to parent ID we could work out the path.\n  if (doc[CHANGE]) {\n    throw new TypeError('Cannot use getObjectById in a change callback')\n  }\n  return doc[CACHE][objectId]\n}\n\n/**\n * Returns the Automerge actor ID of the given document.\n */\nfunction getActorId(doc) {\n  return doc[STATE].actorId || doc[OPTIONS].actorId\n}\n\n/**\n * Sets the Automerge actor ID on the document object `doc`, returning a\n * document object with updated metadata.\n */\nfunction setActorId(doc, actorId) {\n  checkActorId(actorId)\n  const state = Object.assign({}, doc[STATE], {actorId})\n  return updateRootObject(doc, {}, state)\n}\n\n/**\n * Fetches the conflicts on the property `key` of `object`, which may be any\n * object in a document. If `object` is a list, then `key` must be a list\n * index; if `object` is a map, then `key` must be a property name.\n */\nfunction getConflicts(object, key) {\n  if (object[CONFLICTS] && object[CONFLICTS][key] &&\n      Object.keys(object[CONFLICTS][key]).length > 1) {\n    return object[CONFLICTS][key]\n  }\n}\n\n/**\n * Returns the backend state associated with the document `doc` (only used if\n * a backend implementation is passed to `init()`).\n */\nfunction getBackendState(doc, callerName = null, argPos = 'first') {\n  if (doc[OBJECT_ID] !== '_root') {\n    // Most likely cause of passing an array here is forgetting to deconstruct the return value of\n    // Automerge.applyChanges().\n    const extraMsg = Array.isArray(doc) ? '. Note: Automerge.applyChanges now returns an array.' : ''\n    if (callerName) {\n      throw new TypeError(`The ${argPos} argument to Automerge.${callerName} must be the document root${extraMsg}`)\n    } else {\n      throw new TypeError(`Argument is not an Automerge document root${extraMsg}`)\n    }\n  }\n  return doc[STATE].backendState\n}\n\n/**\n * Given an array or text object from an Automerge document, returns an array\n * containing the unique element ID of each list element/character.\n */\nfunction getElementIds(list) {\n  if (list instanceof Text) {\n    return list.elems.map(elem => elem.elemId)\n  } else {\n    return list[ELEM_IDS]\n  }\n}\n\nmodule.exports = {\n  init, from, change, emptyChange, applyPatch,\n  getObjectId, getObjectById, getActorId, setActorId, getConflicts, getLastLocalChange,\n  getBackendState, getElementIds,\n  Text, Table, Counter, Observable, Float64, Int, Uint\n}\n","// Convience classes to allow users to stricly specify the number type they want\n\nclass Int {\n  constructor(value) {\n    if (!(Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER)) {\n      throw new RangeError(`Value ${value} cannot be a uint`)\n    }\n    this.value = value\n    Object.freeze(this)\n  }\n}\n\nclass Uint {\n  constructor(value) {\n    if (!(Number.isInteger(value) && value <= Number.MAX_SAFE_INTEGER && value >= 0)) {\n      throw new RangeError(`Value ${value} cannot be a uint`)\n    }\n    this.value = value\n    Object.freeze(this)\n  }\n}\n\nclass Float64 {\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new RangeError(`Value ${value} cannot be a float64`)\n    }\n    this.value = value || 0.0\n    Object.freeze(this)\n  }\n}\n\nmodule.exports = { Int, Uint, Float64 }\n","const { OBJECT_ID, CONFLICTS } = require('./constants')\n\n/**\n * Allows an application to register a callback when a particular object in\n * a document changes.\n *\n * NOTE: This API is experimental and may change without warning in minor releases.\n */\nclass Observable {\n  constructor() {\n    this.observers = {} // map from objectId to array of observers for that object\n  }\n\n  /**\n   * Called by an Automerge document when `patch` is applied. `before` is the\n   * state of the document before the patch, and `after` is the state after\n   * applying it. `local` is true if the update is a result of locally calling\n   * `Automerge.change()`, and false otherwise. `changes` is an array of\n   * changes that were applied to the document (as Uint8Arrays).\n   */\n  patchCallback(patch, before, after, local, changes) {\n    this._objectUpdate(patch.diffs, before, after, local, changes)\n  }\n\n  /**\n   * Recursively walks a patch and calls the callbacks for all objects that\n   * appear in the patch.\n   */\n  _objectUpdate(diff, before, after, local, changes) {\n    if (!diff.objectId) return\n    if (this.observers[diff.objectId]) {\n      for (let callback of this.observers[diff.objectId]) {\n        callback(diff, before, after, local, changes)\n      }\n    }\n\n    if (diff.type === 'map' && diff.props) {\n      for (const propName of Object.keys(diff.props)) {\n        for (const opId of Object.keys(diff.props[propName])) {\n          this._objectUpdate(diff.props[propName][opId],\n                             before && before[CONFLICTS] && before[CONFLICTS][propName] && before[CONFLICTS][propName][opId],\n                             after && after[CONFLICTS] && after[CONFLICTS][propName] && after[CONFLICTS][propName][opId],\n                             local, changes)\n        }\n      }\n\n    } else if (diff.type === 'table' && diff.props) {\n      for (const rowId of Object.keys(diff.props)) {\n        for (const opId of Object.keys(diff.props[rowId])) {\n          this._objectUpdate(diff.props[rowId][opId],\n                             before && before.byId(rowId),\n                             after && after.byId(rowId),\n                             local, changes)\n        }\n      }\n\n    } else if (diff.type === 'list' && diff.edits) {\n      let offset = 0\n      for (const edit of diff.edits) {\n        if (edit.action === 'insert') {\n          offset -= 1\n          this._objectUpdate(edit.value, undefined,\n                             after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.elemId],\n                             local, changes)\n        } else if (edit.action === 'multi-insert') {\n          offset -= edit.values.length\n        } else if (edit.action === 'update') {\n          this._objectUpdate(edit.value,\n                             before && before[CONFLICTS] && before[CONFLICTS][edit.index + offset] &&\n                               before[CONFLICTS][edit.index + offset][edit.opId],\n                             after && after[CONFLICTS] && after[CONFLICTS][edit.index] && after[CONFLICTS][edit.index][edit.opId],\n                             local, changes)\n        } else if (edit.action === 'remove') {\n          offset += edit.count\n        }\n      }\n\n    } else if (diff.type === 'text' && diff.edits) {\n      let offset = 0\n      for (const edit of diff.edits) {\n        if (edit.action === 'insert') {\n          offset -= 1\n          this._objectUpdate(edit.value, undefined, after && after.get(edit.index), local, changes)\n        } else if (edit.action === 'multi-insert') {\n          offset -= edit.values.length\n        } else if (edit.action === 'update') {\n          this._objectUpdate(edit.value,\n                             before && before.get(edit.index + offset),\n                             after && after.get(edit.index),\n                             local, changes)\n        } else if (edit.action === 'remove') {\n          offset += edit.count\n        }\n      }\n    }\n  }\n\n  /**\n   * Call this to register a callback that will get called whenever a particular\n   * object in a document changes. The callback is passed five arguments: the\n   * part of the patch describing the update to that object, the old state of\n   * the object, the new state of the object, a boolean that is true if the\n   * change is the result of calling `Automerge.change()` locally, and the array\n   * of binary changes applied to the document.\n   */\n  observe(object, callback) {\n    const objectId = object[OBJECT_ID]\n    if (!objectId) throw new TypeError('The observed object must be part of an Automerge document')\n    if (!this.observers[objectId]) this.observers[objectId] = []\n    this.observers[objectId].push(callback)\n  }\n}\n\nmodule.exports = { Observable }\n","const { OBJECT_ID, CHANGE, STATE } = require('./constants')\nconst { createArrayOfNulls } = require('../src/common')\nconst { Text } = require('./text')\nconst { Table } = require('./table')\n\nfunction parseListIndex(key) {\n  if (typeof key === 'string' && /^[0-9]+$/.test(key)) key = parseInt(key, 10)\n  if (typeof key !== 'number') {\n    throw new TypeError('A list index must be a number, but you passed ' + JSON.stringify(key))\n  }\n  if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n    throw new RangeError('A list index must be positive, but you passed ' + key)\n  }\n  return key\n}\n\nfunction listMethods(context, listId, path) {\n  const methods = {\n    deleteAt(index, numDelete) {\n      context.splice(path, parseListIndex(index), numDelete || 1, [])\n      return this\n    },\n\n    fill(value, start, end) {\n      let list = context.getObject(listId)\n      for (let index = parseListIndex(start || 0); index < parseListIndex(end || list.length); index++) {\n        context.setListIndex(path, index, value)\n      }\n      return this\n    },\n\n    indexOf(o, start = 0) {\n      const id = o[OBJECT_ID]\n      if (id) {\n        const list = context.getObject(listId)\n        for (let index = start; index < list.length; index++) {\n          if (list[index][OBJECT_ID] === id) {\n            return index\n          }\n        }\n        return -1\n      } else {\n        return context.getObject(listId).indexOf(o, start)\n      }\n    },\n\n    insertAt(index, ...values) {\n      context.splice(path, parseListIndex(index), 0, values)\n      return this\n    },\n\n    pop() {\n      let list = context.getObject(listId)\n      if (list.length == 0) return\n      const last = context.getObjectField(path, listId, list.length - 1)\n      context.splice(path, list.length - 1, 1, [])\n      return last\n    },\n\n    push(...values) {\n      let list = context.getObject(listId)\n      context.splice(path, list.length, 0, values)\n      // need to getObject() again because the list object above may be immutable\n      return context.getObject(listId).length\n    },\n\n    shift() {\n      let list = context.getObject(listId)\n      if (list.length == 0) return\n      const first = context.getObjectField(path, listId, 0)\n      context.splice(path, 0, 1, [])\n      return first\n    },\n\n    splice(start, deleteCount, ...values) {\n      let list = context.getObject(listId)\n      start = parseListIndex(start)\n      if (deleteCount === undefined || deleteCount > list.length - start) {\n        deleteCount = list.length - start\n      }\n      const deleted = []\n      for (let n = 0; n < deleteCount; n++) {\n        deleted.push(context.getObjectField(path, listId, start + n))\n      }\n      context.splice(path, start, deleteCount, values)\n      return deleted\n    },\n\n    unshift(...values) {\n      context.splice(path, 0, 0, values)\n      return context.getObject(listId).length\n    }\n  }\n\n  for (let iterator of ['entries', 'keys', 'values']) {\n    let list = context.getObject(listId)\n    methods[iterator] = () => list[iterator]()\n  }\n\n  // Read-only methods that can delegate to the JavaScript built-in implementations\n  for (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes',\n                      'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight',\n                      'slice', 'some', 'toLocaleString', 'toString']) {\n    methods[method] = (...args) => {\n      const list = context.getObject(listId)\n        .map((item, index) => context.getObjectField(path, listId, index))\n      return list[method](...args)\n    }\n  }\n\n  return methods\n}\n\nconst MapHandler = {\n  get (target, key) {\n    const { context, objectId, path } = target\n    if (key === OBJECT_ID) return objectId\n    if (key === CHANGE) return context\n    if (key === STATE) return {actorId: context.actorId}\n    return context.getObjectField(path, objectId, key)\n  },\n\n  set (target, key, value) {\n    const { context, path, readonly } = target\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`)\n    }\n    context.setMapKey(path, key, value)\n    return true\n  },\n\n  deleteProperty (target, key) {\n    const { context, path, readonly } = target\n    if (Array.isArray(readonly) && readonly.indexOf(key) >= 0) {\n      throw new RangeError(`Object property \"${key}\" cannot be modified`)\n    }\n    context.deleteMapKey(path, key)\n    return true\n  },\n\n  has (target, key) {\n    const { context, objectId } = target\n    return [OBJECT_ID, CHANGE].includes(key) || (key in context.getObject(objectId))\n  },\n\n  getOwnPropertyDescriptor (target, key) {\n    const { context, objectId } = target\n    const object = context.getObject(objectId)\n    if (key in object) {\n      return {\n        configurable: true, enumerable: true,\n        value: context.getObjectField(objectId, key)\n      }\n    }\n  },\n\n  ownKeys (target) {\n    const { context, objectId } = target\n    return Object.keys(context.getObject(objectId))\n  }\n}\n\nconst ListHandler = {\n  get (target, key) {\n    const [context, objectId, path] = target\n    if (key === Symbol.iterator) return context.getObject(objectId)[Symbol.iterator]\n    if (key === OBJECT_ID) return objectId\n    if (key === CHANGE) return context\n    if (key === 'length') return context.getObject(objectId).length\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return context.getObjectField(path, objectId, parseListIndex(key))\n    }\n    return listMethods(context, objectId, path)[key]\n  },\n\n  set (target, key, value) {\n    const [context, objectId, path] = target\n    if (key === 'length') {\n      if (typeof value !== 'number') {\n        throw new RangeError(\"Invalid array length\")\n      }\n      const length = context.getObject(objectId).length\n      if (length > value) {\n        context.splice(path, value, length - value, [])\n      } else {\n        context.splice(path, length, 0, createArrayOfNulls(value - length))\n      }\n    } else {\n      context.setListIndex(path, parseListIndex(key), value)\n    }\n    return true\n  },\n\n  deleteProperty (target, key) {\n    const [context, /* objectId */, path] = target\n    context.splice(path, parseListIndex(key), 1, [])\n    return true\n  },\n\n  has (target, key) {\n    const [context, objectId, /* path */] = target\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      return parseListIndex(key) < context.getObject(objectId).length\n    }\n    return ['length', OBJECT_ID, CHANGE].includes(key)\n  },\n\n  getOwnPropertyDescriptor (target, key) {\n    const [context, objectId, /* path */] = target\n    const object = context.getObject(objectId)\n\n    if (key === 'length') return {writable: true, value: object.length}\n    if (key === OBJECT_ID) return {configurable: false, enumerable: false, value: objectId}\n\n    if (typeof key === 'string' && /^[0-9]+$/.test(key)) {\n      const index = parseListIndex(key)\n      if (index < object.length) return {\n        configurable: true, enumerable: true,\n        value: context.getObjectField(objectId, index)\n      }\n    }\n  },\n\n  ownKeys (target) {\n    const [context, objectId, /* path */] = target\n    const object = context.getObject(objectId)\n    let keys = ['length']\n    for (let key of Object.keys(object)) keys.push(key)\n    return keys\n  }\n}\n\nfunction mapProxy(context, objectId, path, readonly) {\n  return new Proxy({context, objectId, path, readonly}, MapHandler)\n}\n\nfunction listProxy(context, objectId, path) {\n  return new Proxy([context, objectId, path], ListHandler)\n}\n\n/**\n * Instantiates a proxy object for the given `objectId`.\n * This function is added as a method to the context object by rootObjectProxy().\n * When it is called, `this` is the context object.\n * `readonly` is a list of map property names that cannot be modified.\n */\nfunction instantiateProxy(path, objectId, readonly) {\n  const object = this.getObject(objectId)\n  if (Array.isArray(object)) {\n    return listProxy(this, objectId, path)\n  } else if (object instanceof Text || object instanceof Table) {\n    return object.getWriteable(this, path)\n  } else {\n    return mapProxy(this, objectId, path, readonly)\n  }\n}\n\nfunction rootObjectProxy(context) {\n  context.instantiateObject = instantiateProxy\n  return mapProxy(context, '_root', [])\n}\n\nmodule.exports = { rootObjectProxy }\n","const { OBJECT_ID, CONFLICTS } = require('./constants')\nconst { isObject, copyObject } = require('../src/common')\n\nfunction compareRows(properties, row1, row2) {\n  for (let prop of properties) {\n    if (row1[prop] === row2[prop]) continue\n\n    if (typeof row1[prop] === 'number' && typeof row2[prop] === 'number') {\n      return row1[prop] - row2[prop]\n    } else {\n      const prop1 = '' + row1[prop], prop2 = '' + row2[prop]\n      if (prop1 === prop2) continue\n      if (prop1 < prop2) return -1; else return +1\n    }\n  }\n  return 0\n}\n\n\n/**\n * A relational-style unordered collection of records (rows). Each row is an\n * object that maps column names to values. The set of rows is represented by\n * a map from UUID to row object.\n */\nclass Table {\n  /**\n   * This constructor is used by application code when creating a new Table\n   * object within a change callback.\n   */\n  constructor() {\n    this.entries = Object.freeze({})\n    this.opIds = Object.freeze({})\n    Object.freeze(this)\n  }\n\n  /**\n   * Looks up a row in the table by its unique ID.\n   */\n  byId(id) {\n    return this.entries[id]\n  }\n\n  /**\n   * Returns an array containing the unique IDs of all rows in the table, in no\n   * particular order.\n   */\n  get ids() {\n    return Object.keys(this.entries).filter(key => {\n      const entry = this.entries[key]\n      return isObject(entry) && entry.id === key\n    })\n  }\n\n  /**\n   * Returns the number of rows in the table.\n   */\n  get count() {\n    return this.ids.length\n  }\n\n  /**\n   * Returns an array containing all of the rows in the table, in no particular\n   * order.\n   */\n  get rows() {\n    return this.ids.map(id => this.byId(id))\n  }\n\n  /**\n   * The standard JavaScript `filter()` method, which passes each row to the\n   * callback function and returns all rows for which the it returns true.\n   */\n  filter(callback, thisArg) {\n    return this.rows.filter(callback, thisArg)\n  }\n\n  /**\n   * The standard JavaScript `find()` method, which passes each row to the\n   * callback function and returns the first row for which it returns true.\n   */\n  find(callback, thisArg) {\n    return this.rows.find(callback, thisArg)\n  }\n\n  /**\n   * The standard JavaScript `map()` method, which passes each row to the\n   * callback function and returns a list of its return values.\n   */\n  map(callback, thisArg) {\n    return this.rows.map(callback, thisArg)\n  }\n\n  /**\n  * Returns the list of rows, sorted by one of the following:\n  * - If a function argument is given, it compares rows as per\n  *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description\n  * - If a string argument is given, it is interpreted as a column name and\n  *   rows are sorted according to that column.\n  * - If an array of strings is given, it is interpreted as a list of column\n  *   names, and rows are sorted lexicographically by those columns.\n  * - If no argument is given, it sorts by row ID by default.\n  */\n  sort(arg) {\n    if (typeof arg === 'function') {\n      return this.rows.sort(arg)\n    } else if (typeof arg === 'string') {\n      return this.rows.sort((row1, row2) => compareRows([arg], row1, row2))\n    } else if (Array.isArray(arg)) {\n      return this.rows.sort((row1, row2) => compareRows(arg, row1, row2))\n    } else if (arg === undefined) {\n      return this.rows.sort((row1, row2) => compareRows(['id'], row1, row2))\n    } else {\n      throw new TypeError(`Unsupported sorting argument: ${arg}`)\n    }\n  }\n\n  /**\n   * When iterating over a table, you get all rows in the table, in no\n   * particular order.\n   */\n  [Symbol.iterator] () {\n    let rows = this.rows, index = -1\n    return {\n      next () {\n        index += 1\n        if (index < rows.length) {\n          return {done: false, value: rows[index]}\n        } else {\n          return {done: true}\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns a shallow clone of this object. This clone is used while applying\n   * a patch to the table, and `freeze()` is called on it when we have finished\n   * applying the patch.\n   */\n  _clone() {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('clone() requires the objectId to be set')\n    }\n    return instantiateTable(this[OBJECT_ID], copyObject(this.entries), copyObject(this.opIds))\n  }\n\n  /**\n   * Sets the entry with key `id` to `value`. `opId` is the ID of the operation\n   * performing this assignment. This method is for internal use only; it is\n   * not part of the public API of Automerge.Table.\n   */\n  _set(id, value, opId) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function')\n    }\n    if (isObject(value) && !Array.isArray(value)) {\n      Object.defineProperty(value, 'id', {value: id, enumerable: true})\n    }\n    this.entries[id] = value\n    this.opIds[id] = opId\n  }\n\n  /**\n   * Removes the row with unique ID `id` from the table.\n   */\n  remove(id) {\n    if (Object.isFrozen(this.entries)) {\n      throw new Error('A table can only be modified in a change function')\n    }\n    delete this.entries[id]\n    delete this.opIds[id]\n  }\n\n  /**\n   * Makes this object immutable. This is called after a change has been made.\n   */\n  _freeze() {\n    Object.freeze(this.entries)\n    Object.freeze(this.opIds)\n    Object.freeze(this)\n  }\n\n  /**\n   * Returns a writeable instance of this table. This instance is returned when\n   * the table is accessed within a change callback. `context` is the proxy\n   * context that keeps track of the mutations.\n   */\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set')\n    }\n\n    const instance = Object.create(WriteableTable.prototype)\n    instance[OBJECT_ID] = this[OBJECT_ID]\n    instance.context = context\n    instance.entries = this.entries\n    instance.opIds = this.opIds\n    instance.path = path\n    return instance\n  }\n\n  /**\n   * Returns an object containing the table entries, indexed by objectID,\n   * for serializing an Automerge document to JSON.\n   */\n  toJSON() {\n    const rows = {}\n    for (let id of this.ids) rows[id] = this.byId(id)\n    return rows\n  }\n}\n\n/**\n * An instance of this class is used when a table is accessed within a change\n * callback.\n */\nclass WriteableTable extends Table {\n  /**\n   * Returns a proxied version of the row with ID `id`. This row object can be\n   * modified within a change callback.\n   */\n  byId(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      const objectId = this.entries[id][OBJECT_ID]\n      const path = this.path.concat([{key: id, objectId}])\n      return this.context.instantiateObject(path, objectId, ['id'])\n    }\n  }\n\n  /**\n   * Adds a new row to the table. The row is given as a map from\n   * column name to value. Returns the objectId of the new row.\n   */\n  add(row) {\n    return this.context.addTableRow(this.path, row)\n  }\n\n  /**\n   * Removes the row with ID `id` from the table. Throws an exception if the row\n   * does not exist in the table.\n   */\n  remove(id) {\n    if (isObject(this.entries[id]) && this.entries[id].id === id) {\n      this.context.deleteTableRow(this.path, id, this.opIds[id])\n    } else {\n      throw new RangeError(`There is no row with ID ${id} in this table`)\n    }\n  }\n}\n\n/**\n * This function is used to instantiate a Table object in the context of\n * applying a patch (see apply_patch.js).\n */\nfunction instantiateTable(objectId, entries, opIds) {\n  const instance = Object.create(Table.prototype)\n  if (!objectId) {\n    throw new RangeError('instantiateTable requires an objectId to be given')\n  }\n  instance[OBJECT_ID] = objectId\n  instance[CONFLICTS] = Object.freeze({})\n  instance.entries = entries || {}\n  instance.opIds = opIds || {}\n  return instance\n}\n\nmodule.exports = { Table, instantiateTable }\n","const { OBJECT_ID } = require('./constants')\nconst { isObject } = require('../src/common')\n\nclass Text {\n  constructor (text) {\n    if (typeof text === 'string') {\n      const elems = [...text].map(value => ({value}))\n      return instantiateText(undefined, elems) // eslint-disable-line\n    } else if (Array.isArray(text)) {\n      const elems = text.map(value => ({value}))\n      return instantiateText(undefined, elems) // eslint-disable-line\n    } else if (text === undefined) {\n      return instantiateText(undefined, []) // eslint-disable-line\n    } else {\n      throw new TypeError(`Unsupported initial value for Text: ${text}`)\n    }\n  }\n\n  get length () {\n    return this.elems.length\n  }\n\n  get (index) {\n    const value = this.elems[index].value\n    if (this.context && isObject(value)) {\n      const objectId = value[OBJECT_ID]\n      const path = this.path.concat([{key: index, objectId}])\n      return this.context.instantiateObject(path, objectId)\n    } else {\n      return value\n    }\n  }\n\n  getElemId (index) {\n    return this.elems[index].elemId\n  }\n\n  /**\n   * Iterates over the text elements character by character, including any\n   * inline objects.\n   */\n  [Symbol.iterator] () {\n    let elems = this.elems, index = -1\n    return {\n      next () {\n        index += 1\n        if (index < elems.length) {\n          return {done: false, value: elems[index].value}\n        } else {\n          return {done: true}\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the content of the Text object as a simple string, ignoring any\n   * non-character elements.\n   */\n  toString() {\n    // Concatting to a string is faster than creating an array and then\n    // .join()ing for small (<100KB) arrays.\n    // https://jsperf.com/join-vs-loop-w-type-test\n    let str = ''\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') str += elem.value\n    }\n    return str\n  }\n\n  /**\n   * Returns the content of the Text object as a sequence of strings,\n   * interleaved with non-character elements.\n   *\n   * For example, the value ['a', 'b', {x: 3}, 'c', 'd'] has spans:\n   * => ['ab', {x: 3}, 'cd']\n   */\n  toSpans() {\n    let spans = []\n    let chars = ''\n    for (const elem of this.elems) {\n      if (typeof elem.value === 'string') {\n        chars += elem.value\n      } else {\n        if (chars.length > 0) {\n          spans.push(chars)\n          chars = ''\n        }\n        spans.push(elem.value)\n      }\n    }\n    if (chars.length > 0) {\n      spans.push(chars)\n    }\n    return spans\n  }\n\n  /**\n   * Returns the content of the Text object as a simple string, so that the\n   * JSON serialization of an Automerge document represents text nicely.\n   */\n  toJSON() {\n    return this.toString()\n  }\n\n  /**\n   * Returns a writeable instance of this object. This instance is returned when\n   * the text object is accessed within a change callback. `context` is the\n   * proxy context that keeps track of the mutations.\n   */\n  getWriteable(context, path) {\n    if (!this[OBJECT_ID]) {\n      throw new RangeError('getWriteable() requires the objectId to be set')\n    }\n\n    const instance = instantiateText(this[OBJECT_ID], this.elems)\n    instance.context = context\n    instance.path = path\n    return instance\n  }\n\n  /**\n   * Updates the list item at position `index` to a new value `value`.\n   */\n  set (index, value) {\n    if (this.context) {\n      this.context.setListIndex(this.path, index, value)\n    } else if (!this[OBJECT_ID]) {\n      this.elems[index].value = value\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n\n  /**\n   * Inserts new list items `values` starting at position `index`.\n   */\n  insertAt(index, ...values) {\n    if (this.context) {\n      this.context.splice(this.path, index, 0, values)\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, 0, ...values.map(value => ({value})))\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n\n  /**\n   * Deletes `numDelete` list items starting at position `index`.\n   * if `numDelete` is not given, one item is deleted.\n   */\n  deleteAt(index, numDelete = 1) {\n    if (this.context) {\n      this.context.splice(this.path, index, numDelete, [])\n    } else if (!this[OBJECT_ID]) {\n      this.elems.splice(index, numDelete)\n    } else {\n      throw new TypeError('Automerge.Text object cannot be modified outside of a change block')\n    }\n    return this\n  }\n}\n\n// Read-only methods that can delegate to the JavaScript built-in array\nfor (let method of ['concat', 'every', 'filter', 'find', 'findIndex', 'forEach', 'includes',\n                    'indexOf', 'join', 'lastIndexOf', 'map', 'reduce', 'reduceRight',\n                    'slice', 'some', 'toLocaleString']) {\n  Text.prototype[method] = function (...args) {\n    const array = [...this]\n    return array[method](...args)\n  }\n}\n\nfunction instantiateText(objectId, elems) {\n  const instance = Object.create(Text.prototype)\n  instance[OBJECT_ID] = objectId\n  instance.elems = elems\n  return instance\n}\n\nmodule.exports = { Text, instantiateText }\n","const uuid = require('./uuid')\nconst Frontend = require('../frontend')\nconst { OPTIONS } = require('../frontend/constants')\nconst { encodeChange, decodeChange } = require('../backend/columnar')\nconst { isObject } = require('./common')\nlet backend = require('../backend') // mutable: can be overridden with setDefaultBackend()\n\n/**\n * Automerge.* API\n * The functions in this file constitute the publicly facing Automerge API which combines\n * the features of the Frontend (a document interface) and the backend (CRDT operations)\n */\n\nfunction init(options) {\n  if (typeof options === 'string') {\n    options = {actorId: options}\n  } else if (typeof options === 'undefined') {\n    options = {}\n  } else if (!isObject(options)) {\n    throw new TypeError(`Unsupported options for init(): ${options}`)\n  }\n  return Frontend.init(Object.assign({backend}, options))\n}\n\n/**\n * Returns a new document object initialized with the given state.\n */\nfunction from(initialState, options) {\n  const changeOpts = {message: 'Initialization'}\n  return change(init(options), changeOpts, doc => Object.assign(doc, initialState))\n}\n\nfunction change(doc, options, callback) {\n  const [newDoc] = Frontend.change(doc, options, callback)\n  return newDoc\n}\n\nfunction emptyChange(doc, options) {\n  const [newDoc] = Frontend.emptyChange(doc, options)\n  return newDoc\n}\n\nfunction clone(doc, options = {}) {\n  const state = backend.clone(Frontend.getBackendState(doc, 'clone'))\n  return applyPatch(init(options), backend.getPatch(state), state, [], options)\n}\n\nfunction free(doc) {\n  backend.free(Frontend.getBackendState(doc, 'free'))\n}\n\nfunction load(data, options = {}) {\n  const state = backend.load(data)\n  return applyPatch(init(options), backend.getPatch(state), state, [data], options)\n}\n\nfunction save(doc) {\n  return backend.save(Frontend.getBackendState(doc, 'save'))\n}\n\nfunction merge(localDoc, remoteDoc) {\n  const localState = Frontend.getBackendState(localDoc, 'merge')\n  const remoteState = Frontend.getBackendState(remoteDoc, 'merge', 'second')\n  const changes = backend.getChangesAdded(localState, remoteState)\n  const [updatedDoc] = applyChanges(localDoc, changes)\n  return updatedDoc\n}\n\nfunction getChanges(oldDoc, newDoc) {\n  const oldState = Frontend.getBackendState(oldDoc, 'getChanges')\n  const newState = Frontend.getBackendState(newDoc, 'getChanges', 'second')\n  return backend.getChanges(newState, backend.getHeads(oldState))\n}\n\nfunction getAllChanges(doc) {\n  return backend.getAllChanges(Frontend.getBackendState(doc, 'getAllChanges'))\n}\n\nfunction applyPatch(doc, patch, backendState, changes, options) {\n  const newDoc = Frontend.applyPatch(doc, patch, backendState)\n  const patchCallback = options.patchCallback || doc[OPTIONS].patchCallback\n  if (patchCallback) {\n    patchCallback(patch, doc, newDoc, false, changes)\n  }\n  return newDoc\n}\n\nfunction applyChanges(doc, changes, options = {}) {\n  const oldState = Frontend.getBackendState(doc, 'applyChanges')\n  const [newState, patch] = backend.applyChanges(oldState, changes)\n  return [applyPatch(doc, patch, newState, changes, options), patch]\n}\n\nfunction equals(val1, val2) {\n  if (!isObject(val1) || !isObject(val2)) return val1 === val2\n  const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort()\n  if (keys1.length !== keys2.length) return false\n  for (let i = 0; i < keys1.length; i++) {\n    if (keys1[i] !== keys2[i]) return false\n    if (!equals(val1[keys1[i]], val2[keys2[i]])) return false\n  }\n  return true\n}\n\nfunction getHistory(doc) {\n  const actor = Frontend.getActorId(doc)\n  const history = getAllChanges(doc)\n  return history.map((change, index) => ({\n      get change () {\n        return decodeChange(change)\n      },\n      get snapshot () {\n        const state = backend.loadChanges(backend.init(), history.slice(0, index + 1))\n        return Frontend.applyPatch(init(actor), backend.getPatch(state), state)\n      }\n    })\n  )\n}\n\nfunction generateSyncMessage(doc, syncState) {\n  const state = Frontend.getBackendState(doc, 'generateSyncMessage')\n  return backend.generateSyncMessage(state, syncState)\n}\n\nfunction receiveSyncMessage(doc, oldSyncState, message) {\n  const oldBackendState = Frontend.getBackendState(doc, 'receiveSyncMessage')\n  const [backendState, syncState, patch] = backend.receiveSyncMessage(oldBackendState, oldSyncState, message)\n  if (!patch) return [doc, syncState, patch]\n\n  // The patchCallback is passed as argument all changes that are applied.\n  // We get those from the sync message if a patchCallback is present.\n  let changes = null\n  if (doc[OPTIONS].patchCallback) {\n    changes = backend.decodeSyncMessage(message).changes\n  }\n  return [applyPatch(doc, patch, backendState, changes, {}), syncState, patch]\n}\n\nfunction initSyncState() {\n  return backend.initSyncState()\n}\n\n/**\n * Replaces the default backend implementation with a different one.\n * This allows you to switch to using the Rust/WebAssembly implementation.\n */\nfunction setDefaultBackend(newBackend) {\n  backend = newBackend\n}\n\nmodule.exports = {\n  init, from, change, emptyChange, clone, free,\n  load, save, merge, getChanges, getAllChanges, applyChanges,\n  encodeChange, decodeChange, equals, getHistory, uuid,\n  Frontend, setDefaultBackend, generateSyncMessage, receiveSyncMessage, initSyncState,\n  get Backend() { return backend }\n}\n\nfor (let name of ['getObjectId', 'getObjectById', 'getActorId',\n     'setActorId', 'getConflicts', 'getLastLocalChange',\n     'Text', 'Table', 'Counter', 'Observable', 'Int', 'Uint', 'Float64']) {\n  module.exports[name] = Frontend[name]\n}\n","function isObject(obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\n/**\n * Returns a shallow copy of the object `obj`. Faster than `Object.assign({}, obj)`.\n * https://jsperf.com/cloning-large-objects/1\n */\nfunction copyObject(obj) {\n  if (!isObject(obj)) return {}\n  let copy = {}\n  for (let key of Object.keys(obj)) {\n    copy[key] = obj[key]\n  }\n  return copy\n}\n\n/**\n * Takes a string in the form that is used to identify operations (a counter concatenated\n * with an actor ID, separated by an `@` sign) and returns an object `{counter, actorId}`.\n */\nfunction parseOpId(opId) {\n  const match = /^(\\d+)@(.*)$/.exec(opId || '')\n  if (!match) {\n    throw new RangeError(`Not a valid opId: ${opId}`)\n  }\n  return {counter: parseInt(match[1], 10), actorId: match[2]}\n}\n\n/**\n * Returns true if the two byte arrays contain the same data, false if not.\n */\nfunction equalBytes(array1, array2) {\n  if (!(array1 instanceof Uint8Array) || !(array2 instanceof Uint8Array)) {\n    throw new TypeError('equalBytes can only compare Uint8Arrays')\n  }\n  if (array1.byteLength !== array2.byteLength) return false\n  for (let i = 0; i < array1.byteLength; i++) {\n    if (array1[i] !== array2[i]) return false\n  }\n  return true\n}\n\n/**\n * Creates an array containing the value `null` repeated `length` times.\n */\nfunction createArrayOfNulls(length) {\n  const array = new Array(length)\n  for (let i = 0; i < length; i++) array[i] = null\n  return array\n}\n\nmodule.exports = {\n  isObject, copyObject, parseOpId, equalBytes, createArrayOfNulls\n}\n","const { v4: uuid } = require('uuid')\n\nfunction defaultFactory() {\n  return uuid().replace(/-/g, '')\n}\n\nlet factory = defaultFactory\n\nfunction makeUuid() {\n  return factory()\n}\n\nmakeUuid.setFactory = newFactory => { factory = newFactory }\nmakeUuid.reset = () => { factory = defaultFactory }\n\nmodule.exports = makeUuid\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [459], function() { return __webpack_require__(5601); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"d99306ff\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t601: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkautowiki\"] = self[\"webpackChunkautowiki\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(459).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["DB","name","db","this","openDB","upgrade","oldVersion","newVersion","transaction","storeNames","objectStoreNames","deleteObjectStore","changeStore","createObjectStore","keyPath","createIndex","unique","docId","hash","change","tx","store","objectStore","get","buffer","byteLength","newChange","Uint8Array","set","add","timestamp","Date","now","singleKeyRange","IDBKeyRange","only","getAllFromIndex","values","map","v","snapshot","changes","lastChangeTime","index","iterate","cursor","push","value","Math","max","decodedChanges","Map","changesByHash","d","Automerge","sortedChanges","topologicalSort","c","deps","h","serializedDoc","getDoc","length","doc","nextSerializedDoc","put","oldChangesKeyRange","upperBound","openCursor","delete","continue","xs","outgoingEdges","result","isDag","unmarked","Set","tempMarks","size","visit","next","Error","n","has","self","addEventListener","e","ports","onmessage","data","saveSnapshot","encodeChange","require","BackendDoc","backendState","hashByActor","state","actorId","hashesByActor","haveHashGraph","computeHashGraph","RangeError","getChanges","backend","haveDeps","Array","isArray","TypeError","module","exports","init","heads","clone","free","frozen","applyChanges","patch","applyLocalChange","seq","clock","actor","lastHash","Object","keys","sort","binaryChange","filter","head","save","load","loadChanges","getPatch","getHeads","getAllChanges","getChangesAdded","backend1","backend2","getChangeByHash","getMissingDeps","pako","copyObject","parseOpId","equalBytes","utf8ToString","hexStringToBytes","bytesToHexString","Encoder","Decoder","RLEEncoder","RLEDecoder","DeltaEncoder","DeltaDecoder","BooleanEncoder","BooleanDecoder","Hash","MAGIC_BYTES","COLUMN_TYPE","GROUP_CARD","ACTOR_ID","INT_RLE","INT_DELTA","BOOLEAN","STRING_RLE","VALUE_LEN","VALUE_RAW","VALUE_TYPE","NULL","FALSE","TRUE","LEB128_UINT","LEB128_INT","IEEE754","UTF8","BYTES","COUNTER","TIMESTAMP","MIN_UNKNOWN","MAX_UNKNOWN","ACTIONS","COMMON_COLUMNS","columnName","columnId","CHANGE_COLUMNS","concat","DOC_OPS_COLUMNS","DOCUMENT_COLUMNS","actorIdToActorNum","opId","actorIds","counter","actorNum","indexOf","compareParsedOpIds","id1","id2","encodeObjectId","op","columns","obj","objActor","appendValue","objCtr","JSON","stringify","encodeOperationKey","key","keyActor","keyCtr","keyStr","elemId","insert","encodeOperationAction","actionCode","action","encodeValue","valLen","numBytes","valRaw","appendRawString","ArrayBuffer","isView","appendRawBytes","datatype","buf64","DataView","setFloat64","Number","isInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","getNumberTypeAndValue","typeTag","appendUint53","appendInt53","decodeValue","sizeTag","bytes","readUint53","readInt53","view","byteOffset","getFloat64","decodeValueColumns","colIndex","decoder","readValue","readRawBytes","validDatatype","undefined","expandMultiOps","ops","startOp","opNum","expandedOps","pred","lastElemId","multiOp","startElemId","startPred","i","decodeOps","forDocument","newOps","newOp","valLen_datatype","chldCtr","chldActor","child","id","idCtr","idActor","succ","succNum","succCtr","succActor","checkSortedOpIds","predNum","predCtr","predActor","opIds","last","decoderByColumnId","makeDecoders","columnSpec","emptyBuf","decoders","columnIndex","specIndex","decodeColumns","parsedRows","some","col","done","row","groupId","groupCols","count","colOffset","decodeColumnInfo","COLUMN_ID_MASK","lastColumnId","numColumns","bufferLen","encodeColumnInfo","encoder","nonEmptyColumns","column","decodeChangeHeader","numDeps","readHexString","time","message","readPrefixedString","numActorIds","encodeContainer","chunkType","encodeContentsCallback","HEADER_SPACE","body","bodyBuf","header","appendByte","headerBuf","sha256","update","subarray","digest","checksum","decodeContainerHeader","computeHash","expectedHash","hashStartOffset","offset","readByte","chunkLength","chunkData","buf","binaryHash","changeObj","encoded","single","actors","newChanges","parseAllOpIds","slice","appendHexString","appendPrefixedString","columnList","a","b","encodeOps","extraBytes","hexHash","compressed","deflateRaw","deflateChange","decodeChangeColumns","inflateChange","chunkDecoder","restLen","WeakMap","decodeChange","decompressed","inflateRaw","splitContainers","chunks","startOffset","sortOpIds","a_","b_","decodeDocumentHeader","documentDecoder","numActors","headsIndexes","numHeads","changesColumns","opsColumns","inflateColumn","decodeDocument","changesByActor","maxOp","opsById","actorChanges","left","right","floor","op1","op2","expectedId","groupChangeOps","expectedHeads","depsNum","depsIndex","extraLen_datatype","extraLen","actualHeads","headsEqual","join","decodeDocumentChanges","deflateColumn","OBJECT_TYPE","makeMap","makeList","makeText","makeTable","encoderByColumnId","decodeChangeMeta","meta","decodeChanges","binaryChanges","decoded","chunk","encodeDocumentHeader","utf8encoder","TextEncoder","utf8decoder","TextDecoder","stringToUtf8","string","encode","decode","test","match","parseInt","NIBBLE_TO_HEX","BYTE_TO_HEX","hex","len","finish","minSize","newSize","newBuf","grow","ceil","clz32","high32","low32","appendUint64","appendInt64","appendUint32","appendInt32","appendPrefixedBytes","shift","nextByte","readUint64","readInt64","start","readPrefixedBytes","type","lastValue","literal","repetitions","_appendValue","flush","options","sumValues","sumShift","remaining","nonNullValues","sum","firstValue","numNulls","min","firstRun","readRecord","numValues","readRawValue","appendRawValue","numSkip","skipRawValues","consume","num","skip","absoluteValue","nulls","firstCopy","numCopied","receiveSyncMessage","generateSyncMessage","encodeSyncMessage","decodeSyncMessage","encodeSyncState","decodeSyncState","initSyncState","MAX_BLOCK_SIZE","BLOOM_FILTER_SIZE","BLOOM_BITS_PER_ENTRY","PRED_COLUMN_IDS","includes","deepCopyUpdate","objectTree","path","assign","seekWithinBlock","docCols","resumeInsertion","reset","objActorD","objCtrD","keyStrD","idActorD","idCtrD","insertD","actionD","succNumD","skipCount","visibleCount","elemVisible","nextObjActor","nextObjCtr","nextIdActor","nextIdCtr","nextKeyStr","nextInsert","nextSuccNum","skipValues","found","objActorIndex","visibleListElements","docState","blockIndex","objActorNum","thisBlock","blocks","nextBlock","lastObjectActor","lastObjectCtr","numVisible","lastVisibleActor","firstVisibleActor","lastVisibleCtr","firstVisibleCtr","seekToOp","totalVisible","blockActor","blockCtr","lastKey","insertAtHead","keyActorNum","bloomFilterContains","bloom","numOps","bloomFilterAdd","elemIdActor","elemIdCtr","modulo","x","y","z","updateBlockMetadata","block","keyActorD","keyCtrD","addBlockOperation","isChangeOp","succNumIdx","splitBlock","numBlocks","opsSoFar","opsToCopy","encoders","copyColumns","newBlock","concatBlocks","outCols","inCols","inIndex","lastGroup","lastCardinality","valueColumn","valueBytes","outCol","inCol","colCount","copyFrom","blankValue","readOperation","actorTable","colValue","operation","appendOperation","readNextDocOp","docOp","readNextChangeOp","changeState","changeIndex","opCtr","updateBlockColumns","getActorTable","actorIndex","nextOp","emptyObjectPatch","objectId","edits","props","opIdDelta","delta","parsed1","parsed2","appendEdit","existingEdits","nextEdit","lastEdit","appendUpdate","firstUpdate","pop","updatePatchProperty","patches","propState","listIndex","oldSuccNum","isWholeDoc","objectMeta","parentObj","parentKey","children","firstOp","visibleOps","hasChild","isOverwritten","patchKey","patchValue","prevChildren","visible","valRawIdx","objType","counterStates","counterState","succs","succOp","succCtrIdx","updates","unshift","convertInsertToUpdate","applyOps","idActorNum","objId","resetFirstVisible","idActorIndex","foundListElem","docOpsConsumed","docOpOldSuccNum","changeOp","changeOps","changeCols","predSeen","lastChangeKey","objectIds","lastOp","isOverwrite","predNumIdx","prevOp","predActorIdx","predCtrIdx","inCorrectObject","keyMatches","listElemMatches","takeDocOp","takeChangeOps","opIndex","j","splice","deleted","mergeDocChangeOps","lastBlockIndex","lastBlock","copyAfterMerge","newBlocks","every","changeCol","find","docCol","allCols","setupPatches","childMeta","patchExists","hasChildren","edit","elem","seekPos","entries","throwExceptions","changeHashes","applied","enqueued","changeIndexByHash","expectedSeq","causallyReady","dep","depIndex","documentPatch","_root","lastObjActor","lastObjCtr","appendChange","dependenciesByHash","dependentsByHash","queue","actorD","seqD","depsNumD","depsIndexD","numChanges","actorNums","headIndexes","headActors","readDocumentChanges","binaryDoc","changesEncoders","initPatch","copy","reduce","acc","k","changeBuffers","isLocal","allApplied","pendingChanges","diffs","stack","seenHashes","toReturn","successors","other","reverse","allDeps","inQueue","missing","newEncoders","Backend","BloomFilter","arg","numEntries","numBitsPerEntry","numProbes","bits","addHash","readUint32","hashBytes","probes","getProbes","probe","encodeHashes","hashes","decodeHashes","need","have","lastSync","messageType","haveCount","changeCount","makeBloomFilter","sharedHeads","lastSentHeads","theirHeads","theirNeed","theirHave","sentHashes","compareArrays","oldSyncState","binaryMessage","beforeHeads","myOldHeads","myNewHeads","ourOldSharedHeads","newHeads","commonHeads","advanceHeads","knownHeads","syncState","ourHeads","ourNeed","ourHave","changesToSend","lastSyncHashes","bloomFilters","dependents","hashesToSend","containsHash","getChangesToSend","headsUnchanged","syncMessage","recordType","isObject","OBJECT_ID","CONFLICTS","ELEM_IDS","instantiateText","instantiateTable","Counter","getValue","object","updated","interpretPatch","lamportCompare","ts1","ts2","regex","time1","time2","cloneMapObject","originalObject","conflicts","defineProperty","updateMapObject","subpatch","applyProperties","updateListObject","originalList","list","elemIds","cloneListObject","oldValue","conflict","oldValue2","newElems","newValues","newConflicts","forEach","_clone","remove","_set","byId","updateTableObject","elems","updateTextObject","cloneRootObject","root","OPTIONS","Symbol","CACHE","STATE","CHANGE","Text","Table","getWriteableCounter","Int","Uint","Float64","createArrayOfNulls","uuid","Context","applyPatch","nextOpNum","cache","getTime","getObjectType","getValueDescription","getElemId","getObject","pathElem","getValuesDescriptions","nextOpId","getPropertyValue","childId","subpath","instantiateObject","addOp","insertListItems","nested","valuePatch","setValue","description","createNestedObjects","callback","diff","getSubpatch","applyAtPath","getPred","newObject","allPrimitive","allValueDescriptions","allDatatypesSame","t","nextElemId","insertions","deletions","lastElemParsed","lastPredParsed","getObjectField","thisElem","thisElemParsed","thisPred","thisPredParsed","rowId","freeze","valueOf","toString","WriteableCounter","context","increment","instance","create","prototype","rootObjectProxy","Observable","checkActorId","updateRootObject","newDoc","_freeze","makeChange","getActorId","round","lastLocalChange","applyPatchToDoc","patchCallback","queuedRequest","before","requests","countOps","fromBackend","deferActorId","observable","after","local","from","initialState","emptyChange","baseDoc","getObjectId","getObjectById","setActorId","getConflicts","getLastLocalChange","getBackendState","callerName","argPos","extraMsg","getElementIds","observers","_objectUpdate","propName","parseListIndex","isNaN","Infinity","MapHandler","target","readonly","setMapKey","deleteProperty","deleteMapKey","getOwnPropertyDescriptor","configurable","enumerable","ownKeys","ListHandler","iterator","listId","methods","deleteAt","numDelete","fill","end","setListIndex","o","insertAt","first","deleteCount","method","item","listMethods","writable","mapProxy","Proxy","instantiateProxy","listProxy","getWriteable","compareRows","properties","row1","row2","prop","prop1","prop2","entry","ids","thisArg","rows","isFrozen","WriteableTable","addTableRow","deleteTableRow","text","str","spans","chars","array","Frontend","oldState","newState","merge","localDoc","remoteDoc","localState","remoteState","oldDoc","equals","val1","val2","keys1","keys2","getHistory","history","setDefaultBackend","newBackend","oldBackendState","exec","array1","array2","v4","defaultFactory","replace","factory","makeUuid","setFactory","newFactory","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","r","getter","__esModule","definition","f","chunkId","Promise","all","promises","u","miniCssF","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}