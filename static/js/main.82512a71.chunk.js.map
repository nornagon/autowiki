{"version":3,"sources":["Replicate.tsx","PageText.tsx","App.tsx","textarea-op.ts","serviceWorker.ts","index.tsx"],"names":["ReplicationPeer","doc","peer","onStateChange","stateChange","useRef","useEffect","current","protocol","window","location","exec","key","host","params","wsProvider","WebsocketProvider","lastState","setState","s","on","event","status","synced","destroy","e","alert","Replicate","peers","map","p","makeCheckboxesEnabled","tree","visit","type","tagName","properties","node","disabled","imageBlobReferences","getBlobURL","src","startsWith","split","pipeline","unified","use","markdown","highlight","wikiLink","hrefTemplate","link","pageResolver","name","wikiLinkClassName","remarkTruncateLinks","length","remark2rehype","allowDangerousHtml","handlers","code","h","value","lang","match","props","className","position","start","offset","u","inlineCode","replace","text","augment","String","raw","stringify","PageText","html","useMemo","processSync","toString","renderMarkdownToHtml","dangerouslySetInnerHTML","__html","extractLinks","parse","links","push","href","allPages","rootDoc","Y","gc","indexeddbProvider","IndexeddbPersistence","requestPersistentStorage","persistentStorageRequested","a","navigator","storage","persist","console","warn","getMap","keys","k","get","f","ExpandingTextArea","forwardRef","opts","ref","fnvHashInt32s","int32s","bytes","hash","Math","imul","fnvHash","Uint32Array","from","findNearestParent","fn","Element","parentElement","Page","title","useState","selected","setSelected","editing","setEditing","initial","has","v","transact","set","useReducer","x","forceUpdate","txn","observeDeep","unobserveDeep","useStorage","r","data","changeData","selectedEl","scrollIntoView","block","l","addEventListener","removeEventListener","preventDefault","requestAnimationFrame","textarea","setSelectionRange","blur","target","toArray","i","id","client","clock","mixedId","_item","lastId","padStart","onClick","nodeName","getAttribute","toLowerCase","nextElementSibling","hasAttribute","d","pos","str","delete","insert","n","getSelection","anchorNode","anchorOffset","nearestPos","off","onClickBlock","substr","autoFocus","onKeyDown","currentTarget","selectionStart","selectionEnd","prev","prevLength","onChange","op","element","previous","end","slice","getInputEnd","charAt","removed","inserted","opFromInput","onPaste","clipboardData","items","item","mimeType","relStart","relEnd","getAsFile","arrayBuffer","buf","crypto","subtle","digest","digestStr","Uint8Array","join","blobs","absStart","absEnd","index","trim","MetaPage","page","rest","meta","Object","prototype","hasOwnProperty","call","MetaPages","all","filter","some","sort","b","localeCompare","style","width","height","objectFit","alt","export","document","createElement","setAttribute","Date","now","exportObj","_autowiki","version","wiki","toJSON","fromEntries","entries","b64","exportData","JSON","blobURL","URL","createObjectURL","Blob","click","setTimeout","revokeObjectURL","input","onchange","files","then","TextDecoder","decode","json","existingPages","Set","added","replaced","newBlobs","log","warnStr","values","confirm","existingPage","every","arr","blob","blobURLs","Map","Backlinks","backlinks","backlinksByPage","backlinkingPages","encodeURIComponent","context","ReplicationStateIndicator","state","aggregateState","reduce","m","o","top","right","display","justifyContent","alignItems","borderRadius","backgroundColor","App","setSynced","whenSynced","pathname","setPathname","handlePopState","history","pushState","scrollTo","useHistory","navigate","localStorage","getItem","setPeers","peerState","setPeerState","pageTitle","decodeURIComponent","HTMLElement","classList","contains","getBlocksLinkingTo","newPeers","prompt","setItem","Boolean","hostname","ReactDOM","render","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.82512a71.chunk.js","sourcesContent":["import React, { useRef, useEffect } from 'react'\nimport { WebsocketProvider } from 'y-websocket';\nimport * as Y from 'yjs';\n\nexport type ReplicationState = 'offline' | 'synced' | 'behind'\n\nfunction ReplicationPeer({doc, peer, onStateChange}: {doc: Y.Doc, peer: string, onStateChange: (s: ReplicationState) => void}) {\n  const stateChange = useRef(onStateChange)\n  useEffect(() => { stateChange.current = onStateChange }, [onStateChange])\n  useEffect(() => {\n    const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws'\n    const [, key, host] = /^(?:([^@]+)@)?(.+)$/.exec(peer)!\n    const params: Record<string, string> = key ? { key } : {}\n    try {\n      const wsProvider = new WebsocketProvider(`${protocol}://${host}`, 'autowiki', doc, { params })\n      let lastState: ReplicationState | null = null\n      function setState(s: ReplicationState) {\n        if (s !== lastState)\n          stateChange.current(s)\n        lastState = s\n      }\n      setState('offline')\n      wsProvider.on('status', (event: { status: 'connected' | 'disconnected' }) => {\n        if (event.status === 'connected') {\n          setState('behind')\n        } else if (event.status === 'disconnected') {\n          setState('offline')\n        }\n      })\n      wsProvider.on('sync', (synced: boolean) => {\n        if (!synced && lastState === 'synced') setState('behind')\n        if (synced) setState('synced')\n      })\n      return () => {\n        wsProvider.destroy()\n      }\n    } catch (e) {\n      alert(`Error connecting to replication peer: ${e}`)\n    }\n  }, [peer, doc])\n  return null\n}\n\nexport function Replicate({doc, peers, onStateChange}: {doc: Y.Doc, peers: string[], onStateChange: (peer: string, state: ReplicationState) => void}) {\n  return <>{peers.map(p => <ReplicationPeer doc={doc} peer={p} key={p} onStateChange={s => onStateChange(p, s)} />)}</>\n}","import React, { useMemo } from \"react\"\n\nimport markdown from 'remark-parse';\nimport remark2rehype from 'remark-rehype';\nimport highlight from 'remark-highlight.js';\nimport raw from 'rehype-raw';\nimport stringify from 'rehype-stringify';\nimport unified from 'unified';\nimport u from 'unist-builder'\nimport visit from 'unist-util-visit';\nimport wikiLink from 'remark-wiki-link';\nimport { remarkTruncateLinks } from 'remark-truncate-links';\nimport 'highlight.js/styles/github.css';\n\n\nfunction makeCheckboxesEnabled() {\n  return function(tree: any) {\n    visit(tree, ((e: any) => e.type === 'element' && e.tagName === 'input' && e.properties.type === 'checkbox') as any, (node) => {\n      delete (node as any).properties.disabled\n    })\n  }\n}\n\nfunction imageBlobReferences({getBlobURL}: {getBlobURL?: (hash: string) => string | undefined}) {\n  return function(tree: any) {\n    if (getBlobURL) {\n      visit(tree, ((e: any) => e.type === 'element' && e.tagName === 'img' && e.properties.src.startsWith('blob:')) as any, (node: any) => {\n        node.properties.src = getBlobURL(node.properties.src.split(':')[1])\n      })\n    }\n  }\n}\n\nfunction pipeline(getBlobURL?: (hash: string) => string | undefined) {\n  return unified()\n    .use(markdown)\n    .use(highlight)\n    .use(wikiLink, {\n      hrefTemplate: (link: string) => `/${link}`,\n      pageResolver: (name: string) => [name],\n      wikiLinkClassName: 'wikilink',\n    })\n    .use(remarkTruncateLinks, { length: 60 })\n    .use(remark2rehype, {\n      allowDangerousHtml: true,\n      handlers: {\n        code(h, node) {\n          var value = node.value ? node.value + '\\n' : ''\n          var lang = node.lang && (node.lang as any).match(/^[^ \\t]+(?=[ \\t]|$)/)\n          var props: any = {}\n\n          if (lang) {\n            props.className = ['language-' + lang]\n          }\n          props['x-pos'] = node.position!.start.offset! + 4 + (lang?.length ?? 0)\n\n          return h((node as any).position, 'pre', [h(node, 'code', props, [u('text', value)])])\n        },\n        inlineCode(h, node: any) {\n          var value = node.value.replace(/\\r?\\n|\\r/g, ' ')\n          return h(node, 'code', {'x-pos': node.position?.start.offset + 1}, [u('text', value)])\n        },\n        text(h, node) {\n          return h.augment(\n            node,\n            u('element',\n              {tagName: 'span', properties: {'x-pos': node.position?.start.offset}},\n              [u('text', String(node.value).replace(/[ \\t]*(\\r?\\n|\\r)[ \\t]*/g, '$1'))])\n          )\n        }\n      }\n    })\n    .use(makeCheckboxesEnabled)\n    .use(raw)\n    .use(imageBlobReferences, {getBlobURL})\n    .use(stringify)\n}\n\nfunction renderMarkdownToHtml(text: string, getBlobURL?: (hash: string) => string | undefined) {\n  return pipeline(getBlobURL)\n    .processSync(text)\n    .toString('utf8')\n}\n\nexport default function PageText({text, getBlobURL}: {text: string, getBlobURL?: (hash: string) => string | undefined}) {\n  const html = useMemo(() => {\n    return renderMarkdownToHtml(text, getBlobURL)\n  }, [text])\n  return <div dangerouslySetInnerHTML={ { __html: html } } />\n}\n\nexport function extractLinks(text: string): any[] {\n  const tree = pipeline().parse(text)\n  const links: {href: string}[] = []\n  visit(tree, 'wikiLink', (node) => {\n    links.push({href: node.value as string})\n  })\n  return links\n}\n","import React, { useEffect, useState, useMemo, useReducer, useRef, forwardRef } from 'react';\nimport './App.css';\nimport * as Y from 'yjs';\nimport { IndexeddbPersistence } from 'y-indexeddb'\nimport { opFromInput } from './textarea-op';\nimport { Replicate, ReplicationState } from './Replicate';\nimport PageText, { extractLinks } from './PageText';\nimport * as b64 from 'base64-arraybuffer';\n\ntype Page = Y.Array<Y.Text>\n\nconst rootDoc = new Y.Doc()\nrootDoc.gc = false\n;(window as any).rootDoc = rootDoc\n\nconst EXPORT_VERSION = 1\n\nconst indexeddbProvider = new IndexeddbPersistence('autowiki', rootDoc)\n\nconst useHistory = (): [string, (s: string) => void] => {\n  const [pathname, setPathname] = useState(window.location.pathname)\n  function handlePopState() {\n    setPathname(window.location.pathname)\n  }\n  function navigate(href: string) {\n    window.history.pushState(null, '', href)\n    setPathname(window.location.pathname)\n    window.scrollTo(0, 0)\n  }\n  useEffect(() => {\n    window.addEventListener('popstate', handlePopState)\n    return () => {\n      window.removeEventListener('popstate', handlePopState)\n    }\n  }, [])\n  return [pathname, navigate]\n}\n\nconst requestPersistentStorage = (() => {\n  let persistentStorageRequested = false\n  return async function requestPersistentStorage() {\n    if (!persistentStorageRequested) {\n      persistentStorageRequested = true\n      if (navigator.storage && navigator.storage.persist) {\n        const isPersisted = await navigator.storage.persist()\n        if (!isPersisted) {\n          // TODO: warn the user more clearly\n          console.warn(\"Navigator declined persistent storage\")\n        }\n      } else {\n        console.warn(\"Navigator does not support persistent storage\")\n      }\n    }\n  }\n})()\n\nfunction useStorage<T>(key: string, initial: () => T): [T, (f: (t: T) => void) => void] {\n  const map = rootDoc.getMap('wiki')\n  if (!map.has(key)) {\n    const v = initial()\n    rootDoc.transact(() => {\n      map.set(key, v)\n    })\n  }\n  function change(f: (t: T) => void) {\n    requestPersistentStorage()\n    rootDoc.transact(() => {\n      f(map.get(key))\n    })\n  }\n  const [, forceUpdate] = useReducer(x => x + 1, 0);\n  useEffect(() => {\n    const fn = (event: any, txn: Y.Transaction) => {\n      forceUpdate()\n    }\n    map.observeDeep(fn)\n    return () => {\n      map.unobserveDeep(fn)\n    }\n  })\n  return [map.get(key), change]\n}\n\nfunction* allPages(): Generator<[string, Page], any, unknown> {\n  const doc = rootDoc.getMap('wiki')\n  for (const k of doc.keys()) {\n    yield [k, doc.get(k)]\n  }\n}\n\nfunction ExpandingTextAreaUnforwarded(opts: React.DetailedHTMLProps<React.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement>, ref: any) {\n  return (\n    <div className=\"expandingArea\">\n      <pre><span>{opts.value}</span><br/></pre>\n      <textarea {...opts} ref={ref}></textarea>\n    </div>\n  )\n}\nconst ExpandingTextArea = forwardRef(ExpandingTextAreaUnforwarded)\n\n// http://isthe.com/chongo/tech/comp/fnv/\n// FNV1a:\n// hash = offset_basis\n// for each octet_of_data to be hashed\n//   hash = hash xor octet_of_data\n//   hash = hash * FNV_prime\n// return hash\n// 32 bit FNV_prime = 224 + 28 + 0x93 = 16777619\n// 32 bit offset_basis = 2166136261\nfunction fnvHash(bytes: Iterable<number>): number {\n  const offset_basis = 2166136261\n  const FNV_prime = 16777619\n  let hash = offset_basis\n  for (const byte of bytes) {\n    hash = hash ^ byte\n    hash = Math.imul(hash, FNV_prime)\n  }\n  return hash >>> 0\n}\n\nfunction fnvHashInt32s(int32s: number[]): number {\n  return fnvHash(Uint32Array.from(int32s))\n}\n\nfunction mixedId(id: Y.ID): number {\n  return id ? fnvHashInt32s([id.client, id.clock]) : 0\n}\n\nfunction findNearestParent(node: Node, fn: (n: Element) => boolean): Element | null {\n  let e: Element | null = node instanceof Element ? node : node.parentElement\n  while (e && !fn(e)) {\n    e = e.parentElement\n  }\n  return e\n}\n\nfunction Page({title}: {title: string}) {\n  const [selected, setSelected] = useState(null as number | null)\n  const [editing, setEditing] = useState(false)\n  const [data, changeData] = useStorage<Y.Array<Y.Text>>(title, () => {\n    const r = new Y.Array<Y.Text>()\n    r.push([new Y.Text()])\n    return r\n  })\n  const selectedEl = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    if (selectedEl.current) {\n      selectedEl.current.scrollIntoView({block: \"nearest\"})\n    }\n  }, [selected])\n\n  useEffect(() => {\n    if (!editing) {\n      const l = (e: KeyboardEvent) => {\n        if (e.key === 'ArrowUp') {\n          if (selected === 0) setSelected(null)\n          else if (selected === null) setSelected(data.length - 1)\n          else setSelected(selected - 1)\n          e.preventDefault()\n        } else if (e.key === 'ArrowDown') {\n          if (selected === data.length - 1) setSelected(null)\n          else if (selected === null) setSelected(0)\n          else setSelected(selected + 1)\n          e.preventDefault()\n        } else if (e.key === 'Enter' && selected !== null) {\n          setEditing(true)\n          requestAnimationFrame(() => {\n            if (textarea.current) {\n              const length = textarea.current.value.length\n              textarea.current.setSelectionRange(length, length)\n            }\n          })\n          e.preventDefault()\n        } else if (e.key === 'Escape') {\n          setSelected(null)\n          e.preventDefault()\n        }\n      }\n      window.addEventListener('keydown', l)\n      return () => {\n        window.removeEventListener('keydown', l)\n      }\n    } else {\n      const l = (e: KeyboardEvent) => {\n        if (e.key === 'Escape') {\n          setEditing(false)\n        }\n      }\n      window.addEventListener('keydown', l)\n      return () => {\n        window.removeEventListener('keydown', l)\n      }\n    }\n  }, [selected, editing, data.length])\n\n  useEffect(() => {\n    function blur(e: MouseEvent) {\n      if (editing && textarea.current && e.target !== textarea.current) {\n        setEditing(false)\n        setSelected(null)\n      } else if (!editing && !findNearestParent(e.target as Element, e => e.className === 'Page')) {\n        setEditing(false)\n        setSelected(null)\n      }\n    }\n    window.addEventListener('mousedown', blur)\n    return () => {\n      window.removeEventListener('mousedown', blur)\n    }\n  }, [editing])\n  const textarea = useRef<HTMLTextAreaElement>(null)\n\n  function onClickBlock(e: React.MouseEvent<HTMLDivElement>, i: number) {\n    if (e.target instanceof Element && e.target.nodeName === 'INPUT' && e.target.getAttribute('type')?.toLowerCase() === 'checkbox') {\n      const { nextElementSibling } = e.target\n      if (nextElementSibling && nextElementSibling.hasAttribute('x-pos')) {\n        changeData(d => {\n          // TODO: this is a hack, we should encode the source position of the checkbox during parsing\n          const text = d.get(i)\n          const pos = +nextElementSibling.getAttribute('x-pos')! - 3\n          const str = text.toString()\n          if (str[pos] === ' ') {\n            text.delete(pos, 1)\n            text.insert(pos, 'x')\n          } else if (str[pos] === 'x') {\n            text.delete(pos, 1)\n            text.insert(pos, ' ')\n          }\n        })\n      }\n      e.preventDefault()\n      return\n    }\n    if (e.target instanceof Element && (findNearestParent(e.target, n => n.nodeName === 'A') || e.target.nodeName === 'SUMMARY')) {\n      return\n    }\n    setSelected(i)\n    setEditing(true)\n    // anchorNode is the node in which the selection begins. (focusNode is where it ends.)\n    const { anchorNode, anchorOffset } = window.getSelection() ?? {}\n    if (anchorNode) {\n      const nearestPos = findNearestParent(anchorNode, e => e.hasAttribute('x-pos'))\n      if (nearestPos) {\n        const off = +(nearestPos.getAttribute('x-pos')!) + anchorOffset!\n        requestAnimationFrame(() => {\n          textarea.current?.setSelectionRange(off, off)\n        })\n      }\n    }\n  }\n\n  return <article className=\"Page\">\n    <h1>{title}</h1>\n    {data.toArray().map((text, i) => {\n      const idNum = mixedId(text._item?.lastId ?? {client: 0, clock: 0})\n      const id = idNum.toString(16).padStart(8, '0')\n      return <div className={`para ${selected === i ? \"selected\" : \"\"}`} ref={selected === i ? selectedEl : null} onClick={e => onClickBlock(e, i)}>\n        <div className=\"id\"><a id={id} href={`#${id}`} title={id}>{id?.substr(0, 3) ?? ''}</a></div>\n        {editing && selected === i\n        ? <ExpandingTextArea\n            ref={textarea}\n            value={text.toString()}\n            autoFocus\n            onKeyDown={e => {\n              const { currentTarget } = e\n              const { selectionStart, selectionEnd } = currentTarget\n              if (e.key === 'Backspace' && selectionStart === 0 && selectionEnd === 0 && selected > 0) {\n                // merge paras\n                changeData(d => {\n                  const prev = d.get(selected - 1)\n                  const prevLength = prev.length\n                  prev.insert(prev.length, d.get(selected).toString())\n                  d.delete(selected, 1)\n                  requestAnimationFrame(() => {\n                    textarea.current?.setSelectionRange(prevLength, prevLength)\n                  })\n                })\n                setSelected(selected - 1)\n              }\n              if (e.key === '[') {\n                changeData(d => {\n                  d.get(selected).insert(selectionEnd, ']')\n                  d.get(selected).insert(selectionStart, '[')\n                })\n                requestAnimationFrame(() => currentTarget.setSelectionRange(selectionStart + 1, selectionEnd + 1))\n                e.preventDefault()\n              } else if (e.key === ']' && selectionStart === selectionEnd && currentTarget.value[selectionStart] === ']') {\n                e.preventDefault()\n                currentTarget.setSelectionRange(selectionStart + 1, selectionStart + 1)\n              }\n            }}\n            onChange={e => {\n              const op = opFromInput(e.target, text?.toString() ?? '')\n              if (op && op.inserted === '\\n' && op.removed == null && e.target.value.substr(op.start - 1, 2) === '\\n\\n') {\n                changeData(d => {\n                  //const str = d[selected].toString().substr(op.start);\n                  const str = d.get(selected).toString().substr(op.start, d.get(selected).length - op.start + 1)\n                  d.get(selected).delete(op.start - 1, d.get(selected).length - op.start + 1)\n                  d.insert(selected + 1, [new Y.Text(str)])\n                })\n                setSelected(selected + 1)\n                return\n              }\n              if (op) {\n                changeData(d => {\n                  const {start, removed, inserted} = op\n                  if (removed != null) {\n                    d.get(selected).delete(start, removed.length)\n                  }\n                  if (inserted != null) {\n                    d.get(selected).insert(start, inserted)\n                  }\n                })\n              }\n            }}\n            onPaste={e => {\n              const { currentTarget } = e\n              const { selectionStart, selectionEnd } = currentTarget\n              for (const item of e.clipboardData.items) {\n                const mimeType = item.type\n                if (mimeType.startsWith('image/')) {\n                  e.preventDefault()\n                  changeData(d => {\n                    const text = d.get(selected)\n                    if (selectionEnd !== selectionStart)\n                      text.delete(selectionStart, selectionEnd - selectionStart)\n                    text.insert(selectionStart, '![](...)')\n                  })\n                  const relStart = Y.createRelativePositionFromTypeIndex(data.get(selected), selectionStart + 4)\n                  const relEnd = Y.createRelativePositionFromTypeIndex(data.get(selected), selectionStart + 7)\n                  ;(async () => {\n                    const buf = await (item.getAsFile() as any).arrayBuffer()\n                    const digest = await crypto.subtle.digest('SHA-256', buf!)\n                    const digestStr = [...new Uint8Array(digest)].map(x => x.toString(16).padStart(2, '0')).join('')\n                    const blobs = rootDoc.getMap('blobs')\n                    rootDoc.transact(() => {\n                      if (!blobs.has(digestStr)) {\n                        blobs.set(digestStr, {data: new Uint8Array(buf), type: mimeType})\n                      }\n                      const text = data.get(selected)\n                      const absStart = Y.createAbsolutePositionFromRelativePosition(relStart, rootDoc)\n                      const absEnd = Y.createAbsolutePositionFromRelativePosition(relEnd, rootDoc)\n                      if (absStart && absEnd) {\n                        text.delete(absStart.index, absEnd.index - absStart.index)\n                        text.insert(absStart.index, `blob:${digestStr}`)\n                      }\n                    })\n                  })()\n                  break;\n                }\n              }\n            }}\n            />\n        : text.toString()?.trim()\n        ? <PageText\n            text={text.toString()}\n            getBlobURL={getBlobURL} />\n        : '\\u00a0'}\n      </div>\n    })}\n  </article>\n}\n\nfunction isValidMetaPage(x: any): x is keyof typeof MetaPages {\n  return Object.prototype.hasOwnProperty.call(MetaPages, x)\n}\n\nfunction MetaPage({page, ...rest}: {page: string}) {\n  const [, meta] = /^meta:(.+)$/.exec(page) ?? []\n  if (isValidMetaPage(meta)) {\n    const Page = MetaPages[meta]\n    return <Page {...rest} />\n  } else {\n    return <>Unknown 'meta' page: {meta}</>\n  }\n}\n\nconst MetaPages = {\n  all: () => {\n    return <div className=\"Page\">\n      <h1>All Pages</h1>\n      <ul>\n        {[...allPages()].filter(x => x[1].toArray().some(x => x.length > 0)).sort((a, b) => a[0].localeCompare(b[0])).map(([title, page]) => {\n          return <li><a href={`/${title}`} className=\"wikilink\">{title}</a></li>\n        })}\n      </ul>\n    </div>\n  },\n  blobs: () => {\n    return <div className=\"Page\">\n      <h1>Blobs</h1>\n      <ul>\n        {[...rootDoc.getMap(\"blobs\").keys()].map(hash => {\n          return <li><img src={getBlobURL(hash)} style={{width: 256, height: 256, objectFit: 'cover'}} alt={hash}/></li>\n        })}\n      </ul>\n    </div>\n  },\n  export: () => {\n    function doImport() {\n      const input = document.createElement('input')\n      input.setAttribute('type', 'file')\n      input.setAttribute('hidden', 'hidden')\n      input.onchange = (e) => {\n        if (input.files?.length) {\n          (input.files[0] as any).arrayBuffer().then((buf: ArrayBuffer) => {\n            const bytes = new Uint8Array(buf)\n            if (bytes[0] !== 0x7b /* { */) {\n              alert(\"That doesn't look like a valid Autowiki export.\")\n              return\n            }\n            const str = (new TextDecoder()).decode(buf)\n            let json: any = null\n            try {\n              json = JSON.parse(str)\n            } catch (e) {\n              alert(\"That doesn't look like a valid Autowiki export.\")\n              return\n            }\n            if (!json._autowiki) {\n              alert(\"That doesn't look like a valid Autowiki export.\")\n              return\n            }\n            if (json._autowiki.version > EXPORT_VERSION) {\n              alert(\"That file is too new for this version of Autowiki :(\")\n              return\n            }\n            const existingPages = new Set(rootDoc.getMap('wiki').keys())\n            const added = Object.keys(json.wiki).filter(k => !existingPages.has(k))\n            const replaced = Object.keys(json.wiki).filter(k => existingPages.has(k))\n            const blobs = rootDoc.getMap('blobs')\n            const newBlobs = Object.keys(json.blobs).filter(k => !blobs.has(k))\n            console.log(added, replaced, newBlobs)\n            const warn = [\n              {name: 'new page', values: added},\n              {name: 'replaced page', values: replaced},\n              {name: 'new blob', values: newBlobs}\n            ]\n            const warnStr = `This import contains ${warn.map(({name, values}) => `${values.length} ${name}${values.length === 1 ? '' : 's'}`).join(', ')}. Go ahead?`\n            if (!window.confirm(warnStr)) {\n              alert('Import cancelled.')\n              return\n            }\n            rootDoc.transact(() => {\n              const wiki: Y.Map<Y.Array<Y.Text>> = rootDoc.getMap('wiki')\n              for (const [page, data] of Object.entries<string[]>(json.wiki)) {\n                const existingPage = wiki.get(page)\n                if (existingPage?.length === data.length && existingPage?.toArray().every((x, i) => x.toString() === data[i]))\n                  continue\n                const arr = new Y.Array<Y.Text>()\n                arr.push(data.map(str => new Y.Text(str)))\n                wiki.set(page, arr)\n              }\n              type BlobData = {data: Uint8Array, type: string}\n              const blobs: Y.Map<BlobData> = rootDoc.getMap('blobs')\n              for (const [hash, blob] of Object.entries<any>(json.blobs)) {\n                if (blobs.has(hash))\n                  continue\n                blobs.set(hash, {\n                  ...blob,\n                  data: new Uint8Array(b64.decode(blob.data))\n                })\n              }\n            })\n            console.log(rootDoc.toJSON())\n            alert('Import complete.')\n          })\n        }\n      }\n      input.click()\n    }\n    function doExport() {\n      const a = document.createElement('a')\n      a.setAttribute('download', `autowiki-export-${(Date.now()/1000)|0}.json`)\n      const exportObj = {\n        _autowiki: { version: EXPORT_VERSION },\n        wiki: rootDoc.getMap('wiki').toJSON(),\n        blobs: Object.fromEntries([\n          ...Object.entries(rootDoc.getMap('blobs').toJSON())\n        ].map(([k, v]: [string, any]) => [k, {...v, data: b64.encode(v.data)}])),\n      }\n      const exportData = JSON.stringify(exportObj)\n      const blobURL = URL.createObjectURL(new Blob([exportData], {type: 'application/json'}))\n      a.setAttribute('href', blobURL)\n      a.click()\n      setTimeout(() => {\n        URL.revokeObjectURL(blobURL)\n      }, 10000)\n    }\n    return <div className=\"Page\">\n      <h1>Export/Import</h1>\n      <p>\n        <button onClick={doExport}>export</button>\n      </p>\n      <p>\n        <button onClick={doImport}>import</button>\n      </p>\n    </div>\n  }\n}\n\nconst blobURLs = new Map<string, string>()\nfunction getBlobURL(hash: string): string | undefined {\n  if (!blobURLs.has(hash)) {\n    const blob = rootDoc.getMap('blobs').get(hash)\n    if (blob && blob.data instanceof Uint8Array) {\n      const data = blob.data\n      const type = blob.type\n      blobURLs.set(hash, URL.createObjectURL(new Blob([data], { type })))\n    }\n  }\n  return blobURLs.get(hash)\n}\n\nfunction Backlinks({backlinks}: {backlinks: LinkInfo[]}) {\n  const backlinksByPage = useMemo(() => {\n    const backlinksByPage = new Map<string, LinkInfo[]>()\n    for (const l of backlinks) {\n      if (!backlinksByPage.has(l.page)) {\n        backlinksByPage.set(l.page, [])\n      }\n      backlinksByPage.get(l.page)!.push(l)\n    }\n    return backlinksByPage\n  }, [backlinks])\n  const backlinkingPages = [...backlinksByPage.keys()].sort()\n  return <article className=\"Page\">\n    <h4>References</h4>\n    {backlinkingPages.length === 0 ? <p><em>No pages link here.</em></p> : null}\n    <ul>\n      {backlinkingPages.map(page => <li key={page}>\n        <a href={encodeURIComponent(page)} className=\"wikilink\">{page}</a>:\n        <ul>{backlinksByPage.get(page)!.map((l, i) => <li key={i}><PageText text={l.context} /></li>)}</ul>\n      </li>)}\n    </ul>\n  </article>\n}\n\ntype LinkInfo = {page: string, context: string}\n\nfunction getBlocksLinkingTo(pageTitle: string): LinkInfo[] {\n  const links: LinkInfo[] = []\n  for (const [k, v] of allPages()) {\n    if (k === pageTitle) continue\n    for (const block of v) {\n      for (const link of extractLinks(block.toString())) {\n        if (link.href === pageTitle)\n          links.push({page: k, context: block.toString()})\n      }\n    }\n  }\n  return links\n}\n\nfunction useDocumentTitle(title: string) {\n  useEffect(() => {\n    document.title = title;\n  }, [title])\n}\n\nfunction ReplicationStateIndicator({state, onClick}: {state: Record<string, ReplicationState>, onClick?: React.MouseEventHandler<HTMLDivElement>}) {\n  const aggregateState = Object.values(state).reduce((m, o) => {\n    if (m === 'offline') {\n      return o !== 'offline' ? o : m\n    } else if (m === 'behind') {\n      return 'behind'\n    } else if (m === 'synced') {\n      return o === 'behind' ? o : m\n    }\n    return m\n  }, 'offline' as ReplicationState)\n  return <div style={{position: 'absolute', top: 20, right: 20, display: 'flex', justifyContent: 'center', alignItems: 'center'}} onClick={onClick}>\n    <div style={{borderRadius: 999, width: 10, height: 10, backgroundColor: aggregateState === 'offline' ? 'red' : aggregateState === 'behind' ? 'orange' : 'green'}} />\n  </div>\n}\n\nfunction App() {\n  const [synced, setSynced] = useState(false)\n  useEffect(() => {\n    indexeddbProvider.whenSynced.then(() => {\n      setSynced(true)\n    })\n  }, [])\n  const [pathname, navigate] = useHistory()\n  const [peers, setPeers] = useState<string[]>(() => JSON.parse(localStorage.getItem('peers') ?? '[]'))\n  const [peerState, setPeerState] = useState<Record<string, ReplicationState>>({})\n  const pageTitle = decodeURIComponent(pathname.substr(1))\n  useDocumentTitle(pageTitle)\n\n  useEffect(() => {\n    function onClick(e: MouseEvent) {\n      if (e.target instanceof HTMLElement) {\n        if (e.target.tagName.toLowerCase() === 'a' && e.target.classList.contains('wikilink')) {\n          const target = e.target.getAttribute('href')\n          if (target) {\n            navigate(target)\n            e.preventDefault()\n            return\n          }\n        }\n      }\n    }\n    window.addEventListener('click', onClick)\n    return () => {\n      window.removeEventListener('click', onClick)\n    }\n  }, [navigate])\n\n  // TODO: this also depends on the other docs, but for now let's only recalculate it when you navigate.\n  const backlinks = useMemo(() => getBlocksLinkingTo(pageTitle), [pageTitle, synced])\n  if (!synced) return <>Loading...</>\n\n  return <>\n    <Replicate doc={rootDoc} peers={peers} onStateChange={(peer, state) => { setPeerState(s => ({...s, [peer]: state})) }} />\n    {pageTitle.startsWith('meta:') ? <MetaPage page={pageTitle} /> : <>\n      <Page key={pageTitle} title={pageTitle} />\n      <Backlinks backlinks={backlinks} />\n    </>}\n    <ReplicationStateIndicator state={peerState} onClick={() => {\n      const newPeers = (prompt(\"Peers?\", peers.join(','))?.split(',') ?? []).map(x => x.trim()).filter(x => x)\n      setPeers(newPeers)\n      localStorage.setItem('peers', JSON.stringify(newPeers))\n    }} />\n  </>;\n}\n\nexport default App;\n","\nfunction getInputEnd(element: HTMLTextAreaElement, previous: string, value: string): number | null {\n  var end = value.length - element.selectionStart;\n  if (end === 0) return end;\n  if (previous.slice(previous.length - end) !== value.slice(value.length - end)) return null;\n  return end;\n};\n\ntype Op = {\n  start: number, inserted?: string, removed?: string\n}\n\nexport function opFromInput(element: HTMLTextAreaElement, previous: string): Op | null {\n  var value = element.value;\n  if (previous === value) return null;\n\n  var start = 0;\n  // Attempt to use the DOM cursor position to find the end\n  var end = getInputEnd(element, previous, value);\n  if (end === null) {\n    // If we failed to find the end based on the cursor, do a diff. When\n    // ambiguous, prefer to locate ops at the end of the string, since users\n    // more frequently add or remove from the end of a text input\n    while (previous.charAt(start) === value.charAt(start)) {\n      start++;\n    }\n    end = 0;\n    while (\n      previous.charAt(previous.length - 1 - end) === value.charAt(value.length - 1 - end) &&\n      end + start < previous.length &&\n      end + start < value.length\n    ) {\n      end++;\n    }\n  } else {\n    while (\n      previous.charAt(start) === value.charAt(start) &&\n      start + end < previous.length &&\n      start + end < value.length\n    ) {\n      start++;\n    }\n  }\n\n  const op: Op = { start }\n  if (previous.length !== start + end) {\n    var removed = previous.slice(start, previous.length - end);\n    op.removed = removed\n  }\n  if (value.length !== start + end) {\n    var inserted = value.slice(start, value.length - end);\n    op.inserted = inserted\n  }\n  return op\n}\n\n/*\nTextDiffBinding.prototype.onInsert = function(index, length) {\n  this._transformSelectionAndUpdate(index, length, insertCursorTransform);\n};\nfunction insertCursorTransform(index, length, cursor) {\n  return (index < cursor) ? cursor + length : cursor;\n}\n\nTextDiffBinding.prototype.onRemove = function(index, length) {\n  this._transformSelectionAndUpdate(index, length, removeCursorTransform);\n};\nfunction removeCursorTransform(index, length, cursor) {\n  return (index < cursor) ? cursor - Math.min(length, cursor - index) : cursor;\n}\n\nTextDiffBinding.prototype._transformSelectionAndUpdate = function(index, length, transformCursor) {\n  if (document.activeElement === this.element) {\n    var selectionStart = transformCursor(index, length, this.element.selectionStart);\n    var selectionEnd = transformCursor(index, length, this.element.selectionEnd);\n    var selectionDirection = this.element.selectionDirection;\n    this.update();\n    this.element.setSelectionRange(selectionStart, selectionEnd, selectionDirection);\n  } else {\n    this.update();\n  }\n};\n\nTextDiffBinding.prototype.update = function() {\n  var value = this._get();\n  if (this._getElementValue() === value) return;\n  this.element.value = value;\n};\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}